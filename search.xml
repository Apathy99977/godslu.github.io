<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js接受后端流数据</title>
    <url>/2022/08/15/JS%E6%8E%A5%E6%94%B6%E5%90%8E%E7%AB%AF%E6%B5%81%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>前言：</p>
<p>本篇博客来源于各大平台知识之间的总结，如有错误，还望各大网友帮忙指正！</p>
<hr>
<h2 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">download</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> fileInfo = &#123;</span><br><span class="line">        要传的数据</span><br><span class="line">    &#125;;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;接口&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(fileInfo),</span><br><span class="line">        <span class="comment">// 向服务器发送的数据类型</span></span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><br><span class="line">        <span class="comment">//设置请求的方式，后台返回数据流，就要设置 arraybuffer，也可以设置&#x27;blob&#x27;。</span></span><br><span class="line">        <span class="attr">responseType</span>: <span class="string">&quot;arraybuffer&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">            <span class="comment">// 处理返回的文件流（data  是后台返回的数据流） new Blob  里面，type 是要下载的各类文件类型</span></span><br><span class="line">            <span class="keyword">let</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([data], &#123; <span class="attr">type</span>: <span class="string">&quot;content-type接收的文件类型&quot;</span> &#125;);</span><br><span class="line">            <span class="keyword">let</span> objectUrl = (<span class="variable language_">window</span>.<span class="property">URL</span> || <span class="variable language_">window</span>.<span class="property">webkitURL</span>).<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">            <span class="keyword">let</span> downFile = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> fileName = <span class="string">&quot;文件名称&quot;</span>;</span><br><span class="line">            downFile.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">            downFile.<span class="property">href</span> = objectUrl;</span><br><span class="line">            downFile.<span class="property">download</span> = fileName;          <span class="comment">// 下载后文件名，这个不能少，否则浏览器会跳转</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(downFile);</span><br><span class="line">            downFile.<span class="title function_">click</span>();</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(downFile);   <span class="comment">// 下载完成移除元素</span></span><br><span class="line">            <span class="comment">// window.location.href = objectUrl</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(objectUrl); <span class="comment">// 只要映射存在，Blob就不能进行垃圾回收，因此一旦不再需要引用，就必须小心撤销URL，释放掉blob对象。</span></span><br><span class="line">            parent.<span class="property">layer</span>.<span class="title function_">closeAll</span>();<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="content-type类型参考表"><a href="#content-type类型参考表" class="headerlink" title="content-type类型参考表"></a>content-type类型参考表</h2><p>最近做文件下载因为涉及到不同类型的文件，所以重新查阅了一下文件所对应的的content-type类型，好记性不如烂笔头，记录一下。</p>
<table>
<thead>
<tr>
<th>文件后缀</th>
<th align="center">MIME TYPE</th>
</tr>
</thead>
<tbody><tr>
<td>.doc</td>
<td align="center">application&#x2F;msword</td>
</tr>
<tr>
<td>.dot</td>
<td align="center">application&#x2F;msword</td>
</tr>
<tr>
<td>.docx</td>
<td align="center">application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.document</td>
</tr>
<tr>
<td>.dotx</td>
<td align="center">application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.template</td>
</tr>
<tr>
<td>.docm</td>
<td align="center">application&#x2F;vnd.ms-word.document.macroEnabled.12</td>
</tr>
<tr>
<td>.dotm</td>
<td align="center">application&#x2F;vnd.ms-word.template.macroEnabled.12</td>
</tr>
<tr>
<td>.xls</td>
<td align="center">application&#x2F;vnd.ms-excel</td>
</tr>
<tr>
<td>.xlt</td>
<td align="center">application&#x2F;vnd.ms-excel</td>
</tr>
<tr>
<td>.xla</td>
<td align="center">application&#x2F;vnd.ms-excel</td>
</tr>
<tr>
<td>.xlsx</td>
<td align="center">application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet</td>
</tr>
<tr>
<td>.xltx</td>
<td align="center">application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.template</td>
</tr>
<tr>
<td>.xlsm</td>
<td align="center">application&#x2F;vnd.ms-excel.sheet.macroEnabled.12</td>
</tr>
<tr>
<td>.xltm</td>
<td align="center">application&#x2F;vnd.ms-excel.template.macroEnabled.12</td>
</tr>
<tr>
<td>.xlam</td>
<td align="center">application&#x2F;vnd.ms-excel.addin.macroEnabled.12</td>
</tr>
<tr>
<td>.xlsb</td>
<td align="center">application&#x2F;vnd.ms-excel.sheet.binary.macroEnabled.12</td>
</tr>
<tr>
<td>.ppt</td>
<td align="center">application&#x2F;vnd.ms-powerpoint</td>
</tr>
<tr>
<td>.pot</td>
<td align="center">application&#x2F;vnd.ms-powerpoint</td>
</tr>
<tr>
<td>.pps</td>
<td align="center">application&#x2F;vnd.ms-powerpoint</td>
</tr>
<tr>
<td>.ppa</td>
<td align="center">application&#x2F;vnd.ms-powerpoint</td>
</tr>
<tr>
<td>.pptx</td>
<td align="center">application&#x2F;vnd.openxmlformats-officedocument.presentationml.presentation</td>
</tr>
<tr>
<td>.potx</td>
<td align="center">application&#x2F;vnd.openxmlformats-officedocument.presentationml.template</td>
</tr>
<tr>
<td>.ppsx</td>
<td align="center">application&#x2F;vnd.openxmlformats-officedocument.presentationml.slideshow</td>
</tr>
<tr>
<td>.ppam</td>
<td align="center">application&#x2F;vnd.ms-powerpoint.addin.macroEnabled.12</td>
</tr>
<tr>
<td>.pptm</td>
<td align="center">application&#x2F;vnd.ms-powerpoint.presentation.macroEnabled.12</td>
</tr>
<tr>
<td>.potm</td>
<td align="center">application&#x2F;vnd.ms-powerpoint.presentation.macroEnabled.12</td>
</tr>
<tr>
<td>.ppsm</td>
<td align="center">application&#x2F;vnd.ms-powerpoint.slideshow.macroEnabled.12</td>
</tr>
<tr>
<td>.zip</td>
<td align="center">application&#x2F;zip</td>
</tr>
<tr>
<td>.tar</td>
<td align="center">application&#x2F;x-tar</td>
</tr>
</tbody></table>
<p>以上总结参考来源(<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xiaoranzhizhu/article/details/70473734">https://blog.csdn.net/xiaoranzhizhu/article/details/70473734</a>)</p>
<p>接下来再补充一下基础知识</p>
<h3 id="什么是-Content-type"><a href="#什么是-Content-type" class="headerlink" title="什么是 Content-type"></a>什么是 Content-type</h3><p>Content-type是实体首部字段，用于说明请求或返回的消息是用什么格式进行编码的，在request header和response header里都有存在。 用来向服务器或者浏览器说明传输的文件格式，以便服务器和浏览器按照正确的格式进行解析。在最初的的http post请求只支持application&#x2F;x-www-form-urlencoded,参数是通过浏览器的url进行传递，但此种方法不支持文件上传，所以后来Content-type 扩充了multipart&#x2F;form-data类型以支持向服务器发送二进制数据，以及随着后面web应用的日益发展增加了application&#x2F;json的类型</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>前端流的处理</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端流的处理</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java链式调用</title>
    <url>/2022/06/18/Java%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本文为CSDN博主「ZmyCoder」的原创文章，本篇仅供学习使用，尊重原创</p>
<p>原文链接：<a href="https://blog.csdn.net/a14654/article/details/112216242">https://blog.csdn.net/a14654/article/details/112216242</a></p>
<hr>
<p>之前接入支付宝支付接口的时候，看到支付宝提供的demo中有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建扫码支付请求builder，设置请求参数</span></span><br><span class="line">	        <span class="type">AlipayTradePrecreateRequestBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePrecreateRequestBuilder</span>()</span><br><span class="line">	            .setSubject(subject)<span class="comment">//订单主题</span></span><br><span class="line">	            .setTotalAmount(totalAmount)<span class="comment">//订单总金额，单位为元</span></span><br><span class="line">	            .setOutTradeNo(outTradeNo)<span class="comment">//订单号</span></span><br><span class="line">	            .setUndiscountableAmount(undiscountableAmount)<span class="comment">//默认0.0</span></span><br><span class="line">	            .setSellerId(sellerId)<span class="comment">//卖家支付宝账号ID</span></span><br><span class="line">	            .setBody(body)<span class="comment">//订单描述</span></span><br><span class="line">	            .setOperatorId(operatorId)<span class="comment">//商户操作员编号 13688889999</span></span><br><span class="line">	            .setStoreId(storeId)<span class="comment">//商户门店编号</span></span><br><span class="line">	            .setExtendParams(extendParams)<span class="comment">//业务扩展参数</span></span><br><span class="line">	            .setTimeoutExpress(timeoutExpress)<span class="comment">//支付超时</span></span><br><span class="line">	            .setNotifyUrl(<span class="string">&quot;http://www.test-notify-url.com&quot;</span>)<span class="comment">//支付宝服务器主动通知商户服务器里</span></span><br><span class="line">	            											   <span class="comment">//指定的页面http路径,根据需要设置</span></span><br><span class="line">	            .setGoodsDetailList(goodsDetailList);<span class="comment">//商品明细列表</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>当时在开发没顾得上去了解，现在闲了一点，在看<a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a>，今天看到建造者模式，看到代码形态是差不多的，才知道这java链式调用。<br>废话不多说，直接用代码来介绍java链式调用。</p>
<p>一般，我们在创建javaBean的时候，采用的是new关键字来创建的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">computer.setCPU(<span class="string">&quot;inter-i5&quot;</span>);</span><br><span class="line">computer.setGPU(<span class="string">&quot;GTX-960&quot;</span>);</span><br><span class="line">computer.setMemoryType(<span class="string">&quot;ddr3 1666MHz&quot;</span>);</span><br><span class="line">computer.setMemorySize(<span class="number">8</span>);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>而采用链式调用的写法的话，则是不一样的风格，这种风格更适合人类的思维，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.Builder()</span><br><span class="line">        .setCPU(<span class="string">&quot;inter-skylake-i7&quot;</span>)</span><br><span class="line">        .setGPU(<span class="string">&quot;GTX-Titan&quot;</span>)</span><br><span class="line">        .setMemoryType(<span class="string">&quot;ddr4-2133MHz&quot;</span>)</span><br><span class="line">        .setMemorySize(<span class="number">16</span>)</span><br><span class="line">        .setStorageType(<span class="string">&quot;ssd&quot;</span>)</span><br><span class="line">        .setStorageSize(<span class="number">512</span>)</span><br><span class="line">        .setScreenType(<span class="string">&quot;IPS&quot;</span>)</span><br><span class="line">        .setScreenSize(<span class="number">28</span>)</span><br><span class="line">        .setOSType(<span class="string">&quot;Ubuntu/Window10&quot;</span>)</span><br><span class="line">        .create();</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>下面就是Computer的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String CPU;</span><br><span class="line">	<span class="keyword">private</span> String GPU;</span><br><span class="line">	<span class="keyword">private</span> String memoryType;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> memorySize;</span><br><span class="line">	<span class="keyword">private</span> String storageType;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> storageSize;</span><br><span class="line">	<span class="keyword">private</span> String screenType;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">float</span> screenSize;</span><br><span class="line">	<span class="keyword">private</span> String OSType;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造方法私有化</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">		CPU = builder.CPU;</span><br><span class="line">		GPU = builder.GPU;</span><br><span class="line">		memoryType = builder.memoryType;</span><br><span class="line">		memorySize = builder.memorySize;</span><br><span class="line">		storageType = builder.storageType;</span><br><span class="line">		storageSize = builder.storageSize;</span><br><span class="line">		screenType = builder.screenType;</span><br><span class="line">		screenSize = builder.screenSize;</span><br><span class="line">		OSType = builder.OSType;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">		<span class="comment">// Optional parameters - initialize with default values</span></span><br><span class="line">		<span class="keyword">private</span> String CPU;</span><br><span class="line">		<span class="keyword">private</span> String GPU;</span><br><span class="line">		<span class="keyword">private</span> String memoryType;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> memorySize;</span><br><span class="line">		<span class="keyword">private</span> String storageType;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> storageSize;</span><br><span class="line">		<span class="keyword">private</span> String screenType;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">float</span> screenSize;</span><br><span class="line">		<span class="keyword">private</span> String OSType;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 提供调用入口</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@author</span> niwei</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@time</span>   2018下午7:34:26</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> Computer <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setCPU</span><span class="params">(String CPU)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.CPU = CPU;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setGPU</span><span class="params">(String GPU)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.GPU = GPU;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setMemoryType</span><span class="params">(String memoryType)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.memoryType = memoryType;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setMemorySize</span><span class="params">(<span class="type">int</span> memorySize)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.memorySize = memorySize;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setStorageType</span><span class="params">(String storageType)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.storageType = storageType;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setStorageSize</span><span class="params">(<span class="type">int</span> storageSize)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.storageSize = storageSize;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setScreenType</span><span class="params">(String screenType)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.screenType = screenType;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setScreenSize</span><span class="params">(<span class="type">float</span> screenSize)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.screenSize = screenSize;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setOSType</span><span class="params">(String OSType)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.OSType = OSType;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充部分：</p>
<p>先说一下这么写的好处在于一方面可以尽可能的少去类型转换的判定，而且大大增强了代码的阅读性，也就是更符合人类阅读的习惯，同时也减少了代码量。</p>
<p>下面通过一个小例子来演示一下链式编程：</p>
<p>public class LinkMan {</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式接口调用时，返回值类型和link该对象类型保持一致</span></span><br><span class="line"><span class="comment">//返回值类型为LinkMan</span></span><br><span class="line"><span class="keyword">public</span> LinkMan <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LinkMan <span class="title function_">setTitle</span><span class="params">(String title)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.title = title;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LinkMan <span class="title function_">setAge</span><span class="params">(Integer age)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;name： &quot;</span> + name + <span class="string">&quot; title: &quot;</span> + title + <span class="string">&quot; age: &quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LinkMan</span> <span class="variable">linkMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkMan</span>().setName(<span class="string">&quot;NIKE&quot;</span>).setTitle(<span class="string">&quot;测试&quot;</span>).setAge(<span class="number">26</span>);</span><br><span class="line">System.out.println(linkMan.toString());</span><br><span class="line">System.out.println(linkMan.getName());</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">name：</span> <span class="string">NIKE title: 测试  age: 26</span></span><br><span class="line"><span class="attr">NIKE</span></span><br></pre></td></tr></table></figure>

<p>总结：链式调用有个缺点，一般情况下，JavaBean类中是写getter&#x2F;setter的，可以使用ide快速生成，而链式调用需要手动写setter部分的代码（可以先用ide生成，然后手动改相关的setter部分代码，通过这种方式来减少工作量），不过只要在Java Bean写完一次，在别的地方调用就方便了很多，有得有失，代码之道啊：）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis缓存</title>
    <url>/2022/06/26/MyBatis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="MyBtais缓存"><a href="#MyBtais缓存" class="headerlink" title="MyBtais缓存"></a>MyBtais缓存</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>Mybatis的二级缓存其实默认是开启的，但我们需要指定每个mapper的缓存策略二级缓存才会生效，如何不配置缓存策略二级缓存则不生效。</p>
<h2 id="开启二级缓存与配置缓存策略："><a href="#开启二级缓存与配置缓存策略：" class="headerlink" title="开启二级缓存与配置缓存策略："></a>开启二级缓存与配置缓存策略：</h2><p><strong>开启二级缓存：</strong></p>
<p>默认是开启的</p>
<p>首先在全局配置文件 mybatis-configuration.xml 文件中加入如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启二级缓存  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>配置缓存策略：</strong></p>
<p>在Mybatis的映射Mapper XML文件中设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到 mapper.xml 文件中就这么一个空标签<cache/>，其实这里可以配置<cache type="org.apache.ibatis.cache.impl.PerpetualCache"/>,PerpetualCache这个类是mybatis默认实现缓存功能的类。我们不写type就使用mybatis默认的缓存，也可以去实现 Cache 接口来自定义缓存。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="执行过程讲解："><a href="#执行过程讲解：" class="headerlink" title="执行过程讲解："></a>执行过程讲解：</h2><h3 id="运行环境："><a href="#运行环境：" class="headerlink" title="运行环境："></a>运行环境：</h3><p>这里我们可以证实Mybtis二级缓存是默认开启的，我们只需要配置缓存策略即可使用二级缓存</p>
<p><strong>启动类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;SqlMapperConfig.xml&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; byId = mapper.findById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        byId = mapper.findById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>mapper接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <strong>mapper接口映射xml：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.Dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    设置二级缓存策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>MyBatis配置文件：</strong></p>
<p>没有去开启二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    注意先后顺序--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    通过properties标签使用properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    设置UserMapper中的类型别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.example.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置数据源环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;dataSourceJDBC&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceJDBC&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com.mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p>第一次执行mapper.findById(1);</p>
<p>他会先去获取缓存中的映射方法，如果未获取到则进行创建，并将创建的映射方法存入缓存中</p>
<p><a href="https://imgtu.com/i/jAHS0K"><img src="https://s1.ax1x.com/2022/06/26/jAHS0K.jpg" alt="jAHS0K.jpg"></a></p>
<p><strong>执行execute</strong>：</p>
<p>运行执行器，会先判断当前为什么类型的SQL，如果为SELECT的sql又会分为多结果等等方法，这个为多结果的查询sql所以运行多结果执行方法</p>
<p><a href="https://imgtu.com/i/jESdqH"><img src="https://s1.ax1x.com/2022/06/26/jESdqH.jpg" alt="jESdqH.jpg"></a></p>
<p><strong>运行多结果执行器：</strong></p>
<p>判断当前方法是否有边界索引，没有进行查询</p>
<p><a href="https://imgtu.com/i/jEpbtI"><img src="https://s1.ax1x.com/2022/06/26/jEpbtI.jpg" alt="jEpbtI.jpg"></a></p>
<p><strong>SelectList查询方法：</strong></p>
<p>先获取配置文件中的映射语句，再进行query查询</p>
<p><a href="https://imgtu.com/i/jEpqht"><img src="https://s1.ax1x.com/2022/06/26/jEpqht.jpg" alt="jEpqht.jpg"></a></p>
<p><strong>query查询方法（CachingExecutor类）重载方法：</strong></p>
<p>通过映射语句MappedStatement获取SQL,再进行其他的一些参数生成一个key之后用来获取缓存中的结果值</p>
<p><a href="https://imgtu.com/i/jEpT7d"><img src="https://s1.ax1x.com/2022/06/26/jEpT7d.jpg" alt="jEpT7d.jpg"></a></p>
<p><strong>query方法（CachingExecutor类）重载方法：</strong></p>
<p>判断是否开启了二级缓存，没有二级缓存则进行一级缓存的查询，一级缓存还会进行本地缓存的一个获取，没有才进行数据库查询</p>
<p>如果开启了二级缓存，则进行二级的一个查询，如果有就进行返回结果，并将结果加入到二级缓存，没有还是进行一个一级缓存的查询</p>
<p><a href="https://imgtu.com/i/jEpHAA"><img src="https://s1.ax1x.com/2022/06/26/jEpHAA.jpg" alt="jEpHAA.jpg"></a></p>
<p><strong>一级缓存先是进行一个本地缓存的查询，如果本地缓存没有数据就进行数据库查询，查询后会放入本地缓存</strong></p>
]]></content>
      <categories>
        <category>Mybatis</category>
        <category>java</category>
        <category>缓存原理</category>
        <category>持久层框架</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>java</tag>
        <tag>Mybatis</tag>
        <tag>持久层框架</tag>
        <tag>缓存原理</tag>
      </tags>
  </entry>
  <entry>
    <title>React通过useEffect使用定时器</title>
    <url>/2022/08/09/React%E9%80%9A%E8%BF%87useEffect%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>使用场景：页面刷新数据，页面获取当前时间等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开启定时器&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入定时器&#x27;</span>)</span><br><span class="line">      <span class="comment">// 注:在setCount中使用箭头函数是最好方式之一,只有一个timer生成</span></span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>) </span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;清除定时器&#x27;</span>)</span><br><span class="line">      <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []) <span class="comment">//如果设置count依赖,会有多个timer生成,销毁</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>注意：如果切换到其他页面，不清除定时器的时候控制台会出现报错，翻译过来就是“无法对已卸载的组件执行反应状态更新。这是一个no-op，但它表示应用程序中存在内存泄漏。若要修复，请取消useffect清除函数中的所有订阅和异步任务。在time这个组件”</p>
<p>所以各位销毁组件时千万要把定时器一起清除掉，否则容易出现一些奇奇怪怪的错误！</p>
]]></content>
      <categories>
        <category>React</category>
        <category>前端三大基础</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>React</tag>
        <tag>前端定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>React快速入门</title>
    <url>/2022/07/07/React%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程讲解了React的快速入门，不多BB，直接全是干货，请尊重原创，如需转载请备注原创链接！</p>
<hr>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h2><p>React官网：<a href="https://react.docschina.org/">https://react.docschina.org/</a></p>
<h3 id="什么是React？"><a href="#什么是React？" class="headerlink" title="什么是React？"></a>什么是React？</h3><p>用官网的一句话概括就是用于构建用户界面的 JavaScript 库</p>
<p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712084610159.png" alt="image-20220712084610159"></p>
<h3 id="React的好处是什么？"><a href="#React的好处是什么？" class="headerlink" title="React的好处是什么？"></a>React的好处是什么？</h3><p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712085102954.png" alt="image-20220712085102954"></p>
<h3 id="React和vue的区别："><a href="#React和vue的区别：" class="headerlink" title="React和vue的区别："></a>React和vue的区别：</h3><p><strong>1、监听数据变化的实现原理不同</strong></p>
<p>Vue通过 getter&#x2F;setter以及一些函数的劫持，能精确知道数据变化。</p>
<p>React默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。为什么React不精确监听数据变化呢？这是因为Vue和React设计理念上的区别，Vue使用的是可变数据，而React更强调数据的不可变，两者没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。</p>
<p><strong>2、数据流的不同</strong></p>
<p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712090026315.png" alt="image-20220712090026315"></p>
<p>Vue1.0中可以实现两种双向绑定：父子组件之间，props可以双向绑定；组件与DOM之间可以通过v-model双向绑定。Vue2.x中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且Vue2.x已经不鼓励组件对自己的 props进行任何修改了。</p>
<p>React一直不支持双向绑定，提倡的是单向数据流，称之为onChange&#x2F;setState()模式。不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</p>
<p><strong>3、HoC和mixins</strong></p>
<p>Vue组合不同功能的方式是通过mixin，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。比如我们定义的模板怎么被编译的？比如声明的props怎么接收到的？这些都是vue创建组件实例的时候隐式干的事。由于vue默默帮我们做了这么多事，所以我们自己如果直接把组件的声明包装一下，返回一个HoC，那么这个被包装的组件就无法正常工作了。</p>
<p>React组合不同功能的方式是通过HoC(高阶组件）。React最早也是使用mixins的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了mixinx转而使用HoC。高阶组件本质就是高阶函数，React的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。</p>
<p><strong>4、组件通信的区别</strong></p>
<p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712090051265.png" alt="image-20220712090051265"></p>
<p>Vue中有三种方式可以实现组件通信：父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据；子组件通过事件向父组件发送消息；通过V2.2.0中新增的provide&#x2F;inject来实现父组件向子组件注入数据，可以跨越多个层级。</p>
<p>React中也有对应的三种方式：父组件通过props可以向子组件传递数据或者回调；可以通过 context 进行跨层级的通信，这其实和 provide&#x2F;inject 起到的作用差不多。React 本身并不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数，但Vue更倾向于使用事件。在React中我们都是使用回调函数的，这可能是他们二者最大的区别。</p>
<p><strong>5、模板渲染方式的不同</strong></p>
<p>在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。</p>
<p>在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。</p>
<p>举个例子，说明React的好处：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。</p>
<p><strong>6、渲染过程不同</strong></p>
<p>Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p>
<p>React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。</p>
<p>如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。</p>
<p><strong>7、框架本质不同</strong></p>
<p>Vue本质是MVVM框架，由MVC发展而来；</p>
<p>React是前端组件化框架，由后端组件化发展而来。</p>
<p><strong>8、Vuex和Redux的区别</strong></p>
<p>从表面上来说，store注入和使用方式有一些区别。在Vuex中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store来读取数据。在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。</p>
<p>从实现原理上来说，最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter&#x2F;setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用Vue的感觉。</p>
<p><strong>9、React是国际比较主流的MV*框架，而vue是MVVM框架，vue3也是参考了react进行的编写，React可以进行小程序编写</strong></p>
<h3 id="npx创建脚手架和vue中npm创建脚手架的区别："><a href="#npx创建脚手架和vue中npm创建脚手架的区别：" class="headerlink" title="npx创建脚手架和vue中npm创建脚手架的区别："></a>npx创建脚手架和vue中npm创建脚手架的区别：</h3><p>vue中npm创建脚手架的话只能在当前使用的node版本创建，比如你现在用的是14.6.0，你此时使用npm创建脚手架时只能在当前版本使用，换个版本的node的话只能重新安装，这样容易造成资源的浪费</p>
<p>React中npx创建脚手架的话会在创建完项目之后把本地的删除掉，好处就是不会造成资源的浪费并且时刻可以保持和官网版本同步</p>
<blockquote>
<p>npm创建脚手架命令：npm    i    @vue&#x2F;cli  -g</p>
</blockquote>
<blockquote>
<p>npx创建脚手架命令：npx  create-react-app   项目名称</p>
</blockquote>
<h3 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h3><p>JSX就是JS+XML，使用JSX去编写项目就可以直接在JS中直接写HTML代码，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloMessage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Hello &#123;this.props.name&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">&quot;Taylor&quot;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hello-example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="第一个React项目"><a href="#第一个React项目" class="headerlink" title="第一个React项目"></a>第一个React项目</h2><h3 id="使用脚手架创建"><a href="#使用脚手架创建" class="headerlink" title="使用脚手架创建"></a>使用脚手架创建</h3><p>1、在文件夹下面打开cmd命令窗口：然后输入：npx  create-react-app   项目名称</p>
<p>2、创建好后用vscode打开，打开一个React项目先看package.json文件，因为在工作中大部人都是接盘侠，README.md文件一般都是被修改了</p>
<p>3、直接npm run start启动项目，其中run可以省略，但本人推荐写上，因为React项目比较大，所以要稍微等一会，启动后看到下面的图片就意味着你成功了：</p>
<p><img src="D:\FrontEnd\React\笔记\React笔记图片\image-20220712174326734.png" alt="image-20220712174326734"></p>
]]></content>
      <categories>
        <category>React</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>React</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis快速入门</title>
    <url>/2022/08/08/Redis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程是根据B站Up主狂神说记得笔记，有需要查看视频的小伙伴可以去看看狂神的视频，真的非常好！</p>
<p>狂神说Redis视频地址：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV1S54y1R7SB?vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p>
<hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h2><h3 id="为什么使用Nosql"><a href="#为什么使用Nosql" class="headerlink" title="为什么使用Nosql"></a>为什么使用Nosql</h3><blockquote>
<p>1、单机Mysql时代</p>
</blockquote>
<p><img src="D:\Microservices\Redis\笔记\Redis笔记图片\image-20220811173021688.png" alt="image-20220811173021688"></p>
<p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p>
<ol>
<li>数据量增加到一定程度，单机数据库就放不下了</li>
<li>数据的索引（B+ Tree）,一个机器内存也存放不下</li>
<li>访问量变大后（读写混合），一台服务器承受不住。</li>
</ol>
<blockquote>
<p>2、<a href="https://so.csdn.net/so/search?q=Memcached&spm=1001.2101.3001.7020">Memcached</a>(缓存) + Mysql + 垂直拆分（读写分离）</p>
</blockquote>
<p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p>
<p>发展过程∶优化数据结构和索引–&gt;文件缓存(IO )） —&gt; Memcached（当时最热门的技术!)</p>
<p><img src="D:\Microservices\Redis\笔记\Redis笔记图片\image-20220812092858924.png" alt="image-20220812092858924"></p>
<p>优化过程经历了以下几个过程：</p>
<ol>
<li><p>优化数据库的数据结构和索引(难度大)</p>
</li>
<li><p>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</p>
</li>
<li><p>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</p>
</li>
</ol>
<blockquote>
<p>3、分库分表 + 水平拆分 + Mysql集群</p>
</blockquote>
<p>技术和业务在发展的同时，对人的要求也越来越高!</p>
<p>本质︰数据库（读，写)</p>
<p>早些年MylSAM:表锁，十分影响效率!高并发下就会出现严重的锁问题</p>
<p>转战lnnodb :行锁</p>
<p>慢慢的就开始使用分库分表来解决写的压力!</p>
<p><img src="D:\Microservices\Redis\笔记\Redis笔记图片\image-20220812094641367.png" alt="image-20220812094641367"></p>
<blockquote>
<p>4、如今最近的年代</p>
</blockquote>
<ul>
<li>2010–2020十年之间，世界已经发生了翻天覆地的变化;(定位，也是一种数据，音乐，热榜! )</li>
<li>MySQL等关系型数据库就不够用了!数据量很多，变化很快~!</li>
<li>MySQL有的使用它来村粗一些比较大的文件，博客，图片!数据库表很大，效率就低了!如果有一种数据库来专门处理这种数据</li>
<li>MySQL压力就变得十分小（研究如何处理这些问题!)大数据的IO压力下，表几乎没法更大!</li>
</ul>
<p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p>
<blockquote>
<p>目前一个基本的互联网项目</p>
</blockquote>
<p><img src="D:\Microservices\Redis\笔记\Redis笔记图片\image-20220812100841012.png" alt="image-20220812100841012"></p>
<blockquote>
<p>为什么要用NoSQL ？</p>
</blockquote>
<p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！</p>
<p>这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p>
<h3 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h3><p>NoSQL &#x3D; Not Only SQL（不仅仅是SQL）</p>
<p>Not Only Structured Query Language</p>
<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>
<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>
<p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p>
<h3 id="Nosql特点"><a href="#Nosql特点" class="headerlink" title="Nosql特点"></a>Nosql特点</h3><ol>
<li><p>方便扩展（数据之间没有关系，很好扩展！）</p>
</li>
<li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p>
</li>
<li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p>
</li>
<li><p>传统的 RDBMS 和 NoSQL</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">传统的 RDBMS(关系型数据库)</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Nosql</span><br><span class="line"></span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE</span><br><span class="line">- 高性能，高可用，高扩展</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>了解：3V + 3高</p>
</blockquote>
<p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p>
<ol>
<li><p>海量Velume</p>
</li>
<li><p>多样Variety</p>
</li>
<li><p>实时Velocity</p>
</li>
</ol>
<p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p>
<ol>
<li><p>高并发</p>
</li>
<li><p>高可扩</p>
</li>
<li><p>高性能</p>
</li>
</ol>
<p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p>
<h2 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h2><p>推荐阅读：阿里云的这群疯子<a href="https://yq.aliyun.com/articles/653511">https://yq.aliyun.com/articles/653511</a></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>非关系型数据库</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity_JWT快速入门</title>
    <url>/2022/06/18/SpringSecurity_JWT%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程是根据B站Up主字母哥记得笔记，有需要查看视频的小伙伴可以去看看字母哥的视频</p>
<p>字母哥SpringSecurity视频地址：<a href="https://www.bilibili.com/video/BV16J41127jq?p=1&amp;vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV16J41127jq?p=1&amp;vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p>
<hr>
]]></content>
      <categories>
        <category>SpringSecurity</category>
        <category>JWT</category>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>SpringSecurity</tag>
        <tag>JWT</tag>
        <tag>安全框架</tag>
      </tags>
  </entry>
  <entry>
    <title>博客技术总结</title>
    <url>/2022/05/14/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-技术介绍"><a href="#1-技术介绍" class="headerlink" title="1.技术介绍"></a>1.技术介绍</h1><p>前端：vue + vuex + vue-router + axios + vuetify + element + echarts</p>
<p>后端：SpringBoot + nginx + SpringSecurity + Swagger2 + MyBatisPlus + Mysql + Redis + elasticsearch + rabbitMQ + MaxWell</p>
<h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2.运行环境"></a>2.运行环境</h1><p>开发工具：IDEA</p>
<p>服务器：阿里云1核2G CentOS8.0以上</p>
<p>对象存储：阿里云OSS</p>
<p>全站cdn加速</p>
<p>cos对象储存</p>
<p>全站https</p>
<h1 id="3-项目总结"><a href="#3-项目总结" class="headerlink" title="3.项目总结"></a>3.项目总结</h1><p>此次对博客进行了全方位的升级，前端技术点和后端技术点相比第一，二版提升了不少。</p>
<p>加入了许多动画过渡效果，并考虑到了一些用户细节（深色模式，图片预览，等），评论加入了表情和分页，提升了用户体验，。后台文章编辑器换为MarkDown，语法更加简洁，新增了草稿箱和自动保存文章等功能。</p>
]]></content>
  </entry>
  <entry>
    <title>Git快速入门</title>
    <url>/2022/05/24/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程是根据B站Up主狂神说记得笔记，有需要查看视频的小伙伴可以去看看狂神的视频，真的非常好！</p>
<p>狂神说Git视频地址：<a href="https://www.bilibili.com/video/BV1FE411P7B3?vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV1FE411P7B3?vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p>
<hr>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="什么是版本控制？"><a href="#什么是版本控制？" class="headerlink" title="什么是版本控制？"></a>什么是版本控制？</h3><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<ul>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>
</ul>
<p>简单说就是用于管理多人协同开发项目的技术。</p>
<p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件<strong>代码的一致性</strong>、软件<strong>内容的冗余</strong>、软件<strong>过程的事物性</strong>、软件<strong>开发过程中的并发性</strong>、软件源<strong>代码的安全性</strong>，以及<strong>软件的整合</strong>等问题。</p>
<p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段，比如写方案的时候客户总是要求改，最后可能又觉得第一版好，然而有的时候你的历史版本可能已经被你删除了，这个时候我们就迫切需要一个版本控制工具！多人开发时就会有更多的问题，所以多人开发就必须要使用版本控制！</p>
<h3 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h3><p>我们学习的东西，一定是当下最流行的！</p>
<p>主流的版本控制器有如下这些：</p>
<ul>
<li><strong>Git</strong></li>
<li><strong>SVN</strong>（Subversion）</li>
<li><strong>CVS</strong>（Concurrent Versions System）</li>
<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>
<li><strong>TFS</strong>（Team Foundation Server）</li>
<li>Visual Studio Online</li>
</ul>
<p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p>
<h3 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h3><h4 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a><strong>本地版本控制</strong></h4><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p>
<p><a href="https://imgtu.com/i/jmZwRS"><img src="https://s1.ax1x.com/2022/06/29/jmZwRS.png" alt="jmZwRS.png"></a></p>
<h4 id="集中版本控制-SVN"><a href="#集中版本控制-SVN" class="headerlink" title="集中版本控制  SVN"></a><strong>集中版本控制  SVN</strong></h4><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>
<p><a href="https://imgtu.com/i/jmZaPf"><img src="https://s1.ax1x.com/2022/06/29/jmZaPf.png" alt="jmZaPf.png"></a></p>
<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p>
<h4 id="分布式版本控制-Git"><a href="#分布式版本控制-Git" class="headerlink" title="分布式版本控制 	Git"></a><strong>分布式版本控制 	Git</strong></h4><p>每个人都拥有全部的代码！安全隐患！</p>
<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>
<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>
<p><a href="https://imgtu.com/i/jmZdG8"><img src="https://s1.ax1x.com/2022/06/29/jmZdG8.png" alt="jmZdG8.png"></a></p>
<h2 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p><a href="https://imgtu.com/i/jmZNIP"><img src="https://s1.ax1x.com/2022/06/29/jmZNIP.png" alt="jmZNIP.png"></a></p>
<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<h2 id="Git的历史"><a href="#Git的历史" class="headerlink" title="Git的历史"></a>Git的历史</h2><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p>
<p><a href="https://imgtu.com/i/jmZtat"><img src="https://s1.ax1x.com/2022/06/29/jmZtat.png" alt="jmZtat.png"></a></p>
<p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p>
<h2 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h2><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p>打开 [git官网] <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p>
<p>所有东西下载慢的话就可以去找镜像！</p>
<p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p>
<p><a href="https://imgtu.com/i/jmZ6Zn"><img src="https://s1.ax1x.com/2022/06/29/jmZ6Zn.png" alt="jmZ6Zn.png"></a></p>
<p>下载对应的版本即可安装！</p>
<p>安装：无脑下一步即可！安装完毕就可以使用了！</p>
<p>卸载的话先删除对应的环境变量然后直接卸载软件即可</p>
<p>直接反安装即可、然后清理环境变量，环境变量只是为了全局使用而已</p>
<h3 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h3><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p>
<p><a href="https://imgtu.com/i/jmZDMQ"><img src="https://s1.ax1x.com/2022/06/29/jmZDMQ.png" alt="jmZDMQ.png"></a></p>
<p><strong>Git Bash：</strong> Unix与Linux风格的命令行，使用最多，推荐最多</p>
<p><strong>Git CMD：</strong> Windows风格的命令行</p>
<p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p>
<h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p>
<ol>
<li><p>cd : 改变目录。</p>
</li>
<li><p>cd . . 回退到上一个目录，直接cd进入默认目录</p>
</li>
<li><p>pwd : 显示当前所在的目录路径。</p>
</li>
<li><p>ls，ll:  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>
</li>
<li><p>touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>
</li>
<li><p>rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>
</li>
<li><p>mkdir:  新建一个目录,就是新建一个文件夹。</p>
</li>
<li><p>rm -r :  删除一个文件夹, rm -r src 删除src目录</p>
</li>
<li><p>rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！</p>
</li>
<li><p>mv 移动文件, mv index.html src test 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下,其中src也可以省略</p>
</li>
<li><p>reset 重新初始化终端&#x2F;清屏。</p>
</li>
<li><p>clear 清屏。</p>
</li>
<li><p>history 查看命令历史。</p>
</li>
<li><p>help 帮助。</p>
</li>
<li><p>exit 退出。</p>
</li>
<li><p>‘#’表示注释，一般不要随便加</p>
</li>
</ol>
<h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>所有的配置文件，其实都保存在本地！</p>
<p>查看配置 git config -l</p>
<p><a href="https://imgtu.com/i/jmZ0xg"><img src="https://s1.ax1x.com/2022/06/29/jmZ0xg.png" alt="jmZ0xg.png"></a></p>
<p>查看不同级别的配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看系统config</span></span><br><span class="line"><span class="attr">git</span> <span class="string">config --system --list</span></span><br><span class="line"><span class="comment">　　</span></span><br><span class="line"><span class="comment">#查看当前用户（global）配置</span></span><br><span class="line"><span class="attr">git</span> <span class="string">config --global  --list</span></span><br></pre></td></tr></table></figure>

<h3 id="Git相关的配置文件："><a href="#Git相关的配置文件：" class="headerlink" title="Git相关的配置文件："></a><strong>Git相关的配置文件：</strong></h3><ol>
<li>Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</li>
<li>C:\Users\Apathy\ .gitconfig         只适用于当前登录用户的配置  –global 全局</li>
</ol>
<p><a href="https://imgtu.com/i/jmntaR"><img src="https://s1.ax1x.com/2022/06/29/jmntaR.jpg" alt="jmntaR.jpg"></a></p>
<p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>
<h3 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h3><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">config --global user.name &quot;gods&quot;  #名称</span></span><br><span class="line"><span class="attr">git</span> <span class="string">config --global user.email apathygods@qq.com   #邮箱</span></span><br></pre></td></tr></table></figure>

<p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>
<p><a href="https://imgtu.com/i/jmnYZ9"><img src="https://s1.ax1x.com/2022/06/29/jmnYZ9.jpg" alt="jmnYZ9.jpg"></a></p>
<h2 id="Git基本理论（重要）"><a href="#Git基本理论（重要）" class="headerlink" title="Git基本理论（重要）"></a>Git基本理论（重要）</h2><h3 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><a href="https://imgtu.com/i/jmZcaq"><img src="https://s1.ax1x.com/2022/06/29/jmZcaq.png" alt="jmZcaq.png"></a></p>
<ul>
<li>Workspace：工作区，就是你平时存放项目代码的地方</li>
<li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p>
<p><a href="https://imgtu.com/i/jmZgI0"><img src="https://s1.ax1x.com/2022/06/29/jmZgI0.png" alt="jmZgI0.png"></a></p>
<ul>
<li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li>
<li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li>
<li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li>
<li>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li>
<li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li>
<li>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复WorkSpace中的临时状态。</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>git的工作流程一般是这样的：</p>
<ol>
<li>在工作目录中添加、修改文件；      UserMapper.xml</li>
<li>将需要进行版本管理的文件放入暂存区域；    命令：git add.</li>
<li>将暂存区域的文件提交到git仓库。        命令:git commit</li>
</ol>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>
<p><a href="https://imgtu.com/i/jmZRiV"><img src="https://s1.ax1x.com/2022/06/29/jmZRiV.png" alt="jmZRiV.png"></a></p>
<h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h2><h3 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h3><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>
<p>日常使用只要记住下图6个命令：</p>
<p><a href="https://imgtu.com/i/jmZWGT"><img src="https://s1.ax1x.com/2022/06/29/jmZWGT.png" alt="jmZWGT.png"></a></p>
<h3 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<ol>
<li><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&#x27;#&#x27;</span> <span class="string">在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="attr">&#x27;$&#x27;</span> <span class="string">git init</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面,记得勾选显示隐藏的项目</p>
<p> <a href="https://imgtu.com/i/jmZfRU"><img src="https://s1.ax1x.com/2022/06/29/jmZfRU.png" alt="jmZfRU.png"></a></p>
</li>
</ol>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><ol>
<li><p>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;#&#x27; 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">&#x27;$&#x27; git clone [url]  &#x27;#&#x27; https://gitee.com/kuangstudy/openclass.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>去 gitee 或者 github 上克隆一个测试！</p>
</li>
</ol>
<h2 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h2><h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>
<li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li>
<li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>
<li><strong>Staged</strong>: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line"><span class="attr">git</span> <span class="string">status [filename]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line"><span class="attr">git</span> <span class="string">status</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># git add .                  添加所有文件到暂存区</span></span><br><span class="line"><span class="comment"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure>

<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>
<ol>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为注释</span></span><br><span class="line"><span class="attr">*.txt</span>        <span class="string">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span></span><br><span class="line"><span class="comment">!lib.txt     #但lib.txt除外</span></span><br><span class="line"><span class="attr">/temp</span>        <span class="string">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line"><span class="attr">build/</span>       <span class="string">#忽略build/目录下的所有文件</span></span><br><span class="line"><span class="attr">doc/*.txt</span>    <span class="string">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><p>由于GitHub是国外的网站，所以一般访问时间较慢，这里推荐使用国内的镜像Gitee，公司中有时候也会搭建自己的gitlab服务器</p>
<ol>
<li><p>注册并登录<a href="https://gitee.com/">码云</a>，然后完善个人信息</p>
<p> <a href="https://imgtu.com/i/jmZ5M4"><img src="https://s1.ax1x.com/2022/06/29/jmZ5M4.png" alt="jmZ5M4.png"></a></p>
</li>
<li><p>生成一个新的<a href="https://so.csdn.net/so/search?q=SSH&spm=1001.2101.3001.7020">SSH</a>密钥打开 Git Bash，输入如下命令，然后连续按三个回车即可：</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ssh-keygen</span> <span class="string">-t rsa -C &quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p> <a href="https://imgtu.com/i/jmnGqJ"><img src="https://s1.ax1x.com/2022/06/29/jmnGqJ.jpg" alt="jmnGqJ.jpg"></a></p>
</li>
<li><p>将.pub文件里面的公钥信息添加到码云账户中即可！</p>
<p> <a href="https://imgtu.com/i/jmn8r4"><img src="https://s1.ax1x.com/2022/06/29/jmn8r4.jpg" alt="jmn8r4.jpg"></a></p>
</li>
<li><p>学习使用码云创建一个自己的远程仓库</p>
<p> <a href="https://imgtu.com/i/jmZ7ZR"><img src="https://s1.ax1x.com/2022/06/29/jmZ7ZR.png" alt="jmZ7ZR.png"></a><br> 许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载等等，主要做一些限制！</p>
<p><a href="https://imgtu.com/i/jmZbIx"><img src="https://s1.ax1x.com/2022/06/29/jmZbIx.png" alt="jmZbIx.png"></a></p>
</li>
</ol>
<h2 id="IDEA中集成Git"><a href="#IDEA中集成Git" class="headerlink" title="IDEA中集成Git"></a>IDEA中集成Git</h2><p>   1、 在项目中绑定git，将自己远程的git文件目录拷贝到项目即可<br>       <a href="https://imgtu.com/i/jmZLi6"><img src="https://s1.ax1x.com/2022/06/29/jmZLi6.png" alt="jmZLi6.png"></a><br>       项目拷贝完后idea会新增几个git的按钮<br>       <a href="https://imgtu.com/i/jmZXRO"><img src="https://s1.ax1x.com/2022/06/29/jmZXRO.png" alt="jmZXRO.png"></a><br>   2、 修改文件，使用IDEA操作git<br>       add 添加到暂存区</p>
<pre><code>   commit 提交
   
   push到远程仓库
   
</code></pre>
<p>   3、 刷新远程仓库发现已经发送过去了<br>       <a href="https://imgtu.com/i/jmZOJK"><img src="https://s1.ax1x.com/2022/06/29/jmZOJK.png" alt="jmZOJK.png"></a></p>
<h2 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h2><h3 id="什么是分支？"><a href="#什么是分支？" class="headerlink" title="什么是分支？"></a>什么是分支？</h3><p>分支就像地球和太阳，如果他们互不干扰的话，对你就没印象，但是万一某天这两个行星突然出问题了，那就需要去解决了</p>
<p>在程序里的示意图：</p>
<p><a href="https://imgtu.com/i/jmZjzD"><img src="https://s1.ax1x.com/2022/06/29/jmZjzD.png" alt="jmZjzD.png"></a></p>
<h3 id="git分支中常用指令："><a href="#git分支中常用指令：" class="headerlink" title="git分支中常用指令："></a>git分支中常用指令：</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch -r</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch [branch-name]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="attr">git</span> <span class="string">checkout -b [branch]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 临时切换到新建分支</span></span><br><span class="line"><span class="attr">git</span> <span class="string">checkout [branch]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line"><span class="attr">$</span> <span class="string">git merge [branch]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="attr">$</span> <span class="string">git branch -d [branch-name]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line"><span class="attr">$</span> <span class="string">git push origin --delete [branch-name]</span></span><br><span class="line"><span class="attr">$</span> <span class="string">git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure>

<h3 id="IDEA中操作"><a href="#IDEA中操作" class="headerlink" title="IDEA中操作"></a>IDEA中操作</h3><p><a href="https://imgtu.com/i/jmnNI1"><img src="https://s1.ax1x.com/2022/06/29/jmnNI1.png" alt="jmnNI1.png"></a></p>
<p>如果同一个文件在合并分支时都被修改了则会引起冲突：这个时候我们应该修改冲突后的文件然后重新提交，然后团队自己协商好提交谁的即可</p>
<p>master主分支相对稳定，一般用来发布新版本，一般情况下不会在上面工作，工作时一般在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
]]></content>
      <categories>
        <category>Git</category>
        <category>企业协同开发工具</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Git</tag>
        <tag>企业协同开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码讲解</title>
    <url>/2022/07/01/HashMap%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程简单明了的讲解了java集合中HashMap的底层原理，本文章来源于我好朋友的技术总结，有需要的可以去访问他的博客<br>本文原链接：<a href="https://www.studyhard.site/2022/07/01/HashMap%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/">https://www.studyhard.site/2022/07/01/HashMap%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</a></p>
<hr>
<h1 id="HashMap源码："><a href="#HashMap源码：" class="headerlink" title="HashMap源码："></a>HashMap源码：</h1><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>先说下结论，有的小伙伴可能没有心思看看完！</p>
<p><strong>数据结构：</strong></p>
<p>加载因子为0.75f</p>
<p>默认初始容量为16</p>
<p>扩容为原来的1倍  &lt;&lt;1  临界点也会随着增加1倍 &lt;&lt;1</p>
<p>依靠每次在数组中添加成功都会自增的size与临界点做比较，是否需要扩容</p>
<p>如果添加key相同的键值对会进行value的替换，并返回替换掉的value值</p>
<p>链表未大于等于8位时：</p>
<p>​	数组加链表，其实就是一个Node类型的数组，而而每个下表都是Node类，Node它的结构为链表的形式，记录下一个、本身键值对，为<strong>单向链表</strong></p>
<p>转换红黑树条件：</p>
<p>​	数组长度大于64，并且链表长度大于8才会进行转换</p>
<p>​	</p>
<p>与HashTable的区别：</p>
<p>JDK1.8 ：</p>
<p>HashMap在添加时进行数组实例化，HashTable实例化时就会进行数组实例化</p>
<p>HashTable不会转换为红黑树</p>
<p>线程安全性不同。HashMap线程不安全；Hashtable 中的方法是Synchronize的。<br>key、value是否允许null。HashMap的key和value都是可以是null，key只允许一个null；Hashtable的key和value都不可为null。<br>迭代器不同。HashMap的Iterator是fail-fast迭代器；Hashtable还使用了enumerator迭代器。<br>hash的计算方式不同。HashMap计算了hash值；Hashtable使用了key的hashCode方法。<br>默认初始大小和扩容方式不同。HashMap默认初始大小16，容量必须是2的整数次幂，扩容时将容量变为原来的2倍；Hashtable默认初始大小11，扩容时将容量变为原来的2倍加1。<br>是否有contains方法。HashMap没有contains方法；Hashtable包含contains方法，类似于containsValue。<br>父类不同。HashMap继承自AbstractMap；Hashtable继承自Dictionary。</p>
<h2 id="HashMap初始化："><a href="#HashMap初始化：" class="headerlink" title="HashMap初始化："></a>HashMap初始化：</h2><p><strong>HashMap有着多个重载的构造方法，接下来 一 一来看看分别有着什么作用！！</strong></p>
<h3 id="无参构造："><a href="#无参构造：" class="headerlink" title="无参构造："></a>无参构造：</h3><p>无参构造中可以看出我们没有做其他的初始化，只是赋予了一个默认加载因子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量，加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//真正使用在hashMap中的加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 所有字段均为默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="有参构造："><a href="#有参构造：" class="headerlink" title="有参构造："></a>有参构造：</h3><h4 id="设置默认容量构造器："><a href="#设置默认容量构造器：" class="headerlink" title="设置默认容量构造器："></a>设置默认容量构造器：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量，加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//最大容量   1,073,741,824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可设置初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//调用其他构造方法</span></span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//真正实例化的构造器   参数：1、默认容量   2、加载因子</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     	<span class="comment">//判断当前设置的默认容量是否为0 ，为0抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">     	<span class="comment">//判断是否超出最大容量，如果超出就赋予最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     	<span class="comment">//判断当前加载因子是否小于等于0 Float.isNaN这个方法目前还不是很清楚</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;  <span class="comment">//为加载因素赋值</span></span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);  <span class="comment">//根据当前容量得出下次需要扩容的临界点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Put："><a href="#Put：" class="headerlink" title="Put："></a>Put：</h2><p>在初始化我们可以看出都没有进行数据结构的创建，其实HashMap使用的是懒加载默认，但我们真正要存储时再进行创建</p>
<h3 id="添加方法："><a href="#添加方法：" class="headerlink" title="添加方法："></a>添加方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更加key获取hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="第一次添加："><a href="#第一次添加：" class="headerlink" title="第一次添加："></a>第一次添加：</h4><h5 id="主方法："><a href="#主方法：" class="headerlink" title="主方法："></a>主方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">   		<span class="comment">// 1、 tab为当前map数组，p为当前节点，n为数组长度，i为当键值对在数值的下表位置</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;      </span><br><span class="line">    	<span class="comment">//2、 tab为空 n为0  此处判断的同时也为我们的tab指向了table  n值为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//3、调用初始化方法  返回新map数组赋值为局部tab，并获取容量大小赋值给局部n</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    	<span class="comment">// 4、获取当前数组长度减一 并使用 ‘与’ 逻辑运算符获取 数组下表位置赋值给i 并获取当前下表下的内容赋值给p，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//5、没有内容就进行创建一个node（非树型）节点，放入当前下标中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//6、modCount进行计数  这个便利店作用显目有解释</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//7、size++ 判断当前加入数组中的数量是否大于临界值</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="HashMap初始化及调整大小方法："><a href="#HashMap初始化及调整大小方法：" class="headerlink" title="HashMap初始化及调整大小方法："></a><strong>HashMap初始化及调整大小方法：</strong></h5><p>​	这个方法主要是为了当我们数组为null没有进行初始化时进行初始化，并设置临界值，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">//3.1、hashMap数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;  <span class="comment">//3.2、旧数组大小，如果数组为空则为0 ，不为空则为数组大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold; <span class="comment">//3.3、临界点 旧</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;  <span class="comment">//3.4、newCap 数组大小 新    newThr：临界点 新</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//3.5、判断旧数组大小是否大于0 第一次不会进入</span></span><br><span class="line">        <span class="comment">//判断旧容量是否为最大值了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//如果数值为最大值了就将最大值为临界点</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//并返回就数组回去，不进行扩容</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行扩容参数初始化，新长度为原来的1倍，新临界点也为原来的1倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//3.6、判断临界值 旧 是否大于0 第一次不会进入</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//3.7、进行基础数据初始化</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//将默认容量大小 16 赋予新数组大小</span></span><br><span class="line">        <span class="comment">//新数组容量与加载因子进行计算得出 临界点 并赋值为临界点局部变量 新</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.8判断临界值 新 是否为0  一般情况下不会进入</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.9、将局部临界点赋值给全局临界点</span></span><br><span class="line">    threshold = newThr; </span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//3.10、初始化新map数组 长度为局部newCap大小 </span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">     <span class="comment">//3.11、将新map数组</span></span><br><span class="line">    table = newTab; </span><br><span class="line">    <span class="comment">//3.12、判断旧map数组是否为空 第一次不会进入</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回map数组 新</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建节点方法："><a href="#创建节点方法：" class="headerlink" title="创建节点方法："></a>创建节点方法：</h5><p>​	创建非树型节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="modCount作用："><a href="#modCount作用：" class="headerlink" title="modCount作用："></a>modCount作用：</h5><p>Fail-Fast 机制<br>我们知道 java.util.HashMap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对HashMap 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map：注意到 modCount 声明为 volatile，保证线程之间修改的可见性。</p>
<h4 id="二次添加："><a href="#二次添加：" class="headerlink" title="二次添加："></a>二次添加：</h4><h5 id="主方法：-1"><a href="#主方法：-1" class="headerlink" title="主方法："></a>主方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">   		<span class="comment">// 1、 tab为当前map数组，p为当前节点，n为数组长度，i为当键值对在数值的下表位置</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;      </span><br><span class="line">    	<span class="comment">//2、此处判断的同时也为我们的tab指向了table  n值为tab的长度 由于不为空 不进入该方法</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    	<span class="comment">// 3、获取当前数组长度减一 并使用 ‘与’ 逻辑运算符获取 数组下表位置赋值给i 并获取当前下表下的内容赋值给p，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//4、没有内容就进行创建一个node（非树型）节点，放入当前下标中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//5、modCount进行计数  这个便利店作用显目有解释</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//6、size++ 判断当前加入数组中的数量是否大于临界值</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="添加至同一个下标中："><a href="#添加至同一个下标中：" class="headerlink" title="添加至同一个下标中："></a>添加至同一个下标中：</h4><p>此处是第二次添加，第一次添加于上面无差别</p>
<p><strong>注意，要两个key的Hash值相同</strong></p>
<h5 id="主方法：-2"><a href="#主方法：-2" class="headerlink" title="主方法："></a>主方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">   		<span class="comment">// 1、 tab为当前map数组，p为当前节点（会随着循环链表成为循环到的那个结构），n为数组长度，i为当键值对在数值的下表位置</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;      </span><br><span class="line">    	<span class="comment">//2、此处判断的同时也为我们的tab指向了table  n值为tab的长度 由于不为空 不进入该方法</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    	<span class="comment">// 3、获取当前数组长度减一 并使用 ‘与’ 逻辑运算符获取 数组下表位置赋值给i 并获取当前下表下的内容赋值给p，判断是否为空</span></span><br><span class="line">    	<span class="comment">//此次hash碰撞，下表相同，进行else</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4、e 局部e为临时存储变量，会一直改变 ，  k为当前数值中需要对比节点的key</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k; </span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; <span class="comment">//5、判断当前比较的节点的hash值与本次添加的hash值是否相同</span></span><br><span class="line">                <span class="comment">//此处为k进行赋值并判断他们的值是否相同 </span></span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//如果key相同，将当前节点赋值给我们的e，下面会将我们要添加的与当前的value进行替换</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//6、判断当前是否为树节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//7、无限循环</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//8、将局部e赋值为当前数组上的节点的下一个节点，并判断是否为空</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//9、创建一个节点赋值在当前循环到的节点的下一个节点</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//10、判断当前循环长度是否大于等于8为，注意从0开始的，如果为true则转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//11、判断循环中的节点是否与我们当前要添加的key相同，相同就终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//不一样就将当前遍历到的节点赋值给p进行下一轮遍历</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断e是否为null，不为null</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//将原来的旧值赋值给我们的oldValue，等会将这个值返回给我们</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//将我们新添加的value赋给当前节点的value进行替换</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">//返回旧值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//5、modCount进行计数  这个便利店作用显目有解释</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//6、size++ 判断当前加入数组中的数量是否大于临界值</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="链表超出8位："><a href="#链表超出8位：" class="headerlink" title="链表超出8位："></a>链表超出8位：</h4><p>多余的就不多看了，都是上面一样了，我们直接看转红黑树的过程</p>
<p>如果数组小于64则不会进行红黑树的转换，还是进行扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//判断数组长度是否小于64，小于则是进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      <span class="comment">//小于64于则进行扩容，还不会进行红黑树转换</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>java集合框架</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>java</tag>
        <tag>java集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate快速入门</title>
    <url>/2022/06/30/Hibernate%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程将快速带你了解和掌握hibernate，有学过类似框架的可以更快速上手哦，本文章来源于我好朋友的技术总结，有需要的可以去访问他的博客<br>本文原链接：<a href="https://www.studyhard.site/2022/07/01/HashMap%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/">https://www.studyhard.site/2022/07/01/HashMap%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</a></p>
<hr>
<h1 id="Hibernate快速使用："><a href="#Hibernate快速使用：" class="headerlink" title="Hibernate快速使用："></a>Hibernate快速使用：</h1><p>主流ORM框架 Object Relation Mapping 对象关系映射，将面向对象映射成面向关系。</p>
<h2 id="如何使用："><a href="#如何使用：" class="headerlink" title="如何使用："></a>如何使用：</h2><p>1、导入相关依赖</p>
<p>2、创建Hibernate配置文件</p>
<p>3、创建实体类</p>
<p>4、创建实体类-关系映射文件</p>
<p>5、调用Hubernate API 完成操作</p>
<h2 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h2><h3 id="1、导入基础依赖："><a href="#1、导入基础依赖：" class="headerlink" title="1、导入基础依赖："></a>1、导入基础依赖：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、创建Hibernate配置文件"><a href="#2、创建Hibernate配置文件" class="headerlink" title="2、创建Hibernate配置文件"></a>2、创建Hibernate配置文件</h3><p>文件名称不能随意修改：hibernate.cfg.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-configuration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Configuration DTD//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    数据源配置    --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用 Hibernate 自带的连接池配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>Admin123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &amp;lt;!&amp;ndash;  使用连接池 （内置的）  &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;connection.pool_size&quot;&gt;1&lt;/property&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--hibernate 方言  根据不同数据库有不同的方言生成对应特性的SQL语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--打印sql语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--格式化sql--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   根据实体类生自动生成对应数据库     --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  C3P0 连接池 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.c3p0.max_size&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.c3p0.min_size&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.c3p0.timeout&quot;</span>&gt;</span>120<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大的PreparedStatement的数量 也就是用于执行sql语句的对象，底层就是jdbc --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.c3p0.max_statements&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.c3p0.idle_test_period&quot;</span>&gt;</span>120<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.c3p0.acquire_increment&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每次都验证连接是否可用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.c3p0.validate&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    对象关系映射文件    --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="其它标签属性："><a href="#其它标签属性：" class="headerlink" title="其它标签属性："></a>其它标签属性：</h4><p><strong>property：</strong></p>
<p>1、name为hibernate.hbm2ddl.auto：</p>
<p>​		此属性用于根据实体类生自动生成对应数据库有4个类型，<strong>在标签中写</strong></p>
<p>​		upate：动态创建表，如果表存在，则直接使用，如果表不存在，则创建</p>
<p>​		create：无论表是否存在，都会重新创建</p>
<p>​		create-drop：初始化创建表，程序结束时删除表</p>
<p>​		validate：校验实体类关系映射文件和数据库表是否对应，不能对应直接报错</p>
<h3 id="3、创建实体类"><a href="#3、创建实体类" class="headerlink" title="3、创建实体类"></a>3、创建实体类</h3><p><strong>单表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@ToString</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class People &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private Double money;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>一对多：</strong></p>
<p>用户类  一个用户可以对应多个订单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Orders&gt; orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>订单类 一个订单对应一个用户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多对多：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Account &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Set&lt;Course&gt; course;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Course &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Set&lt;Account&gt; accounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、实体关系映射文件"><a href="#4、实体关系映射文件" class="headerlink" title="4、实体关系映射文件"></a>4、实体关系映射文件</h3><h4 id="单表："><a href="#单表：" class="headerlink" title="单表："></a><strong>单表：</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.study.hibernate.pojo.People&quot;</span> <span class="attr">table</span>=<span class="string">&quot;people&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   设置主键 name 类型属性  column 对应表字段    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  设置主键自增      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    type数据类型    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Double&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="一对多："><a href="#一对多：" class="headerlink" title="一对多："></a><strong>一对多：</strong></h4><p><strong>用户可以有多个订单</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.study.hibernate.pojo.Customer&quot;</span> <span class="attr">table</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   设置主键 name 类型属性  column 对应表字段    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  设置主键自增      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    types数据类型    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--  设置set name当前类中的set属性   table 这个属性的值重哪个表中获取      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--   配置关联的字段 也就是外键 cid 要与当前表的id相同        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  一对多的意思   根据关联的字段查找到对象放入set中       --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.study.hibernate.pojo.Orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>name 实体类属性名</p>
<p>table 表名</p>
<p>set 标签来配置实例类中的集合属性orsers （实体类的类型就是set的 如果是List集合 可以使用list标签）</p>
<p>​	one-to-many与集合泛型的实力类对应  表示这个的一对多中的多</p>
<p>​	key 外键</p>
<p><strong>一个订单只能有一个用户</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name:类的全路径:--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- table:表的名称:(可以省略的.使用类的名称作为表名.)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.study.hibernate.pojo.Orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;oders&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主键--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键生成策略--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--type:三种写法--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Java类型 :java.lang.String--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Hibernate类型:string--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SQL类型 :不能直接使用type属性,需要子标签&lt;column&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;column name=&quot;name&quot; sql-type=&quot;varchar(20)&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.hibernate.pojo.Customer&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>many-to-one标签 配置实体类对应的对象属性</p>
<p>​	name 属性名称</p>
<p>​	class 属性对应的类</p>
<p>​	column 外键</p>
<p><strong>使用api：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void CustomerTest()&#123;</span><br><span class="line">    Configuration configuration = new Configuration().configure();</span><br><span class="line">    SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line">    Customer customer = new Customer(null,&quot;张三&quot;,null);</span><br><span class="line">    //我们需要将订单需要的用户放入 他会获取用户的id并插入cid</span><br><span class="line">    Orders orders = new Orders(null,&quot;订单一&quot;,customer);</span><br><span class="line">    session.save(customer);</span><br><span class="line">    session.save(orders);</span><br><span class="line">    session.beginTransaction().commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="多对多："><a href="#多对多：" class="headerlink" title="多对多："></a>多对多：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.study.hibernate.pojo.Course&quot;</span> <span class="attr">table</span>=<span class="string">&quot;course&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   设置主键 name 类型属性  column 对应表字段    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  设置主键自增      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    types数据类型    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--  设置set name当前类中的set属性   table 这个属性的值重哪个表中获取      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;accounts&quot;</span> <span class="attr">table</span>=<span class="string">&quot;account_course&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  根据cid去account_course表中查询有哪些account  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  多对多的意思   更加account的aid去Account表中查询并放入set中      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.study.hibernate.pojo.Account&quot;</span> <span class="attr">column</span>=<span class="string">&quot;aid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.study.hibernate.pojo.Account&quot;</span> <span class="attr">table</span>=<span class="string">&quot;account&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   设置主键 name 类型属性  column 对应表字段    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  设置主键自增      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    types数据类型    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--  设置set name当前类中的set属性   table 这个属性的值重哪个表中获取      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;course&quot;</span> <span class="attr">table</span>=<span class="string">&quot;account_course&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--   根据aid去account_course表中查询有哪些Customer关联了        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;aid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  一对多的意思   根据关联的字段查找到对象放入set中       --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.study.hibernate.pojo.Course&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>使用api</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void account_courseTest()&#123;</span><br><span class="line">        Configuration configuration = new Configuration().configure();</span><br><span class="line">        SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        Account account = new Account();</span><br><span class="line">        account.setName(&quot;李四&quot;);</span><br><span class="line">        Course course = new Course();</span><br><span class="line">        course.setName(&quot;C#&quot;);</span><br><span class="line"></span><br><span class="line">//这两个都是可以 都会去关联表中插入数据，因为都是有配置set多对多关系设置的</span><br><span class="line">//        Set&lt;Course&gt; courses = new HashSet&lt;&gt;();</span><br><span class="line">//        courses.add(course);</span><br><span class="line">//        account.setCourse(courses);</span><br><span class="line"></span><br><span class="line">        Set&lt;Account&gt; accounts = new HashSet&lt;&gt;();</span><br><span class="line">        accounts.add(account);</span><br><span class="line">        course.setAccounts(accounts);</span><br><span class="line"></span><br><span class="line">        session.save(account);</span><br><span class="line">        session.save(course);</span><br><span class="line"></span><br><span class="line">        session.beginTransaction().commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="在hibernate映射文件中配置："><a href="#在hibernate映射文件中配置：" class="headerlink" title="在hibernate映射文件中配置："></a><strong>在hibernate映射文件中配置：</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;People.hbm.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;Customer.hbm.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;Orders.hbm.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="5、调用Hubernate-API"><a href="#5、调用Hubernate-API" class="headerlink" title="**5、调用Hubernate API **"></a>**5、调用Hubernate API **</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PeopleTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//Hibernate 加载核心配置文件（有数据库连接信息） 不设置configure()的访问文件也会默认去找hibernate.cfg.xml</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure(<span class="string">&quot;hibernate.cfg.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取会话工厂 SessionFactory</span></span><br><span class="line">        <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">        <span class="comment">//在SessionFactory中获取Session会话</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="type">Serializable</span> <span class="variable">id</span> <span class="operator">=</span> session.save(<span class="keyword">new</span> <span class="title class_">People</span>(<span class="literal">null</span>, <span class="string">&quot;某某某11&quot;</span>, <span class="number">5100.50</span>));</span><br><span class="line">        session.beginTransaction().commit();</span><br><span class="line">        System.out.println(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="映射文件标签属性："><a href="#映射文件标签属性：" class="headerlink" title="映射文件标签属性："></a>映射文件标签属性：</h4><p><strong>hibernate-mapping标签：</strong></p>
<p>​	package：给class节点对应的实体类统一设置包名，此处设置包名，class的nname属性就可以省略包名。</p>
<p>​	schema：数据库schema的名称</p>
<p>​	catalog：数据库catalog的名称</p>
<p>​	default-cascade：默认的级联关系，默认为none</p>
<p>​	default-access：Hibernate用来访问属性的策略</p>
<p>​	default-lazy：指定了未明确注明lazy属性的Java属性和集合类，Hibernate会采用什么样的加载风格，默认为true</p>
<p>​	auto-impory：指定我们是否可以在查询语句中使用非全限定类名，默认为true，如果下面中有两个同名的持久化类，最好在这两个类的对应映射文件中设置为</p>
<p>​							  false</p>
<p><strong>class标签：</strong></p>
<p>​	name：实体类名</p>
<p>​	table：数据库表名</p>
<p>​	schema：数据库schema的名称，会覆盖hibernate-mapping中的schema</p>
<p>​	catalog：数据库catalog的名称，会覆盖hibernate-mapping中的catalog</p>
<p>​	proxy：指定一个接口，在延迟加载时作为代理使用</p>
<p>​	dynamic-update：动态更新，不会属性没有值sql也要传那么多参数</p>
<p>​	dynamic-insert：动态添加，不会属性没有值sql也要传那么多参数</p>
<p>​	where：查询时给Sql添加where条件，在使用HQL的情况下</p>
<p><strong>id标签：</strong></p>
<p>​	name：实体类属性名</p>
<p>​	type：实体类属性数据类型</p>
<p>​	此处可以设置两种类型的数据：java数据类型或Hibernate映射类型，实体类的属性数据类型必须于数据表对应的字段数据类型一致</p>
<p>​	column：数据库表的主键</p>
<p>​	generator：主键生成策略</p>
<p>​		hilo算法、</p>
<p>​		increment：Hibernate自增、</p>
<p>​		identity：数据库自增、</p>
<p>​		native：本地策略，根据底层数据库自动选择主键的生成策略</p>
<p>​		uuid.hex：算法</p>
<p>​		select算法</p>
<p><strong>property标签：</strong></p>
<p>​	name：实体类的属性名</p>
<p>​	column：数据库表字段名</p>
<p>​	type：数据类型</p>
<p>​	update：该字段是可以修改，默认为true</p>
<p>​	insert：该字段是可以添加，默认为true</p>
<p>​	lazy：延迟加载策略</p>
<p><strong>实体关系映射文件属性：</strong></p>
<p>​	inverse：该类型是否放弃维护映射关系，当两个类有映射关系添加时，并且都持有对方时，会出现重复维护，添加多条，这时候就让一方放弃维护即可，一对					 多，或多对多时会出现</p>
<p><strong>级联删除：</strong></p>
<p>​	cascade&#x3D;”delete“：删除为该字段有级联的数据（也就是外键），如果不使用这个属性，那么就只能在代码中自己去编程删除了</p>
<h2 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h2><p>延迟加载也就是当我们要去查询时，如查询一个用户，但用户里面还要订单，如果我们只是查看用户而不查看用户的订单就不去查询订单只查询用户，当访问订单时才加载订单 </p>
<h3 id="XML配置："><a href="#XML配置：" class="headerlink" title="XML配置："></a>XML配置：</h3><h4 id="一对多：-1"><a href="#一对多：-1" class="headerlink" title="一对多："></a>一对多：</h4><p><strong>多个结果集的lazy（如set，list）</strong></p>
<p>我们需要去多结果集标签中设置 lazy 属性  它有false 、 true 、 extra 三个属性值</p>
<p>false：关闭延迟加载</p>
<p>true：开启延迟加载</p>
<p>extra：增强延迟加载</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.study.hibernate.pojo.Customer&quot;</span> <span class="attr">table</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   设置主键 name 类型属性  column 对应表字段    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  设置主键自增      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    types数据类型    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--  设置set name当前类中的set属性   table 这个属性的值重哪个表中获取   lazy 是否开启延迟加载   --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">lazy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--   配置关联的字段 也就是外键 cid 要与当前表的id相同        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  一对多的意思   根据关联的字段查找到对象放入set中       --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.study.hibernate.pojo.Orders&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p><strong>单个结果集设置lazy</strong></p>
<p>lazy开启懒加载，在many-to-one标签中设置，false、proxy、no-proxy</p>
<p>默认为开启延迟加载</p>
<p>false：关闭延迟加载</p>
<p>proxy：无论调用方法是否需要访问customer的成员变量，都会发送SQL语句查询Customer</p>
<p>no-proxy：当调用方法需要访问customer的成员变量时，发送SQL语句查询Customer，否则不查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name:类的全路径:--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- table:表的名称:(可以省略的.使用类的名称作为表名.)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.study.hibernate.pojo.Orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;oders&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主键--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键生成策略--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--type:三种写法--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Java类型 :java.lang.String--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Hibernate类型:string--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SQL类型 :不能直接使用type属性,需要子标签&lt;column&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;column name=&quot;name&quot; sql-type=&quot;varchar(20)&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.hibernate.pojo.Customer&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">lazy</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="API使用："><a href="#API使用：" class="headerlink" title="API使用："></a>API使用：</h3><h4 id="普通延迟加载："><a href="#普通延迟加载：" class="headerlink" title="普通延迟加载："></a>普通延迟加载：</h4><p>lazy 为 true</p>
<p><strong>当我们之查看用户时：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lazyCustomer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">    <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">    <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> session.get(Customer.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p>可以发现只执行了 一条SQL</p>
<p><a href="https://imgtu.com/i/jdLNzq"><img src="https://s1.ax1x.com/2022/07/07/jdLNzq.jpg" alt="jdLNzq.jpg"></a></p>
<p><strong>再同时查看订单：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lazyCustomer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">    <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">    <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> session.get(Customer.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">    System.out.println(customer.getOrders().size());</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>结果：</p>
<p>可以看到查询了俩条SQL语句</p>
<p><a href="https://imgtu.com/i/jdLO6P"><img src="https://s1.ax1x.com/2022/07/07/jdLO6P.jpg" alt="jdLO6P.jpg"></a></p>
<h4 id="增强延迟加载："><a href="#增强延迟加载：" class="headerlink" title="增强延迟加载："></a>增强延迟加载：</h4><p>lazy 为extra</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lazyCustomer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">    <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">    <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> session.get(Customer.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">    System.out.println(customer.getOrders().size());</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p>会更加你的查询来判断要执行的sql语句，如果是普通延迟就会直接将数据也查询出来，而增强延迟就不会，他会直接换为count（）去查询，节省效率</p>
<p><a href="https://imgtu.com/i/jwbdR1"><img src="https://s1.ax1x.com/2022/07/07/jwbdR1.jpg" alt="jwbdR1.jpg"></a></p>
<h2 id="HQL："><a href="#HQL：" class="headerlink" title="HQL："></a>HQL：</h2><h3 id="Hibernate-HQL"><a href="#Hibernate-HQL" class="headerlink" title="Hibernate HQL"></a>Hibernate HQL</h3><p>HQL: Hibernate Query Language，是 Hibernate框架提供的一种查询机制，它和SQL类似，不同的是HQL是面向对象的查询语句，让开发者能够以面向对象的思想来编写查询语句，对Java编程是一种好友好的方式。<br>HQL不能直接参与数据库的交互，中间层语言。</p>
<p>Java —》 HQL —&gt;Hibernate —》SQL —&gt;DB</p>
<p>HQL只能完成查询、修改、删除，新增是无法操作的。</p>
<h3 id="HQL使用："><a href="#HQL使用：" class="headerlink" title="HQL使用："></a>HQL使用：</h3><p>Hql中from前面默认为select * from后也不是表名，而是类型，如果只是写别名而不写全类名会有警告，当不妨该使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Hql</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">    <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">    <span class="comment">//Hql 语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;from People&quot;</span>;</span><br><span class="line">    <span class="comment">//创建Hql 查询放入hql</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">    <span class="comment">//进行查询</span></span><br><span class="line">    List&lt;People&gt; list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (People people : list) &#123;</span><br><span class="line">        System.out.println(people);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">七月 08, 2022 9:40:30 上午 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator initiateService</span><br><span class="line">INFO: HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        people0_.id as id1_6_,</span><br><span class="line">        people0_.name as name2_6_,</span><br><span class="line">        people0_.money as money3_6_ </span><br><span class="line">    from</span><br><span class="line">        people people0_</span><br><span class="line">People(id=1, name=某某某, money=5000.5)</span><br><span class="line">People(id=2, name=某某某11, money=5100.5)</span><br><span class="line">People(id=3, name=某某某22, money=5100.5)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><p>HQL分页查询可以通过query的方法完成：</p>
<p>1、setFirstResult() 设置起始下标</p>
<p>2、setMaxResults() 设置截取长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Hql</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">    <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">    <span class="comment">//Hql 语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;from People&quot;</span>;</span><br><span class="line">    <span class="comment">//创建Hql 查询放入hql</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">    <span class="comment">//设置起始下标</span></span><br><span class="line">    query.setFetchSize(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置截取长度</span></span><br><span class="line">    query.setMaxResults(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//进行查询</span></span><br><span class="line">    List&lt;People&gt; list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (People people : list) &#123;</span><br><span class="line">        System.out.println(people);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        people0_.id as id1_6_,</span><br><span class="line">        people0_.<span class="keyword">name</span> as name2_6_,</span><br><span class="line">        people0_.money as money3_6_ </span><br><span class="line">    from</span><br><span class="line">        people people0_ limit ?</span><br><span class="line">People(id=<span class="number">1</span>, <span class="keyword">name</span>=某某某, money=<span class="number">5000.5</span>)</span><br><span class="line">People(id=<span class="number">2</span>, <span class="keyword">name</span>=某某某<span class="number">11</span>, money=<span class="number">5100.5</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="where条件查询-级联查询："><a href="#where条件查询-级联查询：" class="headerlink" title="where条件查询 级联查询："></a><strong>where条件查询 级联查询：</strong></h3><p>HQL直接追加where关键字作为查询条件，与SQL没有区别，比较的值可以使用java对象</p>
<p>在HQL中 :xxx 为占位符，使用Query的setParameter(“Customer”,customer); 替换占位符</p>
<p>级联查询也就是先拿到级联的外键对象，再通过这个对象去获取级联的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HqlWhere</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">    <span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> configuration.buildSessionFactory();</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">    <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> session.get(Customer.class, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//Hql 语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;from Orders where customer = :Customer&quot;</span>;</span><br><span class="line">    <span class="comment">//创建Hql 查询放入hql</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">    <span class="comment">//替换占位符</span></span><br><span class="line">    query.setParameter(<span class="string">&quot;Customer&quot;</span>,customer);</span><br><span class="line">    List&lt;Orders&gt; list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (Orders orders : list) &#123;</span><br><span class="line">        System.out.println(orders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">七月 <span class="number">08</span>, <span class="number">2022</span> <span class="number">9</span>:<span class="number">58</span>:<span class="number">00</span> 上午 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator initiateService</span><br><span class="line">INFO: HHH000490: <span class="keyword">Using</span> JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        customer0_.id as id1_4_0_,</span><br><span class="line">        customer0_.<span class="keyword">name</span> as name2_4_0_ </span><br><span class="line">    from</span><br><span class="line">        customer customer0_ </span><br><span class="line">    where</span><br><span class="line">        customer0_.id=?</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        orders0_.id as id1_5_,</span><br><span class="line">        orders0_.<span class="keyword">name</span> as name2_5_,</span><br><span class="line">        orders0_.cid as cid3_5_ </span><br><span class="line">    from</span><br><span class="line">        oders orders0_ </span><br><span class="line">    where</span><br><span class="line">        orders0_.cid=?</span><br><span class="line">Orders&#123;id=<span class="number">1</span>, <span class="keyword">name</span>=<span class="comment">&#x27;订单一&#x27;&#125;</span></span><br><span class="line">Orders&#123;id=<span class="number">2</span>, <span class="keyword">name</span>=<span class="comment">&#x27;订单二&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="uniquerResult方法："><a href="#uniquerResult方法：" class="headerlink" title="uniquerResult方法："></a>uniquerResult方法：</h3><p>这个方法获取结果如果是没有获取到返回为null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void HqlUniquerResult()&#123;</span><br><span class="line">    Configuration configuration = new Configuration().configure();</span><br><span class="line">    SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line">    Customer customer = session.get(Customer.class, 1);</span><br><span class="line">    //Hql 语句</span><br><span class="line">    String hql = &quot;from Orders where id = 10&quot;;</span><br><span class="line">    //创建Hql 查询放入hql</span><br><span class="line">    Query query = session.createQuery(hql);</span><br><span class="line">    Orders orders = (Orders)query.uniqueResult();</span><br><span class="line">    System.out.println(orders);</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">七月 08, 2022 10:04:01 上午 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator initiateService</span><br><span class="line">INFO: HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        customer0_.id as id1_4_0_,</span><br><span class="line">        customer0_.name as name2_4_0_ </span><br><span class="line">    from</span><br><span class="line">        customer customer0_ </span><br><span class="line">    where</span><br><span class="line">        customer0_.id=?</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        orders0_.id as id1_5_,</span><br><span class="line">        orders0_.name as name2_5_,</span><br><span class="line">        orders0_.cid as cid3_5_ </span><br><span class="line">    from</span><br><span class="line">        oders orders0_ </span><br><span class="line">    where</span><br><span class="line">        orders0_.id=10</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code -1</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a>模糊查询：</h3><p>模糊查询也就是使用like ‘%三 %’  注意是在字符串里面使用 ’  ‘ 号 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>hibernate</category>
        <category>持久层框架</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>java</tag>
        <tag>持久层框架</tag>
        <tag>hibernate</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MybatisPlus快速入门</title>
    <url>/2022/06/01/MybatisPlus%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程是根据B站Up主狂神说记得笔记，有需要查看视频的小伙伴可以去看看狂神的视频，真的非常好！</p>
<p>狂神说MybatisPlus视频地址：<a href="https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p>
<hr>
<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="MyBatisPlus概述"><a href="#MyBatisPlus概述" class="headerlink" title="MyBatisPlus概述"></a>MyBatisPlus概述</h2><p> 需要的基础：MyBatis、Spring、SpringMVC </p>
<p>为什么要学习它呢？</p>
<ul>
<li>MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！</li>
</ul>
<p>市面上主流的一些框架：</p>
<ul>
<li>JPA：国外使用的较多，集成springboot时使用较多</li>
<li>tk-mapper：开源项目使用较多</li>
<li>MyBatisPlus：国内较为主流的框架</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a> MyBatis Plus，简化 MyBatis ！</p>
<p><a href="https://imgtu.com/i/jYWy0U"><img src="https://s1.ax1x.com/2022/07/05/jYWy0U.png" alt="jYWy0U.png"></a></p>
<p><a href="https://imgtu.com/i/jYWB60"><img src="https://s1.ax1x.com/2022/07/05/jYWB60.png" alt="jYWB60.png"></a></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求，以后简单的CRUD操作，都不用自己编写 了！</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>官方地址：<a href="https://baomidou.com/pages/226c21/#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">https://baomidou.com/pages/226c21/#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B</a></p>
<p>使用第三方组件的四步曲：</p>
<ol>
<li>导入对应的依赖</li>
<li>研究依赖如何配置</li>
<li>代码如何编写</li>
<li>提高扩展技术能力！</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>创建名为mybaits_plus数据库</p>
</li>
<li><p>根据官网提供的数据创建user表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br><span class="line"><span class="comment">-- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个springboot项目</p>
</li>
<li><p>导入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis_plus,导了就不需要导入mybatis了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--这个版本原生较多，最新版查看官方文档即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：我们使用 mybatis-plus 可以节省我们大量的代码</p>
<p>注意：尽量不要同时导入 mybatis 和 mybatis-plus！容易产生版本差异</p>
</li>
<li><p>连接数据库，这里我们使用yaml文件配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动：com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动：com.mysql.cj.jdbc.Driver、需要增加时区的配置：serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">Apathy99977</span></span><br><span class="line">    <span class="comment"># 假如时区报错了，就增加一个时区的配置就ok：serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/连接的数据库?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用mybatis-plus</p>
<ol>
<li><p>编写pojo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atapathy.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atapathy.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Apathy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-06-08 9:53:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在对应的Mapper上面继承基本的类 BaseMapper&lt;要编写sql语句的类&gt;</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 所有的CRUD操作都已经编写完成了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试使用</p>
<ul>
<li><p>注意我们需要在主启动类上去扫描我们的mapper包下的所有接口</p>
<p><a href="https://imgtu.com/i/jYWsmT"><img src="https://s1.ax1x.com/2022/07/05/jYWsmT.png" alt="jYWsmT.png"></a></p>
</li>
<li><p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlusApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">// 继承了BaseMapper，所有的方法都来自己父类</span></span><br><span class="line">    <span class="comment">// 我们也可以编写自己的扩展方法！</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 参数是一个 Wrapper ，条件构造器，这里我们先不用 null</span></span><br><span class="line">        <span class="comment">// 查询全部用户</span></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
<p><a href="https://imgtu.com/i/jYW67F"><img src="https://s1.ax1x.com/2022/07/05/jYW67F.png" alt="jYW67F.png"></a></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="思考问题？"><a href="#思考问题？" class="headerlink" title="思考问题？"></a>思考问题？</h3><ol>
<li>SQL谁帮我们写的 ? 		是MyBatis-Plus 写好了的</li>
<li>方法哪里来的？    MyBatis-Plus 编写的</li>
</ol>
<h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p><a href="https://imgtu.com/i/jYWDXV"><img src="https://s1.ax1x.com/2022/07/05/jYWDXV.png" alt="jYWDXV.png"></a></p>
<p>在yaml文件配置的时候可以发现可以配置很多日志类，<strong>StdOutImpl</strong>为默认控制台输出，使用其他类导入相关依赖即可</p>
<h2 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h2><h3 id="Insert插入"><a href="#Insert插入" class="headerlink" title="Insert插入"></a>Insert插入</h3><p><a href="https://imgtu.com/i/jYWh11"><img src="https://s1.ax1x.com/2022/07/05/jYWh11.png" alt="jYWh11.png"></a></p>
<p>数据库插入的id的默认值为：全局的唯一id</p>
<h4 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h4><p>默认 <strong>ID_WORKER</strong> 全局唯一id</p>
<p>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p>
<h5 id="雪花算法："><a href="#雪花算法：" class="headerlink" title="雪花算法："></a>雪花算法：</h5><ul>
<li>snowflake是<strong>Twitter</strong>开源的分布式ID生成算法，结果是一个<strong>long型</strong>的ID。</li>
<li>其核心思想是：使用41bit作为 毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味 着每个节点在每毫秒可以产生 4096 个 ID）</li>
<li>最后还有一个符号位，永远是0，可以保证几乎全球唯 一！</li>
</ul>
<h5 id="注解自增："><a href="#注解自增：" class="headerlink" title="注解自增："></a>注解自增：</h5><p>配置主键自增：</p>
<ol>
<li><p>实体类字段上加@TableId(type &#x3D; IdType.AUTO)zhujie</p>
</li>
<li><p>数据库设置时字段一定也要是自增</p>
<p><a href="https://imgtu.com/i/jYWgk4"><img src="https://s1.ax1x.com/2022/07/05/jYWgk4.png" alt="jYWgk4.png"></a></p>
</li>
</ol>
<h5 id="不同的主键策略："><a href="#不同的主键策略：" class="headerlink" title="不同的主键策略："></a>不同的主键策略：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdType</span> &#123;</span><br><span class="line">    AUTO(<span class="number">0</span>), <span class="comment">// 数据库id自增</span></span><br><span class="line">    NONE(<span class="number">1</span>), <span class="comment">// 未设置主键</span></span><br><span class="line">    INPUT(<span class="number">2</span>), <span class="comment">// 手动输入,一旦手动输入id之后，就需要自己配置id 了</span></span><br><span class="line">    ID_WORKER(<span class="number">3</span>), <span class="comment">// 默认的全局唯一id</span></span><br><span class="line">    UUID(<span class="number">4</span>), <span class="comment">// 全局唯一id uuid</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>); <span class="comment">//ID_WORKER 字符串表示法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">// 通过条件自动拼接动态sql</span></span><br><span class="line">    user.setId(<span class="number">1534360852678524929L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="comment">// 注意：updateById 的参数是一个对象！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(result);<span class="comment">//受影响的行数</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://imgtu.com/i/jYW5X6"><img src="https://s1.ax1x.com/2022/07/05/jYW5X6.png" alt="jYW5X6.png"></a></p>
<p>所有的sql都是自动帮你动态配置的！</p>
<h4 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h4><p>创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！ </p>
<p>阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需 要自动化！</p>
<h5 id="方式一：数据库级别"><a href="#方式一：数据库级别" class="headerlink" title="方式一：数据库级别"></a>方式一：数据库级别</h5><p>前言：实际工作中一般不允许你修改数据库</p>
<p>使用方式：</p>
<ol>
<li><p>在表中新增字段 create_time, update_time</p>
<p><a href="https://imgtu.com/i/jYWRh9"><img src="https://s1.ax1x.com/2022/07/05/jYWRh9.png" alt="jYWRh9.png"></a></p>
</li>
<li><p>再次测试插入方法，注意需要先把实体类同步！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次更新查看结果即可</p>
<p><a href="https://imgtu.com/i/jYWfpR"><img src="https://s1.ax1x.com/2022/07/05/jYWfpR.png" alt="jYWfpR.png"></a></p>
</li>
</ol>
<h5 id="方式二：代码级别"><a href="#方式二：代码级别" class="headerlink" title="方式二：代码级别"></a>方式二：代码级别</h5><ol>
<li><p>删除数据库的默认值、更新操作！</p>
<p><a href="https://imgtu.com/i/jYW46x"><img src="https://s1.ax1x.com/2022/07/05/jYW46x.png" alt="jYW46x.png"></a></p>
</li>
<li><p>实体类字段属性上需要增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字段添加填充内容</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写处理器来处理这个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atapathy.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log4j</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 一定不要忘记把处理器加到IOC容器中！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 插入时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill.....&quot;</span>);</span><br><span class="line">        <span class="comment">// setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill.....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试添加和更新然后观察时间</p>
<p><a href="https://imgtu.com/i/jYWonK"><img src="https://s1.ax1x.com/2022/07/05/jYWonK.png" alt="jYWonK.png"></a></p>
</li>
</ol>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！</p>
<blockquote>
<p>乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题， 再次更新值测试 </p>
<p>悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！</p>
</blockquote>
<p>当要更新一条记录的时候，希望这条记录没有被别人更新<br>乐观锁实现方式:</p>
<blockquote>
<ul>
<li>取出记录时，获取当前 version</li>
<li>更新时，带上这个 version</li>
<li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li>
<li>如果 version 不对，就更新失败</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">乐观锁：<span class="number">1</span>、先查询，获得版本号 version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- A线程</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;Gods&quot;, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;Gods&quot;, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="测试一下MybatisPlus的乐观锁插件："><a href="#测试一下MybatisPlus的乐观锁插件：" class="headerlink" title="测试一下MybatisPlus的乐观锁插件："></a>测试一下MybatisPlus的乐观锁插件：</h4><ol>
<li><p>给数据库中增加version字段！</p>
<p><a href="https://imgtu.com/i/jYWT0O"><img src="https://s1.ax1x.com/2022/07/05/jYWT0O.png" alt="jYWT0O.png"></a></p>
</li>
<li><p>实体类添加对应的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span> <span class="comment">//乐观锁Version注解</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atapathy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atapathy.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    最新版MybatisPlus注册乐观锁插件，因为乐观锁配置(OptimisticLockerInterceptor已经弃用)</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return interceptor;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试乐观锁成功！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOptimisticLocker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、查询用户信息</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 2、修改用户信息</span></span><br><span class="line">    user.setName(<span class="string">&quot;Gods&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;gods@qq.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、执行更新操作</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">    <span class="comment">//查询修改后的值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现查询语句的where条件自动帮我们添加了version判断</p>
<p><a href="https://imgtu.com/i/jYW77D"><img src="https://s1.ax1x.com/2022/07/05/jYW77D.png" alt="jYW77D.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试乐观锁失败！多线程下</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOptimisticLocker2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 线程 1</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;Gods1&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;gods@qq.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 模拟另外一个线程执行了插队操作</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;Gods2&quot;</span>);</span><br><span class="line">    user2.setEmail(<span class="string">&quot;gods@qq.com&quot;</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line">    <span class="comment">// 自旋锁来多次尝试提交！</span></span><br><span class="line">    userMapper.updateById(user); <span class="comment">// 如果没有乐观锁就会覆盖插队线程的值！</span></span><br><span class="line">    <span class="comment">//查询修改后的值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：可以发现结果为Gods2</p>
<p><a href="https://imgtu.com/i/jYWbAe"><img src="https://s1.ax1x.com/2022/07/05/jYWbAe.png" alt="jYWbAe.png"></a></p>
</li>
</ul>
</li>
</ol>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="测试Id查询"><a href="#测试Id查询" class="headerlink" title="测试Id查询"></a>测试Id查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><a href="https://imgtu.com/i/jYWqtH"><img src="https://s1.ax1x.com/2022/07/05/jYWqtH.png" alt="jYWqtH.png"></a></p>
<h4 id="测试批量查询"><a href="#测试批量查询" class="headerlink" title="测试批量查询"></a>测试批量查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchId</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：注意查看sql语句</p>
<p><a href="https://imgtu.com/i/jYWLhd"><img src="https://s1.ax1x.com/2022/07/05/jYWLhd.png" alt="jYWLhd.png"></a></p>
<h4 id="按条件查询：使用map操作"><a href="#按条件查询：使用map操作" class="headerlink" title="按条件查询：使用map操作"></a>按条件查询：使用map操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 自定义查询</span></span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">17</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：注意查看SQL语句</p>
<p><a href="https://imgtu.com/i/jYWX9A"><img src="https://s1.ax1x.com/2022/07/05/jYWX9A.png" alt="jYWX9A.png"></a></p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>分页在网站使用的频率十分之多！</p>
<p>使用分页的几种方法</p>
<ol>
<li>原始的 limit 进行分页 </li>
<li>pageHelper 第三方插件 </li>
<li>MybatisPlus内置的分页插件！</li>
</ol>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol>
<li><p>配置拦截器组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新版MybatisPlus分页插件</span></span><br><span class="line"><span class="comment">// 分页插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用Page对象即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 参数一：当前页</span></span><br><span class="line">    <span class="comment">// 参数二：页面大小</span></span><br><span class="line">    <span class="comment">// 使用了分页插件之后，所有的分页操作也变得简单的！</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page,<span class="literal">null</span>);</span><br><span class="line">    List&lt;User&gt; records = page.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//获取总数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    System.out.println(<span class="string">&quot;页面总数：&quot;</span>+total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：注意查看SQL语句</p>
<p><a href="https://imgtu.com/i/jYWvct"><img src="https://s1.ax1x.com/2022/07/05/jYWvct.png" alt="jYWvct.png"></a></p>
</li>
</ol>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>和查询操作类似，这里就不一一演示了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试Id删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过id批量删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchId</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.deleteBatchIds(Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过map删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老六&quot;</span>);</span><br><span class="line">    userMapper.deleteByMap(map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><blockquote>
<p>物理删除 ：从数据库中直接移除  </p>
<p>逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted &#x3D; 0 &#x3D;&gt; deleted &#x3D; 1</p>
</blockquote>
<p>管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！</p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li><p>在数据表中增加一个 deleted 字段</p>
<p><a href="https://imgtu.com/i/jYWj1I"><img src="https://s1.ax1x.com/2022/07/05/jYWj1I.png" alt="jYWj1I.png"></a></p>
</li>
<li><p>实体类中增加属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置到组件类里(目前最新版本的已经剔除，默认集成好了，只需添加了注解即可)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逻辑删除组件！</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span>  <span class="comment">#逻辑删除</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p><a href="https://imgtu.com/i/jYfpB8"><img src="https://s1.ax1x.com/2022/07/05/jYfpB8.png" alt="jYfpB8.png"></a></p>
<p>记录依旧在数据库，但是值确已经变化了！</p>
<p>我们再测试一下查询</p>
<p><a href="https://imgtu.com/i/jYWxjP"><img src="https://s1.ax1x.com/2022/07/05/jYWxjP.png" alt="jYWxjP.png"></a></p>
</li>
</ol>
<h2 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h2><ul>
<li>我们在平时的开发中，会遇到一些慢sql。</li>
<li>测试工具： druid，MybatisPlus提供的性能分析插件</li>
<li>MybatisPlus提供的性能分析插件的作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间 ，如果超过这个时间就停止运行！</li>
</ul>
<p>使用方式：最新版已改为执行SQL分析打印,查阅官网即可：<a href="https://baomidou.com/pages/833fab/">https://baomidou.com/pages/833fab/</a></p>
<ol>
<li><p>导入插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SQL执行效率插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="comment">// 设置 dev test 环境开启，保证我们的效率</span></span><br><span class="line"><span class="keyword">public</span> PerformanceInterceptor <span class="title function_">performanceInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PerformanceInterceptor</span> <span class="variable">performanceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">PerformanceInterceptor</span>();</span><br><span class="line">    performanceInterceptor.setMaxTime(<span class="number">100</span>); <span class="comment">// ms设置sql执行的最大时间，如果超过了则不执行</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="literal">true</span>); <span class="comment">// 是否格式化代码</span></span><br><span class="line">    <span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住，要在SpringBoot中配置环境为dev或者 test 环境！</p>
</li>
<li><p>测试查询全部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 参数是一个 Wrapper ，条件构造器，这里我们先不用 null</span></span><br><span class="line">    <span class="comment">// 查询全部用户</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><a href="https://imgtu.com/i/jYfSnf"><img src="https://s1.ax1x.com/2022/07/05/jYfSnf.png" alt="jYfSnf.png"></a></p>
</li>
</ol>
<h2 id="条件构造器：Wrapper"><a href="#条件构造器：Wrapper" class="headerlink" title="条件构造器：Wrapper"></a>条件构造器：Wrapper</h2><p>查阅官方文档使用即可：<a href="https://baomidou.com/pages/10c804/#abstractwrapper">https://baomidou.com/pages/10c804/#abstractwrapper</a></p>
<p>警告:</p>
<p>官方不支持以及不赞成在 <strong>RPC</strong> 调用中把 Wrapper 进行传输</p>
<h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC?"></a>什么是RPC?</h3><p><a href="https://blog.csdn.net/lgxzzz/article/details/120921461">https://blog.csdn.net/lgxzzz/article/details/120921461</a></p>
<p>Wrapper的后期可维护性不高，复杂SQL还是推荐使用xml格式编写</p>
<h2 id="代码自动生成器"><a href="#代码自动生成器" class="headerlink" title="代码自动生成器"></a>代码自动生成器</h2><p>官方使用的是逆向工程实现：<a href="https://baomidou.com/pages/779a6e/">https://baomidou.com/pages/779a6e/</a></p>
<p>我推荐使用idea自带插件**<a href="https://blog.csdn.net/weixin_43982359/article/details/121799836">EasyCode</a>**</p>
<h3 id="我自定义的EasyCode模板"><a href="#我自定义的EasyCode模板" class="headerlink" title="我自定义的EasyCode模板"></a>我自定义的EasyCode模板</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;makejava&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;1.2.4&quot;</span><span class="punctuation">,</span><span class="attr">&quot;userSecure&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currTypeMapperGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Default&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currTemplateGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;GodsTemplate&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currColumnConfigGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Default&quot;</span><span class="punctuation">,</span><span class="attr">&quot;currGlobalConfigGroupName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Default&quot;</span><span class="punctuation">,</span><span class="attr">&quot;typeMapper&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;template&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;GodsTemplate&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;GodsTemplate&quot;</span><span class="punctuation">,</span><span class="attr">&quot;elementList&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;controller.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;Controller\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/controller\&quot;))\n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;controller;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;\nimport org.springframework.web.bind.annotation.*;\nimport io.swagger.annotations.*;\nimport com.baomidou.mybatisplus.plugins.Page;\nimport com.rambler.core.door.Response;\nimport java.util.List;\n \nimport javax.annotation.Resource;\n \n/**\n * @author $!author\n * @since $!time.currTime()\n */\n@Api(tags = \&quot;$!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)控制层\&quot;)\n@RestController\n@RequestMapping(\&quot;/$!tool.firstLowerCase($tableInfo.name)\&quot;)\npublic class $!&#123;tableName&#125; &#123;\n    /**\n     * 服务对象\n     */\n    @Resource\n    private $!&#123;tableInfo.name&#125;Service $!tool.firstLowerCase($tableInfo.name)Service;\n \n    @ApiOperation(value = \&quot;通过主键查询单条数据\&quot;)\n    @ApiImplicitParam(name = \&quot;id\&quot;, value = \&quot;实体id\&quot;, required = true, paramType = \&quot;query\&quot;)\n    @RequestMapping(value = \&quot;selectOne\&quot;, method = RequestMethod.GET)\n    public Response&lt;$tableInfo.name&gt; selectOne($!pk.shortType $!pk.name) &#123;\n        if (id == null) &#123;\n            return Response.createErrorResponse(\&quot;参数错误\&quot;);\n        &#125;\n        $tableInfo.name result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.selectById($!pk.name);\n        if(result != null)&#123;\n            return Response.createSuccessResponse(\&quot;查询成功\&quot;, result);\n        &#125;\n        return Response.createErrorResponse(\&quot;查询失败\&quot;);\n    &#125;\n    \n    @ApiOperation(value = \&quot;发布新增实体类\&quot;)\n    @RequestMapping(value = \&quot;insert\&quot;, method = RequestMethod.POST)\n    public Response&lt;$tableInfo.name&gt; insert(@RequestBody @ApiParam(name = \&quot;文章对象\&quot;, value = \&quot;json格式\&quot;, required = true) $tableInfo.name $!tool.firstLowerCase($tableInfo.name)) &#123;\n        int result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.insert($!tool.firstLowerCase($tableInfo.name));\n        if (result &gt; 0) &#123;\n            return Response.createSuccessResponse(\&quot;新增成功\&quot;, $!tool.firstLowerCase($tableInfo.name));\n        &#125;\n        return Response.createErrorResponse(\&quot;新增失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;更新实体\&quot;)\n    @RequestMapping(value = \&quot;update\&quot;, method = RequestMethod.PUT)\n    public Response&lt;$tableInfo.name&gt; update(@RequestBody @ApiParam(name = \&quot;文章对象\&quot;, value = \&quot;json格式\&quot;, required = true) $tableInfo.name $!tool.firstLowerCase($tableInfo.name)) &#123;\n        int result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.update($!tool.firstLowerCase($tableInfo.name));\n        if (result != -1) &#123;\n            return Response.createSuccessResponse(\&quot;修改成功\&quot;, null);\n        &#125;\n        return Response.createErrorResponse(\&quot;修改失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;通过id删除\&quot;)\n    @ApiImplicitParam(name = \&quot;id\&quot;, value = \&quot;实体id\&quot;, required = true, paramType = \&quot;query\&quot;)\n    @RequestMapping(value = \&quot;delete\&quot;, method = RequestMethod.DELETE)\n    public Response&lt;$tableInfo.name&gt; delete($!pk.shortType $!pk.name) &#123;\n        if (id == null) &#123;\n            return Response.createErrorResponse(\&quot;参数错误\&quot;);\n        &#125;\n        int result = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.deleteById($!pk.name);\n        if (result &gt; 0) &#123;\n            return Response.createSuccessResponse(\&quot;删除成功\&quot;, null);\n        &#125;\n        return Response.createErrorResponse(\&quot;删除失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;查询所有\&quot;, notes = \&quot;不需要参数\&quot;)\n    @RequestMapping(value = \&quot;selectAll\&quot;, method = RequestMethod.GET)\n    public Response&lt;List&lt;$tableInfo.name&gt;&gt; selectAll() &#123;\n        List&lt;$tableInfo.name&gt; $!tool.firstLowerCase($tableInfo.name)List = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.selectAll();\n        if ($!tool.firstLowerCase($tableInfo.name)List != null) &#123;\n            return Response.createSuccessResponse(\&quot;查询成功\&quot;, $!tool.firstLowerCase($tableInfo.name)List);\n        &#125;\n        return Response.createErrorResponse(\&quot;查询失败\&quot;);\n    &#125;\n \n    @ApiOperation(value = \&quot;分页查询\&quot;)\n    @ApiImplicitParams(&#123;\n            @ApiImplicitParam(name = \&quot;start\&quot;, value = \&quot;开始位置,正整数\&quot;, required = true, paramType = \&quot;query\&quot;),\n            @ApiImplicitParam(name = \&quot;limit\&quot;, value = \&quot;页面大小,正整数\&quot;, required = true, paramType = \&quot;query\&quot;)\n    &#125;)\n    @RequestMapping(value = \&quot;selectPage\&quot;, method = RequestMethod.GET)\n    public Response&lt;Page&lt;$tableInfo.name&gt;&gt; selectPage(Integer start, Integer limit) &#123;\n        if(start &lt; 0 || limit &lt;= 0)&#123;\n            return Response.createErrorResponse(\&quot;分页参数错误\&quot;);\n        &#125;\n        List&lt;$tableInfo.name&gt; $!tool.firstLowerCase($tableInfo.name)List = $!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.selectPage(start, limit);\n        Page&lt;$tableInfo.name&gt; page = new Page&lt;&gt;((start/limit)+1,limit);\n        page.setRecords($!tool.firstLowerCase($tableInfo.name)List);\n        page.setTotal($!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.count());\n        if ($!tool.firstLowerCase($tableInfo.name)List != null) &#123;\n            return Response.createSuccessResponse(\&quot;查询成功\&quot;, page);\n        &#125;\n        return Response.createErrorResponse(\&quot;查询失败\&quot;);\n    &#125;\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;debug.json.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;// 禁止将生成结果写入到文件\n$!callback.setWriteFile(false)\n\n//调试表原始对象\n$!tool.debug($tableInfo.obj)\n\n//调试列原始对象\n$!tool.debug($tableInfo.fullColumn.get(0).obj)\n\n//调试列原始列类型\n$!tool.debug($tableInfo.fullColumn.get(0).obj.dataType)\n\n//获取原始列类型中的字段\nsqlType = $!tool.getField($tableInfo.fullColumn.get(0).obj.dataType, \&quot;typeName\&quot;)\n\n//执行原始列类型中的方法\nsqlTypeLen = $!tableInfo.fullColumn.get(0).obj.dataType.getLength()\n&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;mapper.xml.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##引入mybatis支持\n$!mybatisSupport\n \n##设置保存名称与保存位置\n$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, \&quot;Mapper.xml\&quot;))\n$!callback.setSavePath($tool.append($modulePath, \&quot;/src/main/resources/mybatis/mapper\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC \&quot;-//mybatis.org//DTD Mapper 3.0//EN\&quot; \&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\&quot;&gt;\n&lt;mapper namespace=\&quot;$!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper\&quot;&gt;\n    &lt;!-- 结果集 --&gt;\n    &lt;resultMap type=\&quot;$!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;\&quot; id=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n#foreach($column in $tableInfo.fullColumn)\n        &lt;result property=\&quot;$!column.name\&quot; column=\&quot;$!column.obj.name\&quot; jdbcType=\&quot;$!column.ext.jdbcType\&quot;/&gt;\n#end\n    &lt;/resultMap&gt;\n    \n    &lt;!-- 基本字段 --&gt;\n    &lt;sql id=\&quot;Base_Column_List\&quot;&gt;\n        #allSqlColumn()\n    &lt;/sql&gt;\n    \n    &lt;!-- 查询单个 --&gt;\n    &lt;select id=\&quot;selectById\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n          &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n        where $!pk.obj.name = #&#123;$!pk.name&#125;\n    &lt;/select&gt;\n \n    &lt;!-- 分页查询 --&gt;\n    &lt;select id=\&quot;selectPage\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n        &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n        limit #&#123;start&#125;,#&#123;limit&#125;\n    &lt;/select&gt;\n \n    &lt;!-- 查询全部 --&gt;\n    &lt;select id=\&quot;selectAll\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n        &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n    &lt;/select&gt;\n \n    &lt;!--通过实体作为筛选条件查询--&gt;\n    &lt;select id=\&quot;selectList\&quot; resultMap=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n        select\n        &lt;include refid=\&quot;Base_Column_List\&quot; /&gt;\n        from $!tableInfo.obj.name\n        &lt;where&gt;\n        #foreach($column in $tableInfo.fullColumn)\n            &lt;if test=\&quot;$!column.name != null#if($column.type.equals(\&quot;java.lang.String\&quot;)) and $!column.name != &#x27;&#x27;#end\&quot;&gt;\n                and $!column.obj.name = #&#123;$!column.name&#125;\n            &lt;/if&gt;\n        #end\n        &lt;/where&gt;\n    &lt;/select&gt;\n \n    &lt;!-- 新增所有列 --&gt;\n    &lt;insert id=\&quot;insert\&quot; keyProperty=\&quot;$!pk.name\&quot; useGeneratedKeys=\&quot;true\&quot;&gt;\n        insert into $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.fullColumn)$!column.obj.name#if($velocityHasNext), #end#end)\n        values ( #foreach($column in $tableInfo.fullColumn)#&#123;$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end#end)\n    &lt;/insert&gt;\n    \n    &lt;!-- 批量新增 --&gt;\n    &lt;insert id=\&quot;batchInsert\&quot;&gt;\n        insert into $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.fullColumn)$!column.obj.name#if($velocityHasNext), #end#end)\n        values \n        &lt;foreach collection=\&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)s\&quot; item=\&quot;item\&quot; index=\&quot;index\&quot; separator=\&quot;,\&quot;&gt;\n        (\n            #foreach($column in $tableInfo.fullColumn)\n            #&#123;item.$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end\n#end\n         )\n         &lt;/foreach&gt;\n    &lt;/insert&gt;\n \n    &lt;!-- 通过主键修改数据 --&gt;\n    &lt;update id=\&quot;update\&quot;&gt;\n        update $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125;\n        &lt;set&gt;\n        #foreach($column in $tableInfo.otherColumn)\n            &lt;if test=\&quot;$!column.name != null#if($column.type.equals(\&quot;java.lang.String\&quot;)) and $!column.name != &#x27;&#x27;#end\&quot;&gt;\n                $!column.obj.name = #&#123;$!column.name&#125;,\n            &lt;/if&gt;\n        #end\n        &lt;/set&gt;\n        where $!pk.obj.name = #&#123;$!pk.name&#125;\n    &lt;/update&gt;\n \n    &lt;!--通过主键删除--&gt;\n    &lt;delete id=\&quot;deleteById\&quot;&gt;\n        delete from $!&#123;tableInfo.obj.name&#125; where $!pk.obj.name = #&#123;$!pk.name&#125;\n    &lt;/delete&gt;\n    \n    &lt;!-- 总数 --&gt;\n    &lt;select id=\&quot;count\&quot; resultType=\&quot;int\&quot;&gt;\n        select count(*) from $!&#123;tableInfo.obj.name&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;service.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;Service\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/service\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport java.util.List;\nimport java.util.Map;\n \n/**\n * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务接口\n *\n * @author $!author\n * @since $!time.currTime()\n */\npublic interface $!&#123;tableName&#125; &#123;\n \n    /**\n     * 通过ID查询单条数据\n     */\n    $!&#123;tableInfo.name&#125; selectById($!pk.shortType $!pk.name);\n \n    /**\n     * 分页查询\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectPage(int start, int limit);\n \n    /**\n     * 查询全部\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectAll();\n    \n    /**\n     * 通过实体作为筛选条件查询\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectList($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 新增数据\n     */\n    int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n\t\n\t/**\n     * 批量新增\n     */\n    int batchInsert(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)s);\n\t\n    /**\n     * 修改数据\n     */\n    int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 通过主键删除数据\n     */\n    int deleteById($!pk.shortType $!pk.name);\n    \n    /**\n     * 查询总数据数\n     */\n    int count();\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;serviceImpl.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;ServiceImpl\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/service/impl\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service.impl;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;\nimport $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;\nimport org.springframework.stereotype.Service;\n \nimport javax.annotation.Resource;\nimport java.util.List;\n \n/**\n * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务实现类\n *\n * @author $!author\n * @since $!time.currTime()\n */\n@Service(\&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Service\&quot;)\npublic class $!&#123;tableName&#125; implements $!&#123;tableInfo.name&#125;Service &#123;\n    @Resource\n    private $!&#123;tableInfo.name&#125;Mapper $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Mapper;\n \n    /**\n     * 通过ID查询单条数据\n     *\n     * @param $!pk.name 主键\n     * @return 实例对象\n     */\n    @Override\n    public $!&#123;tableInfo.name&#125; selectById($!pk.shortType $!pk.name) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectById($!pk.name);\n    &#125;\n \n    /**\n     * 分页查询\n     *\n     * @param start 查询起始位置\n     * @param limit 查询条数\n     * @return 对象列表\n     */\n    @Override\n    public List&lt;$!&#123;tableInfo.name&#125;&gt; selectPage(int start, int limit) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectPage(start, limit);\n    &#125;\n    \n    /**\n     * 查询全部\n     *\n     * @return 对象列表\n     */\n    @Override\n    public List&lt;$!&#123;tableInfo.name&#125;&gt; selectAll() &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectAll();\n    &#125;\n \n    /**\n     * 根据实体类进行筛选\n     \n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 对象列表\n     */\n    @Override\n    public List&lt;$!&#123;tableInfo.name&#125;&gt; selectList($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.selectList($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n    &#125;\n    \n    /**\n     * 新增数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 生效条数\n     */\n    @Override\n    public int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.insert($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n    &#125;\n    \n    /**\n     * 批量新增\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List 实例对象\n     * @return 生效条数\n     */\n    @Override\n    public int batchInsert(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.batchInsert($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List);\n    &#125;\n    \n \n    /**\n     * 修改数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 实例对象\n     */\n    @Override\n    public int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.update($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n    &#125;\n \n    /**\n     * 通过主键删除数据\n     *\n     * @param $!pk.name 主键\n     * @return 是否成功\n     */\n    @Override\n    public int deleteById($!pk.shortType $!pk.name) &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.deleteById($!pk.name);\n    &#125;\n    \n    /**\n     * 查询总数据数\n     *\n     * @return 数据总数\n     */\n    @Override\n    public int count() &#123;\n        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.count();\n    &#125;\n    \n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;mapper.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##定义初始变量\n#set($tableName = $tool.append($tableInfo.name, \&quot;Mapper\&quot;))\n##设置回调\n$!callback.setFileName($tool.append($tableName, \&quot;.java\&quot;))\n$!callback.setSavePath($tool.append($tableInfo.savePath, \&quot;/mapper\&quot;))\n \n##拿到主键\n#if(!$tableInfo.pkColumn.isEmpty())\n    #set($pk = $tableInfo.pkColumn.get(0))\n#end\n \n#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;mapper;\n \nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport org.apache.ibatis.annotations.Param;\nimport java.util.List;\nimport java.util.Map;\n \n/**\n * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表数据库访问层\n *\n * @author $!author\n * @since $!time.currTime()\n */\npublic interface $!&#123;tableName&#125; &#123;\n \n    /**\n     * 通过ID查询单条数据\n     *\n     * @param $!pk.name 主键\n     * @return 实例对象\n     */\n    $!&#123;tableInfo.name&#125; selectById($!pk.shortType $!pk.name);\n\t\n    /**\n     * 分页查询\n     *\n     * @param start 查询起始位置\n     * @param limit 查询条数\n     * @return 对象列表\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectPage(@Param(\&quot;start\&quot;) int start, @Param(\&quot;limit\&quot;) int limit);\n \n    /**\n     * 查询全部\n     *\n     * @return 对象列表\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectAll();\n    \n    /**\n     * 通过实体作为筛选条件查询\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 对象列表\n     */\n    List&lt;$!&#123;tableInfo.name&#125;&gt; selectList($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 新增数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 影响行数\n     */\n    int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n\t\n\t/**\n     * 批量新增\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List 实例对象的集合\n     * @return 影响行数\n     */\n     int batchInsert(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List);\n\t\n    /**\n     * 修改数据\n     *\n     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象\n     * @return 影响行数\n     */\n    int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));\n \n    /**\n     * 通过主键删除数据\n     *\n     * @param $!pk.name 主键\n     * @return 影响行数\n     */\n    int deleteById($!pk.shortType $!pk.name);\n \n    /**\n     * 查询总数据数\n     *\n     * @return 数据总数\n     */\n    int count();\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;pojo.java.vm&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;##引入宏定义\n$!define\n \n##使用宏定义设置回调(保存位置与文件后缀)\n#save(\&quot;/pojo\&quot;, \&quot;.java\&quot;)\n \n##使用宏定义设置包后缀\n#setPackageSuffix(\&quot;pojo\&quot;)\n \n##使用全局变量实现默认包导入\n$!autoImport\nimport java.io.Serializable;\n \n##使用宏定义实现类注释信息\n#tableComment(\&quot;实体类\&quot;)\npublic class $!&#123;tableInfo.name&#125; implements Serializable &#123;\n    private static final long serialVersionUID = $!tool.serial();\n#foreach($column in $tableInfo.fullColumn)\n    #if($&#123;column.comment&#125;)/**\n    * $&#123;column.comment&#125;\n    */#end\n \n    private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;\n#end\n \n#foreach($column in $tableInfo.fullColumn)\n    ##使用宏定义实现get,set方法\n    #getSetMethod($column)\n#end\n&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;columnConfig&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;globalConfig&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>MybatisPlus</category>
        <category>面试加分项</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>MybatisPlus</tag>
        <tag>面试加分项</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁的理解</title>
    <url>/2022/06/11/MySQL%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>前言：</p>
<p>本文为百度文章高级互联网专家的原创文章，本篇仅供学习使用，尊重原创</p>
<p>原文链接：<a href="https://baijiahao.baidu.com/s?id=1709427910908845097&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709427910908845097&amp;wfr=spider&amp;for=pc</a></p>
<hr>
<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>InnoDB实现了如下两种标准的行级锁：</p>
<ul>
<li><strong>共享锁</strong>（S Lock）：允许事务对一条行数据进行读取</li>
<li><strong>排他锁</strong>（X Lock）：允许事务对一条行数据进行删除或更新</li>
</ul>
<p>如果一个事务T1已经获得了行r的共享锁， 那么另外的事务T2可以立即获得行r的共享锁， 因为读取并没有改变行 r 的数据， 称这种情况为<strong>锁兼容</strong> (Lock Compatible)。 但若有其他的事务T3想获得行r的排他锁， 则其必须等待事务T1, T2释放行r上的共享锁——这种情况称为<strong>锁不兼容</strong>。因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<p>从上表可以发现，<strong>X锁与任何锁都不兼容，而S锁仅和S锁兼容</strong>。</p>
<p>此外， InnoDB 存储引擎支持多粒度锁定， 这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支待在不同粒度上进行加锁操作， InnoDB 存储引擎支持 一种额外的锁方式， 称之为<strong>意向锁</strong> (Intention Lock)。意向锁是将锁定的对象分为多个层次， 意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>InnoDB存储引擎支持意向锁设计比较简练，其<strong>意向锁即为表级别的锁</strong>。设计目的主要是为了在事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁</li>
<li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此<strong>意向锁不会阻塞除全表扫描以外的任何请求</strong>，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。</p>
<p>如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。</p>
<p>故表级意向锁和行级锁的兼容性如下表所示：</p>
<h1 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h1><p>InnoDB有三种行锁的算法：</p>
<ul>
<li><p><strong>Record Lock</strong></p>
<p>简单说就是单个行记录上加锁，防止事务间修改或删除数据。Record Lock总是会去锁住索引记录，如果表建立的时候没有设置任何一个索引，InnoDB存储引擎会使用隐式的主键来进行锁定。</p>
</li>
<li><p><strong>Gap Lock</strong></p>
<p>间隙锁，表示只锁住一段范围，<strong>不锁记录本身</strong>，通常表示两个索引记录之间，或者索引上的第一条记录之前，或者最后一条记录之后的锁。</p>
</li>
<li><p><strong>Next-Key Lock</strong></p>
<p>Gap Lock + Record Lock，锁定一个范围及锁定记录本身。例如一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-key Locking的区间为<code>(负无穷, 10), (10, 11), (11, 13), (12, 20), (20, 正无穷)</code>。需要理解一点，InnoDB中加锁都是给所有记录一条一条加锁，并没有一个直接的范围可以直接锁住，所以会生成多个区间。</p>
</li>
</ul>
<p>MySQL默认情况下使用RR的隔离级别，而<strong>Next-key Lock正是为了解决RR隔离级别下的不可重复读问题和幻读问题</strong>。所谓不可重复读就是一个事务内执行相同的查询，会看到不同的行记录，在RR隔离级别下这是不允许的。</p>
<p>假设索引上有记录<code>1，4，5，8，12</code>，我们执行类似语句<code>SELECT … WHERE col &gt; 10 FOR UPDATE</code>。如果我们不在<code>(8, 12)</code>之间加上Next-key Lock，另外一个会话就可能向其中插入一条记录9，再执行一次相同的<code>SELECT ... FOR UPDATE</code>，就会看到新插入的记录。这也是为什么MySQL插入一条记录时，需要判断下一条记录上是否加锁了，如果加锁就需要等待。</p>
<p><strong>InnoDB对行的查询默认采用Next-key算法</strong>。然而，<strong>当查询条件为等值时，且索引有唯一属性时（就是只锁定一条记录），InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock</strong>，即仅锁住索引本身，而不是一个范围，因为此时不会产生重复读问题。</p>
<h1 id="锁读取"><a href="#锁读取" class="headerlink" title="锁读取"></a>锁读取</h1><blockquote>
<p><strong>一致性非锁定读</strong>(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVCC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
</blockquote>
<p><a href="https://imgtu.com/i/jJJdOK"><img src="https://s1.ax1x.com/2022/07/04/jJJdOK.jpg" alt="jJJdOK.jpg"></a></p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为<strong>行多版本技术</strong>。由此带来的并发控制，称之为<strong>多版本并发控制</strong>(Multi Version Concurrency Control, MVCC)。**InnoDB是通过undo log来实现MVCC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p><strong>一致性非锁定读是InnoDB默认的读取方式</strong>，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。</p>
<p>我们下面举个例子来详细说明一下上述的情况。</p>
<p><a href="https://imgtu.com/i/jJJ0eO"><img src="https://s1.ax1x.com/2022/07/04/jJJ0eO.jpg" alt="jJJ0eO.jpg"></a></p>
<p>首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有提交。与此同时，在开启另一个会话B，将test表中id为1的记录修改为id&#x3D;3，但是事务同样也没有提交，这样id&#x3D;1的行其实加了一个排他锁。</p>
<p>由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p>当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了：</p>
<ul>
<li><strong>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本</strong>，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。</li>
<li><strong>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据</strong>，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</li>
</ul>
<p>在默认情况下，即事务的隔离级别是repeatable read模式下，InnoDB存储引擎的SELECT操作使用的是一致性非锁定读。但是在某些情况下，用户需要显示的读取数据操作进行加锁保证数据逻辑的一致性。</p>
<p>InnoDB提供了两种方式实现一致性锁定读：</p>
<ul>
<li><code>select … for udpate</code>，对读取的行加了X锁</li>
<li><code>select … lock in share mode</code>，对读取的行加了S锁</li>
</ul>
<p>需要注意的是，以上两种语句必须在一个事务当中，当事务提交了，锁也就释放了。</p>
<h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><blockquote>
<p>因为不同锁之间的兼容性关系，有时候一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是<strong>阻塞</strong>。</p>
</blockquote>
<p>在InnoDB，参数<code>innodb_lock_wait_timeout</code>用来控制等待的时间，<code>innodb_rollback_on_timeout</code>用来设定是否在等待超时后回滚。前者是动态的，后者是静态的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_lock_wait_timeout&#x27;\G;</span><br><span class="line">*************************** 1. row</span><br><span class="line">Variable_name: innodb_lock_wait_timeout</span><br><span class="line">Value: 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;innodb_rollback_on_timeout&#x27;\G;</span><br><span class="line">1. row</span><br><span class="line">: innodb_rollback_on_timeout</span><br><span class="line">Value: OFF</span><br></pre></td></tr></table></figure>

<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种相互等待的现象。若无外力作用，事务都将无法推进下去。</p>
<p>解决死锁做简单的方法就是超时，即当两个事务互相等待时，当一个等待时间超过了某一阈值，其中一个事务进行回滚，另一个等待的事务就能继续进行。</p>
<p>但是如果超时的事务所占权重比较大，如事务更新了很多行，占用了较多的undo log，回滚这个事务的时间相对于另一个事务所占用的时间可能会更多，就显得不合适了。</p>
<p>因此，除了超时机制，当前数据库都普遍采用<strong>等待图</strong>（wait-for graph）的方式来进行死锁检测。</p>
<p>wait-for graph要求数据库保存以下两种信息:</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在 wait-for graph中,事务为图中的节点。而在图中,事务T1指向T2边的定义为:</p>
<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源,也就是事务之间在等待相同的资源,而事务T1发生在事务T2的后面</li>
</ul>
<p>来看一个例子：</p>
<p><a href="https://imgtu.com/i/jJJay6"><img src="https://s1.ax1x.com/2022/07/04/jJJay6.jpg" alt="jJJay6.jpg"></a></p>
<p>在 Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4,故在wait-for graph中应有4个节点。</p>
<p><a href="https://imgtu.com/i/jJJUQx"><img src="https://s1.ax1x.com/2022/07/04/jJJUQx.jpg" alt="jJJUQx.jpg"></a></p>
<p>通过上图可以发现存在回路(t1,t2)，因此存在死锁。可以发现wait-for graph是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。</p>
<h1 id="InnoDB锁相关状态查询"><a href="#InnoDB锁相关状态查询" class="headerlink" title="InnoDB锁相关状态查询"></a>InnoDB锁相关状态查询</h1><p>用户可以使用<code>INFOMATION_SCHEMA</code>库下的<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>表来监控当前事务并分析可能出现的锁问题。的关键字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;</span><br><span class="line">************************************* 1.row *********************************************</span><br><span class="line">trx_id: 7311F4</span><br><span class="line">trx_state: LOCK WAIT</span><br><span class="line">trx_started: 2010-01-04 10:49:33</span><br><span class="line">trx_requested_lock_id: 7311F4:96:3:2</span><br><span class="line">trx_wait_started: 2010-01-04 10:49:33</span><br><span class="line">trx_weight: 2</span><br><span class="line">trx_mysql_thread_id: 471719</span><br><span class="line">trx_query: select * from parent lock in share mode</span><br></pre></td></tr></table></figure>

<p>表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表，该表的关键字段组成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM.INNODB_LOCKS\G;</span><br><span class="line">1. row</span><br><span class="line">lock_id: 16219:56:4:5</span><br><span class="line">lock_trx_id: 16219</span><br><span class="line">lock_mode: X,GAP</span><br><span class="line">lock_type: RECORD</span><br><span class="line">lock_table: `test`.`z`</span><br><span class="line">lock_index: b</span><br><span class="line">lock_space: 56</span><br><span class="line">lock_page: 4</span><br><span class="line">lock_rec: 5</span><br><span class="line">lock_data: 6, 7</span><br><span class="line">2. row</span><br><span class="line">lock_id: 16218:56:4:5</span><br><span class="line">: 16218</span><br><span class="line">lock_mode: X,GAP</span><br><span class="line">lock_type: RECORD</span><br><span class="line">lock_table: `test`.`z`</span><br><span class="line">lock_index: b</span><br><span class="line">lock_space: 56</span><br><span class="line">lock_page: 4</span><br><span class="line">lock_rec: 5</span><br><span class="line">lock_data: 6, 7</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM.INNODB_LOCK_WAITS\G;</span><br><span class="line">*******************************************1.row************************************</span><br><span class="line">requesting_trx_id: 7311F4</span><br><span class="line">requesting_lock_id: 7311F4:96:3:2</span><br><span class="line">blocking_trx_id: 730FEE</span><br><span class="line">blocking_lock_id: 730FEE:96:3:2</span><br></pre></td></tr></table></figure>

<p>通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。</p>
<h1 id="锁的应用实例解析"><a href="#锁的应用实例解析" class="headerlink" title="锁的应用实例解析"></a>锁的应用实例解析</h1><p>有一点需要特别注意，MySQL怎么使用锁，与事务的隔离级别、列上的索引状况等密切相关。单拎出一条SQL语句来讨论加锁的方式以及范围而不考虑使用场景，都是耍流氓的行为。</p>
<p>下面就不同场景下锁的使用情况做一下对比，深入理解上面的理论知识。</p>
<h2 id="场景1：RR隔离级别-主键索引"><a href="#场景1：RR隔离级别-主键索引" class="headerlink" title="场景1：RR隔离级别+主键索引"></a>场景1：RR隔离级别+主键索引</h2><p>首先根据如下代码创建测试表t，然后开启两个事务进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t(a int primary key);</span><br><span class="line">insert into t select 1;</span><br><span class="line">insert into t select 2;</span><br><span class="line">insert into t select 5;</span><br><span class="line">insert into t select 7;</span><br><span class="line">insert into t select 9;</span><br></pre></td></tr></table></figure>

<p>开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where a=5 for update;</span><br></pre></td></tr></table></figure>

<p>开启事务2并提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t select 4;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>表t共有1、2、5、7、9五个值，在上面的例子中，在事务1中首先对<code>a=5</code>进行X锁定，而由于a是主键且唯一，因此锁定的仅是5这个值，而不是（2,5）这个范围。这样在事务2中插入值4而不会阻塞，可以立即插入并返回。即锁定由Next-key Lock算法降级为Record Lock，从而提高应用的并发性。</p>
<p>需要意的一点是，对于唯一键值的锁定，<strong>Next-Key Lock降级为Record Lock仅存在于查询所有的唯一索引列</strong>。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是range类型查询，而不是const类型查询，故InnoDB存储引擎依然使用Next-Key Lock进行锁定。</p>
<p>但如果对主键进来范围查询时，锁的范围是怎么样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where a&lt;=5 for update;</span><br></pre></td></tr></table></figure>

<p>针对下面的sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test.t select 6;</span><br><span class="line">insert into test.t select 8</span><br></pre></td></tr></table></figure>

<p>第一条会产生锁等待，而第二条可以插入成功。</p>
<p>表t共有1、2、5、7、9五个值，在上面的例子中，在事务1中执行<code>a&lt;=5</code>范围查询时，事务1加锁范围是<code>(负无穷, 1)、(1, 2)、(2, 5)、(5, 7)</code>，且<code>1、2、5、7</code>这四条记录也都加锁了，也就是说再插入<code>&lt;=7</code>的记录都是会产生锁等待，插入记录8是成功的。</p>
<p>那么InnoDB如何判断是否允许插入数据呢？对于普通索引，insert的加锁策略是：查找小于等于 insert_rec 的第一条记录，然后查看第一条记录的下一个记录是否有Gap锁，有则等待，没有则插入。比如说我们插入6这条记录，首先定位<code>&lt;=6</code>的记录，也就是5，然后确认5的下一条记录是否锁住了Gap，这里也就是7，当7这条记录有锁是代表锁住的是<code>(5, 7)</code>这个范围，就不允许插入（会申请一把插入意向锁），保证了可重复读。证明了在RR隔离级别下使用了Next-key Lock来保证其“可重复读”的特性。如果没有锁就直接插入即可。</p>
<p>但是如果插入的记录有唯一约束时，只判断下一条记录是否锁住了Gap就不行了，显然会插入重复数据破坏唯一性。这时还会把插入的记录与前一条数据进行比较，如果相同则给插入记录的前一条记录加S Lock（lock in share mode），加锁成功则返回duplicate key，否则等待S Lock。</p>
<p>这个地方可能有人会有一个疑问，为什么MySQL在加锁时，不直接加5这条记录本身以及&lt;5的记录呢？为什么还要给加锁呢？因为(5, 7)加不加锁并不会影响RR级别可重复读的特性。其实这就跟B+树有关系了，首先MySQL定位到1这条记录并加锁，然后顺着1往后读取数据并加锁，直到读取到第一条不匹配数据才能确定是否停止继续读取数据，而在RR隔离级别下只要被读到的数据都需要进行加锁。如果查询条件是&lt;5，那么加锁只会加到5这条记录为止。</p>
<p>如果是在RC隔离级别下，只会对符合条件的记录进行加记录锁，不会对满足条件的下一条记录进行加锁。</p>
<h2 id="场景2：RR隔离级别-普通索引"><a href="#场景2：RR隔离级别-普通索引" class="headerlink" title="场景2：RR隔离级别+普通索引"></a>场景2：RR隔离级别+普通索引</h2><p>正如上面所介绍的，Next-Key Lock降级为Record Lock仅在查询的列是唯一索引且条件为等值查询的情况下。若是辅助索引，则情况会完全不同，</p>
<p>首先根据如下代码创建测试表z：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table z(id int primary key,b int,index(b));</span><br><span class="line">insert into z values(1,1);</span><br><span class="line">insert into z values(3,1);</span><br><span class="line">insert into z values(5,3);</span><br><span class="line">insert into z values(7,6);</span><br><span class="line">insert into z values(10,8);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where b=3 for update;</span><br></pre></td></tr></table></figure>

<p>这时SQL语句通过索引列b进行查询，因此其使用传统的Next-key Locking技术加锁，并且由于有两个索引，其需要分别进行锁定。对于聚集索引，其仅对列id等于5的索引加上Record Lock。那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 z 表进行更新，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。</p>
<p>而对于辅助索引，其加上的是Next-key Lock，锁定的范围是（1, 3），特别需要注意的是，InnoDB存储引擎还会对辅助索引下一个键值加上Gap lock，即还有一个辅助索引范围为（3, 6）的锁。</p>
<p>此时，若在新的事务2中运行下面的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from z where id=5 lock in share mode;</span><br><span class="line">insert into z select 2,1;</span><br><span class="line">insert into z select 4,2;</span><br><span class="line">insert into z select 6,6;</span><br></pre></td></tr></table></figure>

<p>第一个SQL语句，在事务1中执行的SQL语句已经对聚集索引中的列“a&#x3D;5”的值加上X锁，因此执行会被阻塞。</p>
<p>第二SQL语句，主键插入2，没有问题，插入的辅助索引值1也不在锁定的范围（1,3）中，因此可以执行成功。</p>
<p>第三个SQL语句，主键插入4，没有问题，插入的辅助索引值2在锁定的范围（1,3）中，因此执行会被阻塞。</p>
<p>第四个SQL语句，插入的主键6没有被锁定，6也不在范围（1,3）之间。但插入的值6在另一个锁定的范围（3,6）中，故同样需要等待。</p>
<p>在RR隔离级别下，对于INSERT的操作，其会检查插入记录的下一条记录是否被锁定，若已经被锁定，则不允许操作，从而避免不可重复读问题。而下面的SQL语句，不会被阻塞，可以立即执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into z select 8,6;</span><br><span class="line">insert into z select 2,0;</span><br><span class="line">insert into z select 6,7;</span><br></pre></td></tr></table></figure>

<p>从上面的例子中可以看到，Gap Lock的作用是为了阻止多个事务将记录插入到同一个范围内，解决“不可重复读”问题的产生。例如在上面的例子中，事务1中用户已经锁定了b&#x3D;3的记录，若此时没有Gap Lock锁定<code>(3, 6)</code>，那么用户可以插入索引b列为3的记录，这会导致事务1中的用户再次执行同样的查询时会返回不同的记录，即产生不可重复读问题。</p>
<p>这里有一个问题值得思考一下，为什么插入<code>(6, 6)</code>不允许，而插入<code>(8, 6)</code>是允许的。这跟InnoDB索引结构有关系，我们知道二级索引是指向主键，所以结构如：<code>(1, 1), (1, 3), (3, 5), (6, 7), (8, 10)</code>。真正的Gap锁锁住的也是<code>((1, 1), (1, 3))</code>这样的结构，所以当我们插入<code>(6, 6)</code>时，需要插入到<code>(3, 5), (6, 7)</code>之间，这区间被锁，所以无法插入；而我们插入<code>(8, 6)</code>是需要插入到<code>(6, 7), (8, 10)</code>之间，没有锁存在，所以可以插入成功。</p>
<p>另外，在RR隔离级别下，我们访问条件为二级索引的情况下，就算访问一条不存在的记录同样需要加Next-key Lokcs，比如我们查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from z where b=7 for update;</span><br></pre></td></tr></table></figure>

<p>InnoDB会对(6, 8)这个区间加了Gap Lock，也就是说插入这个区间的数据都会被阻塞。</p>
<p>虽然在RR隔离级别默认使用Gap Lock，但用户可以通过以下两种方式来显式地关闭Gap Lock：</p>
<ul>
<li>将事务的隔离级别设置为READ COMMITTED；</li>
<li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1；</li>
</ul>
<p>当设置了上述参数或隔离级别调整到<strong>READ COMMITTED</strong>时，除了外键约束和唯一性检查（duplicate key）依然需要Gap Lock，其余情况仅使用Record Lock进行锁定。但需要知道的是，上述设置破坏了事务的隔离性，并且对于MySQL复制来说，可能会导致主从数据的不一致。虽然MySQL目前默认隔离级别是RR，但是基本生产环境标配基本都是RC隔离级别+ROW格式。</p>
<h2 id="场景3：RC隔离级别-主键索引"><a href="#场景3：RC隔离级别-主键索引" class="headerlink" title="场景3：RC隔离级别+主键索引"></a>场景3：RC隔离级别+主键索引</h2><p>将事务隔离级别切为RC，开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where id&gt;3 for update;</span><br></pre></td></tr></table></figure>

<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into z select 6,6;</span><br></pre></td></tr></table></figure>

<p>可以执行成功。证明在事务1执行主键范围for update时，事务2对这个范围扔可以申请写锁。证明RC隔离级别没有使用NEXT-KEY Lock，而是使用行级锁锁住对应的记录。</p>
<h2 id="场景4：RC隔离级别-普通索引"><a href="#场景4：RC隔离级别-普通索引" class="headerlink" title="场景4：RC隔离级别+普通索引"></a>场景4：RC隔离级别+普通索引</h2><p>将事务隔离级别切为RC，开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from z where b&gt;3 for update;</span><br></pre></td></tr></table></figure>

<p>此时，若在新的事务2中运行下面的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into z select 8,4;</span><br><span class="line">update z set b = 10 where b = 6;</span><br><span class="line">update z set b = 10 where b = 1;</span><br></pre></td></tr></table></figure>

<p>第一个SQL语句，插入数据到事务1的for update范围内是可以的，因为这里事务1在RC模式下没有加NEXT-KEY LOCK锁，所以可以插入数据。</p>
<p>第二个SQL语句，会出现锁等待，我们选择普通索引作为条件，此时MySQL给普通索引b&gt;3的记录都会加行锁。同时，这些记录对应主键索引上的记录也都加上了锁</p>
<p>第三个SQL语句，插入成功，说明b&lt;3的记录都无锁。</p>
<h2 id="场景5：RR-无索引"><a href="#场景5：RR-无索引" class="headerlink" title="场景5：RR + 无索引"></a>场景5：RR + 无索引</h2><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的</strong>，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将会给所有记录加锁</strong>。</p>
<p>在RR隔离级别下，由于查询条件没有索引，那么InnoDB需要扫描所有数据来查找数据，对于扫描过的数据InnoDB都会加上锁，并且是加Next-key lock。</p>
<p>建立测试表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tab_no_index(id int,b int) engine=innodb;</span><br><span class="line">insert into tab_no_index values(1,1),(2,2),(3,3),(4,4),(100,100);</span><br></pre></td></tr></table></figure>

<p>开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tab_no_index where id = 1 for update;</span><br></pre></td></tr></table></figure>

<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into tab_no_index values(5,5);</span><br></pre></td></tr></table></figure>

<p>这时候，并不能插入成功。看起来事务1只给一行加了排他锁，但事务2在请求其他行的排他锁时，却出现了锁等待。原因就在于没有索引的情况下，InnoDB只能扫描所有记录（锁住所有记录）。当我们给其增加一个唯一索引后，InnoDB就只锁定了符合条件的行。</p>
<p>当我们给其增加一个唯一索引后，InnoDB就只锁定了符合条件的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tab_with_index(id int,b int,primary key(id));</span><br><span class="line">insert into tab_with_index values(1,1),(2,2),(3,3),(4,4),(100,100);</span><br></pre></td></tr></table></figure>

<p>开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tab_with_index where id = 1 for update;</span><br></pre></td></tr></table></figure>

<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tab_with_index where id = 2 for update;</span><br></pre></td></tr></table></figure>

<p>由这个例子可以看出，对于id是主键索引的情况下，只锁了id&#x3D;1这一行记录。其余的行都是可以进行DML操作的，但前提条件是以id为条件。如果是以b字段为条件，那么还是会锁的。</p>
<h2 id="场景6：RC-无索引"><a href="#场景6：RC-无索引" class="headerlink" title="场景6：RC + 无索引"></a>场景6：RC + 无索引</h2><p>上面演示了在RR隔离级别下，对于where条件无索引的情况下，InnoDB是对所有记录加Next-key Locks。</p>
<p>但是在RC隔离级别下，对于where条件无索引的情况下，则不会对所有记录加锁，而是只对命中的数据的聚簇索引加X锁。</p>
<p>同样针对tab_no_index&#96;&#96;表，开启事务1，保持未提交的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">delete from tab_no_index where id = 1;</span><br></pre></td></tr></table></figure>

<p>执行下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from tab_no_index where id = 99;</span><br><span class="line">update tab_no_index set id=2 where id=100;</span><br><span class="line">insert into tab_no_index select 99,99;</span><br></pre></td></tr></table></figure>

<p>都可以执行成功。</p>
<h2 id="沙场练兵"><a href="#沙场练兵" class="headerlink" title="沙场练兵"></a>沙场练兵</h2><p>有了上面的分场景演习，下面就两条简单SQL进行一场加锁分析的实战。</p>
<p>下面两条简单的SQL，加什么锁？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t1 where id = 10;</span><br><span class="line">delete from t1 where id = 10;</span><br></pre></td></tr></table></figure>

<p>一眼看去，不经大脑的回答是：</p>
<ul>
<li>SQL1：不加锁。因为MySQL是使用多版本并发控制的，读不加锁</li>
<li>SQL2：对id &#x3D; 10的记录加写锁 (走主键索引)</li>
</ul>
<p>可能是正确的，也有可能是错误的，已知条件不足，要回答这个问题，还缺少几个前提条件：</p>
<ul>
<li>id列是不是主键？</li>
<li>当前系统的隔离级别是什么？</li>
<li>id列如果不是主键，那么id列上有索引吗？</li>
<li>id列上如果有二级索引，那么这个索引是唯一索引吗？</li>
</ul>
<p><strong>组合一：id列是主键，RC隔离级别</strong></p>
<p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：<code>delete from t1 where id = 10;</code> 只需要将主键上，id &#x3D; 10的记录加上X锁即可。</p>
<p><a href="https://imgtu.com/i/jJJTYj"><img src="https://s1.ax1x.com/2022/07/04/jJJTYj.jpg" alt="jJJTYj.jpg"></a></p>
<p><strong>组合二：id唯一索引+RC</strong></p>
<p>id是unique索引，而主键是name列。由于id是unique索引，因此delete语句会选择id列的索引进行where条件的过滤，在找到id&#x3D;10的记录后，首先会将unique索引上的id&#x3D;10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name &#x3D; ‘d’ 对应的主键索引项加X锁。</p>
<p>为什么聚簇索引上的记录也要加锁？如果并发的一个SQL，是通过主键索引来更新：<code>update t1 set id = 100 where name = ‘d’;</code> 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新&#x2F;删除需要串行执行的约束。</p>
<p>若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id &#x3D; 10的记录，另一把锁对应于聚簇索引上的[name&#x3D;’d’,id&#x3D;10]的记录。</p>
<p><a href="https://imgtu.com/i/jJJL60"><img src="https://s1.ax1x.com/2022/07/04/jJJL60.jpg" alt="jJJL60.jpg"></a></p>
<p><strong>组合三：id非唯一索引+RC</strong></p>
<p>相对于组合一、二，id列不再唯一，只有一个普通的索引。</p>
<p>满足id &#x3D; 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p>
<p><a href="https://imgtu.com/i/jJJbpn"><img src="https://s1.ax1x.com/2022/07/04/jJJbpn.jpg" alt="jJJbpn.jpg"></a></p>
<p><strong>组合四：id无索引+RC</strong></p>
<p>这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？换句话说，全表扫描时，会加什么锁？</p>
<p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p>
<p><a href="https://imgtu.com/i/jJJqlq"><img src="https://s1.ax1x.com/2022/07/04/jJJqlq.jpg" alt="jJJqlq.jpg"></a></p>
<p>为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录都锁上了。</p>
<p>在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p>
<p><strong>组合五：id主键+RR</strong></p>
<p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。</p>
<p>id列是主键列，Repeatable Read隔离级别，针对<code>delete from t1 where id = 10;</code> 这条SQL，加锁与组合一：[id主键，Read Committed]一致。</p>
<p><strong>组合六：id唯一索引+RR</strong></p>
<p>与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p>
<p><strong>组合七：id非唯一索引+RR</strong></p>
<p>RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。那么RR隔离级别下，如何防止幻读呢？</p>
<p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行<code>delete from t1 where id = 10;</code> 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？</p>
<p><a href="https://imgtu.com/i/jJJ7fs"><img src="https://s1.ax1x.com/2022/07/04/jJJ7fs.jpg" alt="jJJ7fs.jpg"></a></p>
<p>相对于组合三：[id列上非唯一锁，Read Committed]看似相同，其实却有很大的区别。</p>
<p>最大的区别在于，多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，是加载两条记录之间的位置，GAP锁有何用？</p>
<p><strong>这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键</strong>。</p>
<p>GAP锁锁住的位置，不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读(例如：<code>select * from t1 where id = 10 for update;</code>)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p>
<p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p>
<p>如图中所示，有哪些位置可以插入新的满足条件的项 (id &#x3D; 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id&#x3D;10的记录；[6,c]与[10,b]间、[10,b]与[10,d]间、[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。</p>
<p>因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p>
<p>Insert操作，如insert [10,a]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id&#x3D;10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p>
<p>既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？ GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。</p>
<p>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：<code>delete from t1 where id = 10;</code>首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p>
<p><strong>组合八：id无索引+RR</strong></p>
<p>id列上没有索引。此时SQL：<code>delete from t1 where id = 10;</code>没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p>
<p><a href="https://imgtu.com/i/jJJOXV"><img src="https://s1.ax1x.com/2022/07/04/jJJOXV.jpg" alt="jJJOXV.jpg"></a></p>
<p>这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p>
<p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p>
<p>当然，跟组合四：[id无索引, Read Committed]类似，这个情况下，MySQL也做了一些优化，就是所谓的<code>semi-consistent read</code>。<code>semi-consistent read</code>开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。</p>
<p>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新&#x2F;删除&#x2F;插入 操作。当然，也可以通过触发<code>semi-consistent read</code>，来缓解加锁开销与并发影响，但是<code>semi-consistent read</code>本身可能会带来其他问题。</p>
<p><strong>组合九：Serializable</strong></p>
<p>Serializable隔离级别。对于SQL2：<code>delete from t1 where id = 10;</code> 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致</p>
<p>Serializable隔离级别，影响的是SQL1：<code>select * from t1 where id = 10;</code>这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p>
<p>MVCC 最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC</p>
<p>在MySQL&#x2F;InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL锁进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>服务网格总结</title>
    <url>/2022/06/06/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>前言：</p>
<p>本文为CSDN博主「小魏的博客」的原创文章，本篇仅供学习使用，尊重原创</p>
<p>原文链接：<a href="https://blog.csdn.net/w2009211777/article/details/123840631">https://blog.csdn.net/w2009211777/article/details/123840631</a></p>
<hr>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>服务网格（Service <a href="https://so.csdn.net/so/search?q=Mesh&spm=1001.2101.3001.7020">Mesh</a>）是一个专门处理服务通讯的基础设施层。它的职责是在由云原生应用组成服务的复杂拓扑结构下进行可靠的请求传送。<strong>在实践中，它是一组和应用服务部署在一起的轻量级的网络代理</strong>，并且对应用服务透明。</p>
<p>服务网格从总体<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">架构</a>上来讲比较简单，不过是一堆紧挨着各项服务的<strong>用户代理</strong>，外加一组<strong>任务管理组件</strong>组成。</p>
<p>管理组件被称为控制层或<strong>控制平面</strong>（control plane），负责与控制平面中的代理通信，下发策略和配置。</p>
<p>代理在服务网格中被称为数据层或数据平面（data plane），直接处理入站和出站数据包，转发、路由、健康检查、负载均衡、认证、鉴权、产生监控数据等。</p>
<p>一个典型的服务网格部署网络结构图如下：</p>
<p><a href="https://imgtu.com/i/jYhAaD"><img src="https://s1.ax1x.com/2022/07/05/jYhAaD.jpg" alt="jYhAaD.jpg"></a></p>
<p>其中绿色方块为应用服务，蓝色方块为 Sidecar Proxy，应用服务之间通过 Sidecar Proxy 进行通信，整个服务通信形成图中的蓝色网络连线，图中所有蓝色部分就形成了 Service Mesh。</p>
<h1 id="服务网格带来了什么变化？"><a href="#服务网格带来了什么变化？" class="headerlink" title="服务网格带来了什么变化？"></a>服务网格带来了什么变化？</h1><ul>
<li><strong>第一，微服务治理与业务逻辑的解耦。</strong>服务网格把 SDK 中的大部分能力从应用中剥离出来，拆解为独立进程，以 sidecar 的模式进行部署。服务网格通过将服务通信及相关管控功能从业务程序中分离并下沉到基础设施层，使其和业务系统完全解耦，使开发人员更加专注于业务本身。</li>
<li><strong>第二，异构系统的统一治理。</strong>随着新技术的发展和人员更替，在同一家公司中往往会出现不同语言、不同框架的应用和服务，为了能够统一管控这些服务，以往的做法是为每种语言、每种框架都开发一套完整的 SDK，维护成本非常之高，而且给公司的中间件团队带来了很大的挑战。有了服务网格之后，通过将主体的服务治理能力下沉到基础设施，多语言的支持就轻松很多了。只需要提供一个非常轻量级的 SDK，甚至很多情况下都不需要一个单独的 SDK，就可以方便地实现多语言、多协议的统一流量管控、监控等需求。</li>
</ul>
<h1 id="Istio介绍"><a href="#Istio介绍" class="headerlink" title="Istio介绍"></a>Istio介绍</h1><p>Istio - 服务网格的典型实现。</p>
<p>Istio 是一个由Google和IBM等公司开源的，功能十分丰富的服务网格具体实现，也是目前业界最为流行的实现。它包括如下功能：</p>
<ul>
<li>流量管理：提供统一的流量治理功能，包括失败重试、超时、熔断&#x2F;限流、路由管理、灰度发布、网关等功能。</li>
<li>可观测性：透明化地实现指标监控、日志、链路追踪等功能。</li>
<li>策略控制：实现访问控制系统、遥测捕获、配额管理和计费等。</li>
<li>安全认证：无侵入式地为服务增加认证、鉴权和加密通信的能力。</li>
<li>故障注入：支持随机向服务通信中注入故障（如模拟延时&#x2F;网络中断），检测服务的可靠性</li>
</ul>
<h1 id="Istio架构"><a href="#Istio架构" class="headerlink" title="Istio架构"></a>Istio架构</h1><p>Istio 的架构从逻辑上分成数据平面（Data Plane）和控制平面（Control Plane）。</p>
<p>是否觉得似曾相识？没错，Kubernetes 的架构也具有相似的结构，分为控制节点和计算节点。毫无疑问，这样的设计可以很好地解耦各个功能组件。</p>
<ul>
<li>数据平面：由一组和业务服务成对出现的 Sidecar 代理（Envoy）构成，它的主要功能是接管服务的进出流量，传递并控制服务和 Mixer 组件的所有网络通信（Mixer 是一个策略和遥测数据的收集器，稍后会介绍）。</li>
<li>控制平面：主要包括了 Pilot、Mixer、Citadel 和 Galley 共 4 个组件，主要功能是通过配置和管理 Sidecar 代理来进行流量控制，并配置 Mixer 去执行策略和收集遥测数据（Telemetry）。</li>
</ul>
<p>Istio的架构图如下：</p>
<p><a href="https://imgtu.com/i/jYhZPH"><img src="https://s1.ax1x.com/2022/07/05/jYhZPH.jpg" alt="jYhZPH.jpg"></a></p>
<p>架构补充：</p>
<p><a href="https://imgtu.com/i/jYhEIe"><img src="https://s1.ax1x.com/2022/07/05/jYhEIe.jpg" alt="jYhEIe.jpg"></a></p>
<h1 id="Istio模块介绍"><a href="#Istio模块介绍" class="headerlink" title="Istio模块介绍"></a>Istio模块介绍</h1><h2 id="Istio-的核心控件Envoy"><a href="#Istio-的核心控件Envoy" class="headerlink" title="Istio 的核心控件Envoy"></a>Istio 的核心控件Envoy</h2><p>从上面的架构图可以看出，Istio 的数据平面就是指代理。Istio 选择 Envoy 作为 Sidecar 代理，Envoy 本质上是一个为面向服务的架构而设计的 7 层代理和通信总线。Envoy 基于 C++ 11 开发而成，性能出色。除了具有强大的网络控制能力外，Envoy 还可以将流量行为和数据提取出来发送给 Mixer 组件，用以进行监控。</p>
<p>Envoy 在网络控制方面的主要功能如下：</p>
<ul>
<li>HTTP 7 层路由</li>
<li>支持 gRPC、HTTP&#x2F;2</li>
<li>服务发现和动态配置</li>
<li>健康检查</li>
<li>高级负载均衡</li>
</ul>
<p>我们知道，在Kubernetes环境中，同一个Pod内的不同容器间共享网络栈，这一特性使得Sidecar可以接管进出这些容器的网络流量，这就是Sidecar模式的实现基础。Envoy是目前Istio默认的数据平面，实际上因为Istio灵活的架构，完全可以选择其他兼容的产品作为Sidecar。目前很多服务网格产品都可以作为Istio的数据平面并提供集成。</p>
<h2 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h2><p>Pilot 是 Istio 实现流量管理的核心组件，它主要的作用是配置和管理 Envoy 代理。比如：可以为代理之间设置特定的流量规则，或者配置超时、重试、熔断这样的弹性能力。Pilot 会将控制流量行为的路由规则转换为 Envoy 的配置，并在运行时将它们广播到 Envoy。另外，Pilot 还能够把服务发现机制抽象出来并转换成 API 分发给 Envoy，使得后者具有服务发现的能力。</p>
<p>简单来说，Pilot 的主要任务有两个：</p>
<ul>
<li>从平台（如：Kubernetes）获取服务信息，完成服务发现</li>
<li><strong>获取 Istio 的各项配置，转换成 Envoy 代理可读的格式并分发</strong><ul>
<li><strong>注意：这块是经典的解耦设计，这样有个好处，即以后如果有其他类型的配置格式，也可以转换为Envoy可读的配置。试想下，如果由Envoy直接读取配置，后期接入其他格式的配置则需要修改Envoy代码，而Pilot的出现，则只要修改Pilot端代码就可以了。Pilot层不涉及到业务逻辑层，而是作为一个平台适配器，保障了其他核心组件配置规则的一致性，从而避免其它代码的反复修改。</strong></li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/jYhiqK"><img src="https://s1.ax1x.com/2022/07/05/jYhiqK.jpg" alt="jYhiqK.jpg"></a></p>
<h2 id="Mixer"><a href="#Mixer" class="headerlink" title="Mixer"></a>Mixer</h2><p>Mixer 的主要功能是提供策略控制，并从 Envoy 代理收集遥测数据。</p>
<p>每次网络通信时 Envoy 代理都会向 Mixer 发出预检要求，用来检测调用者的合法性。调用之后 Envoy 代理会发送遥测数据供 Mixer 收集。一般情况下 Sidecar 代理可以缓存这些数据，不需要频繁地调用 Mixer。</p>
<p>适配器是 Mixer 的重要组成部分，它本质上是一个插件模型，每个插件叫作适配器。这项特性使得 Mixer 可以接入几乎任意的（只要定义好接口）后端基础设施。比如可以选择接入不同的日志收集器、监控工具和授权工具等；可以在运行时切换不同的适配器或者是打开（关闭）它们；还可以自定义适配器以满足特定需求。适配器极大地提高了 Mixer 的扩展性，它让 Istio 的功能拥有了更多可能性。下图展示了 Mixer 的架构图并展示了它和 Envoy 的交互方式。</p>
<p><a href="https://imgtu.com/i/jYhkVO"><img src="https://s1.ax1x.com/2022/07/05/jYhkVO.jpg" alt="jYhkVO.jpg"></a></p>
<h2 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h2><p>Citadel 是与安全相关的组件，主要负责密钥和证书的管理。它可以提供服务间和终端用户的身份认证，还可以加密服务网格中的流量。</p>
<h2 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h2><p>在 2019 年 3 月份发布的 1.1 版本中，Galley 作为一个独立的组件被添加到了架构当中（在此之前的版本中 Galley 并未独立出现），它现在是 Istio 主要的配置管理组件，负责配置的获取、处理和分发。Galley 使用了一种叫作 MCP（Mesh Configuration Protocol，网格配置协议）的协议与其他组件进行通信。</p>
<h1 id="Istio之流量管理"><a href="#Istio之流量管理" class="headerlink" title="Istio之流量管理"></a>Istio之流量管理</h1><p>微服务应用最大的痛点就是处理服务间的通信，而这一问题的核心其实就是流量管理。首先来看一看传统的微服务应用在没有服务网格介入的情况下，如何完成诸如金丝雀发布这样的动态路由。假设不借助任何现成的第三方框架，一个简单的实现方法是，在服务间添加一个负载均衡（如Nginx）做代理，通过修改配置的权重来分配流量。这种方式将对流量的管理和基础设施（云服务器、虚拟机、实体机等）绑定在了一起，难以维护。</p>
<p>而使用 Istio 就可以轻松地实现各种维度的流量控制。</p>
<p>下图展示了两种不同的金丝雀发布策略（新版本只对少数终端用户可用）。</p>
<p>第一种是根据权重把 5% 的流量路由给新版本；</p>
<p>第二种是根据请求的头信息 User-Agent 把使用 iPhone 的用户流量路由到新版本。</p>
<p>插曲：什么是金丝雀版本?金丝雀canary版本是一种软件技术版本，通过使新版本只对少数终端用户可用，这样可降低向每个人推出新代码和功能的风险。由于用户组的规模较小，新版本的影响相对较小。如果确定bug存在，或者新的功能或新的设计没有被很好地接受，那么很容易回滚。</p>
<p><a href="https://imgtu.com/i/jYheGd"><img src="https://s1.ax1x.com/2022/07/05/jYheGd.jpg" alt="jYheGd.jpg"></a></p>
<p>Istio 的流量管理是通过 Pilot 和 Envoy 这两个组件实现的，将流量和基础设施进行了解耦。Pilot 负责配置规则，并把规则分发到 Envoy 代理去实施；而 Envoy 按照规则执行各种流量管理的功能，比如动态请求路由，超时、重试和熔断，还可以通过故障注入来测试服务之间的容错能力。下面对这些具体的功能进行逐一介绍。</p>
<h2 id="1、请求路由"><a href="#1、请求路由" class="headerlink" title="1、请求路由"></a>1、请求路由</h2><p>Istio 为了控制服务请求，引入了服务版本（Version）的概念，可以通过版本这一标签将服务进行区分。版本的设置是非常灵活的，可以根据服务的迭代编号进行定义（如 v1、v2 版本）；也可以根据部署环境进行定义（如 Dev、Staging 和 Production）；或者是自定义任何用于区分服务的标记。通过版本标签，Istio 就可以定义灵活的路由规则以控制流量，上面提到的金丝雀发布这类应用场景就很容易实现了。</p>
<p>下图展示了使用服务版本实现路由分配的例子。服务版本定义了版本号（v1.5、v2.0-alpha）和环境（us-prod、us-staging）两种信息。服务 B 包含了 4 个Pod，其中 3 个是部署在生产环境的 v1.5 版本，而 Pod4 是部署在预生产环境的 v2.0-alpha 版本。运维人员根据服务版本指定路由规则，通过 Pilot 同步给 Envoy 代理，使得 99% 的流量流向 v1.5 版本的生产环境，而 1% 的流量进入 v2.0-alpha 版本的预生产环境。</p>
<p><a href="https://imgtu.com/i/jYhmRA"><img src="https://s1.ax1x.com/2022/07/05/jYhmRA.jpg" alt="jYhmRA.jpg"></a></p>
<h2 id="2、入口网关（Ingress）和出口网关（Egress）"><a href="#2、入口网关（Ingress）和出口网关（Egress）" class="headerlink" title="2、入口网关（Ingress）和出口网关（Egress）"></a>2、入口网关（Ingress）和出口网关（Egress）</h2><p>服务间通信是通过 Envoy 代理进行的。同样，我们也可以在整个系统的入口和出口处部署代理，使得所有流入和流出的流量都由代理进行转发，而这两个负责入口和出口的代理就叫作入口网关和出口网关。它们相当于整个微服务应用的边界代理，把守着进入和流出服务网格的流量。下图展示了 Ingress 和 Egress 在请求流中的位置，通过设置 Envoy 代理，出入服务网格的流量也得到了控制。</p>
<p><a href="https://imgtu.com/i/jYhnxI"><img src="https://s1.ax1x.com/2022/07/05/jYhnxI.jpg" alt="jYhnxI.jpg"></a></p>
<h2 id="3、服务发现和负载均衡"><a href="#3、服务发现和负载均衡" class="headerlink" title="3、服务发现和负载均衡"></a>3、服务发现和负载均衡</h2><p>服务发现的前提条件是具有服务注册的能力。目前 Kubernetes 这类容器编排平台也提供了服务注册的能力。Istio 基于平台实现服务发现和负载均衡时，需要通过 Pilot 和 Envoy 协作完成，如下图所示。Pilot 组件会从平台获取服务的注册信息，并提供服务发现的接口，Envoy 获得这些信息并更新到自己的负载均衡池。Envoy 会定期地对池中的实例进行健康检查，剔除离线的实例，保证服务信息的实时性。</p>
<p><a href="https://imgtu.com/i/jYhKMt"><img src="https://s1.ax1x.com/2022/07/05/jYhKMt.jpg" alt="jYhKMt.jpg"></a></p>
<h1 id="Istio之故障处理"><a href="#Istio之故障处理" class="headerlink" title="Istio之故障处理"></a>Istio之故障处理</h1><p>Istio 的故障处理都由 Envoy 代理完成。Envoy 提供了一整套现成的故障处理机制，比如超时、重试、限流和熔断等。这些功能都能够以规则的形式进行动态配置，并且执行运行时修改。这使得服务具有更好的容错能力和弹性，并保证服务的稳定性。</p>
<h1 id="Istio之故障注入"><a href="#Istio之故障注入" class="headerlink" title="Istio之故障注入"></a>Istio之故障注入</h1><p>简单来说，故障注入就是在系统中人为地设置一些故障，来测试系统的稳定性和系统恢复的能力。</p>
<p>比如为某服务设置一个延迟，使其长时间无响应，然后检测调用方是否能处理这种超时问题而自身不受影响（如及时终止对故障发生方的调用，避免自己受到影响且使故障扩展）。</p>
<p>故障注入怎么实现的？也很简单，比如延迟，不是真的去让服务组件故障延迟，而是在获取到服务组件的数据之后，在Envoy端进行延迟。</p>
<p>Isito 支持注入两种类型的故障：<strong>延迟和中断。</strong></p>
<p>延迟是模拟网络延迟或服务过载的情况；</p>
<p>中断是模拟上游服务崩溃的情况，表现为 HTTP 的错误码和 TCP 连接失败。</p>
<h1 id="策略和遥测"><a href="#策略和遥测" class="headerlink" title="策略和遥测"></a>策略和遥测</h1><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>在微服务应用中，除了流量管理以外，常常还需要进行一些额外的控制，比如限流（对调用频率、速率进行限制）、设置白名单和黑名单等。</p>
<p>Istio 中的策略控制是依靠 Mixer 完成的。Envoy 代理在每次网络请求时，都会调用 Mixer 进行预先检查，确定是否满足对应的策略。同时，Mixer 又可以根据这些来自流量的数据，进行指标数据的采集和汇总，这就是遥测功能。</p>
<h2 id="遥测（Telemetry）"><a href="#遥测（Telemetry）" class="headerlink" title="遥测（Telemetry）"></a>遥测（Telemetry）</h2><p>遥测是工业上常用的一种技术，它是指从远程设备中收集数据，并传输到接收设备进行监测。在软件开发中，遥测的含义引申为对各种指标（metric）数据进行收集，并监控、分析这些指标，比如我们经常听到的 BI 数据分析。</p>
<p>Mixer 的一大主要功能就是遥测。前面已经说过，Envoy 代理会发送数据给 Mixer，这就使得 Mixer 具有了数据收集的能力。在对 Mixer 的介绍中读者已经了解到 Mixer 的插件模型，也就是适配器。Mixer 可以接入不同的后端设施作为适配器，来处理收集到的指标数据，比如：日志分析系统、监控系统等。</p>
<h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p>在微服务应用越来越复杂的情况下，对整个系统的状态进行监控和追踪变得尤为重要。试想如果一个包含上百个服务的系统发生了故障却无法准确定位问题的根源，或者系统压力已经到了承受的临界值而运维人员却浑然不知，这是多么可怕的事情。没有完备的、可观察的监控系统就无法保障系统的稳定性。</p>
<p>Istio 可以很方便地和各种监控、追踪工具集成，以便我们以可视化的方式（网页）直观地查看整个系统的运行状态。比如：可以集成 Prometheus 来进行指标数据的收集，然后将收集的数据放在 Grafana 监控工具中展示；还可以集成 Jaeger 作为追踪系统，帮助我们对请求的调用链进行跟踪，在故障发生时分析出现问题的根源；或者将请求日志记录到 Kibana 系统，以图表的方式进行数据分析。</p>
<p>以上提到的这些可视化工具都会在集成到 Istio 中得到详细的介绍。</p>
<h1 id="VirtualService路由规则配置"><a href="#VirtualService路由规则配置" class="headerlink" title="VirtualService路由规则配置"></a>VirtualService路由规则配置</h1><p>virtualService是istio最主要最复杂的核心配置，主要负责配置服务的调用规则，分发规则等等，在详细介绍vs功能之前，可以先查看以下的简化配置内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">end-user:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>

<p>metadata_name： vs的名称</p>
<p>spec_hosts：对应服务的service名称</p>
<p>spec_http_match：路由规则<br>上面表达式的内容解说过来为：对reviews服务的访问请求中，如果请求头的end-user的值为jason，则将流量路由到reviews服务的v2版本上，其他流量路由在v1版</p>
<h2 id="vs配置中的关键配置项"><a href="#vs配置中的关键配置项" class="headerlink" title="vs配置中的关键配置项:"></a>vs配置中的关键配置项:</h2><ol>
<li><p>hosts：表示流量发送的目标（可以理解为拦截目标，也可以理解为配置的路由规则归属哪一个Sidecar），在k8s中hosts需要配置为服务的service域名，同namesapce下可以配置 <strong>短域名</strong>（因为可以跨namespace配置路由规则，所以这里是不便于管理的，如果重新开发istio配置管理dashboard可以考虑为域名分配增加权限）</p>
</li>
<li><p>http: 是一个类似httpRoute的路由集合，用于处理http的流量，是istio最丰富的的流量规则</p>
</li>
<li><p>tls：是一个tlsRoute类型的路由集合，用于处理非终结的tls和https流量</p>
</li>
<li><p>tcp：是一个tcpRoute类型的路由集合，用于处理tcp流量，应用于所有非http和tls端口的流量</p>
</li>
<li><p>exportTo：是istio在1.1版本后的新增特性，用于控制VS跨namespace的可见性。可以控制在一个命名空间下定义的vs是否可以被其他命名空间的Sidecar和Gateway使用。不填写代表全局可见，”.“代表仅当前namespace可见，”* “代表所有namespace可见。</p>
</li>
</ol>
<h2 id="HttpRoute"><a href="#HttpRoute" class="headerlink" title="HttpRoute"></a>HttpRoute</h2><p>在正常使用时，http协议的路由应用场景最多，主要介绍一下http路由的使用场景和使用方法</p>
<p><a href="https://imgtu.com/i/jUMKPA"><img src="https://s1.ax1x.com/2022/07/06/jUMKPA.jpg" alt="jUMKPA.jpg"></a></p>
<p>如上图，httproute可以通过请求中的内容为条件，对请求进行重定向、重写、重试、故障注入、流量复制等操作<br>我们把这些步骤拆分一下，主要分为匹配规则，重定向，重写，重试，故障注入，流量复制这几个方面来详述。</p>
<h2 id="HTTPRoute的匹配规则"><a href="#HTTPRoute的匹配规则" class="headerlink" title="HTTPRoute的匹配规则"></a>HTTPRoute的匹配规则</h2><p>简述：匹配规则是分发流量的重要条件，关键字段是match字段，在match字段下就是对请求路由的匹配方式。</p>
<p><a href="https://imgtu.com/i/jUMn5d"><img src="https://s1.ax1x.com/2022/07/06/jUMn5d.jpg" alt="jUMn5d.jpg"></a></p>
<p>uri、scheme、method、authority：这4个字段都是StringMatch类型，请求规则中都支持exact（完全匹配），prefix（前缀匹配）、regex（正则匹配）三种匹配方式<br>headers：匹配请求中的header，是一个map类型，所以匹配时以k-v的形式比对，对每一个header的值都可以使用exact，prefix、regex三种匹配方式。<br>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">match:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span> </span><br><span class="line">        <span class="attr">end-user:</span> </span><br><span class="line">            <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">&quot;/testPipeline&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上规则中包含了1和2的使用方式，代表匹配请求头中的end-user的值为jason且uri以&#x2F;testPipeline开头的请求。</p>
<p>注意，条件或怎么写？如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">match:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span> </span><br><span class="line">        <span class="attr">end-user:</span> </span><br><span class="line">            <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">&quot;/testPipeline&quot;</span></span><br></pre></td></tr></table></figure>



<p>port：表示请求的端口，在使用时大部分的服务都只开放了一个端口，在这种场景下可以不用指定端口（port在实际使用中使用率会小些）<br><strong>sourceLabels：表示请求来源服务的标签，在k8s中这个标签就是指pod的标签。</strong><br>例：<br>http:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sourceLabels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">cicdfront</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1.0.10</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">cicdapi</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1.0.10</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">cicdapi</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1.0.9</span></span><br></pre></td></tr></table></figure>

<p><strong>当请求服务来源为cicdfront且其pod版本为v1.0.10时会将流量转发到cicdapi的v1.0.10上，其他的请求会发送到cicdapi的v1.0.9版本上</strong></p>
<h2 id="HttpRoute的路由目标"><a href="#HttpRoute的路由目标" class="headerlink" title="HttpRoute的路由目标"></a>HttpRoute的路由目标</h2><p>简述：路由目标代表请求流量发送到的目标服务，<strong>关键字段是route</strong>，在match（匹配规则）下时常代表匹配规则后的发送请求的目标服务。<br>当请求完成匹配规则后，我们需要对匹配到的请求进行转发，我们还是以开始的配置举例(稍微改动一下)。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">end-user:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">     <span class="attr">weight:</span> <span class="number">30</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br><span class="line">     <span class="attr">weight:</span> <span class="number">70</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>

<p><strong>通过上节的匹配规则我们可以理解match中的匹配规则为请求头中的end-user的值为jason。当匹配这一条件时route路由生效，将请求的30%发送到reviews服务的v2版本上，另外70%发送到reviews服务的v3版本上。对未能匹配的请求路由到v1版本上。</strong></p>
<p>这一转发需要搭配istio的另一个重要配置DR（DestinationRule）使用，DR中通过标签定义不同的pod服务。通过subset子集来完成请求的调用，这里按reviews服务的v1 v2两个pod理解就好:</p>
<ul>
<li><strong>destination中的host与http中的host一致，在k8s中也是指向的service的域名</strong>，可以省略部分内容做短域名（在同namespace下的时候）。subset代表对应的dr子集。</li>
<li><strong>weight：除了destination之外的另一个重要属性主要用于流量分配的比例，在一个route下多个dr下流量权重之和必须为100</strong></li>
</ul>
<h2 id="HTTPRedirect重定向"><a href="#HTTPRedirect重定向" class="headerlink" title="HTTPRedirect重定向"></a>HTTPRedirect重定向</h2><p>简述：istio可以人工注入一些不可见的重定向规则，<strong>自定义的重定向规则在redirect关键字下。</strong><br>理解了istio的vs工作模式那么我们接下来继续看istio的重定向功能。</p>
<p>比较常见的使用场景：网站系统的网站地址发生了变化（并非服务器变化，只是访问地址的请求后缀变化），<strong>要求使用之前的访问地址也能够进入网站，不影响旧用户的操作</strong>。这种情况下就很适合使用istio的重定向功能</p>
<ul>
<li>uri：替换url中的path部分</li>
<li>authority：替换url中的authority部分</li>
</ul>
<p>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicdapi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cicdapi</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/pipeline</span></span><br><span class="line">      <span class="attr">redirect:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">/cicd/pipeline</span></span><br><span class="line">        <span class="attr">authority:</span> <span class="string">newcicd</span></span><br></pre></td></tr></table></figure>


<p>以上的请求对cicdapi服务的&#x2F;pipeline请求都会被重定向到newcicd服务的&#x2F;cicd&#x2F;pipeline上</p>
<h2 id="HTTPRewrite重写"><a href="#HTTPRewrite重写" class="headerlink" title="HTTPRewrite重写"></a>HTTPRewrite重写</h2><p>简述：istio可以在请求发送给目标服务之前对请求信息进行改写，这个改写过程是对客户端及服务端都不可见的。重写与重定向很像。<br>关键字：rewrite</p>
<ol>
<li>uri: 重写url中的path部分</li>
<li>authority: 重写url中的authority部分</li>
</ol>
<p>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicdapi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cicdapi</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/pipeline</span></span><br><span class="line">      <span class="attr">rewrite:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">/cicd/pipeline</span></span><br></pre></td></tr></table></figure>

<h2 id="HTTPRerty重试"><a href="#HTTPRerty重试" class="headerlink" title="HTTPRerty重试"></a>HTTPRerty重试</h2><p>简述：很多时候http请求发生异常，重试都是解决异常的最直接，最简单的办法，尤其是环境比较复杂的情况下，可以提高总体的服务质量，<strong>但是这个重试逻辑如果放在客户端进行调度就过于不规范，不便于管理</strong>。istio可以支持这种重试的自动调度。<br>关键字：retry</p>
<ol>
<li>attempts：必填字段，定义重试的次数</li>
<li>perTryTimeout：每次重试的超时时间，单位可以是毫秒(ms)，秒(s)，分钟(m)和小时(h)</li>
<li>retryOn: 重试的条件，可以是多个条件以逗号分隔。可用条件有以下内容</li>
</ol>
<ul>
<li>（1）5xx：在上游服务返回5xx的返回码，或在没有响应的时候进行重试</li>
<li>（2）gateway-error：类似5xx异常，只对502,503,504的路由异常进行重试</li>
<li>（3）connect-failure：在连接上游服务失败时重试</li>
<li>（4）retriable-4xx：在上游服务返回4xx返回码时进行重试（这里可能不包括部分返回码，如404,405）</li>
<li>（5）refused-stream：在上游服务使用REFUSED_STREAM错误码重置时重试</li>
<li>（6）cancelled：在gRPC应答的Header中状态码是cancelled时重试</li>
<li>（7）deadline-exceeded：在gRPC应答的Header中的状态码是deadline-exceeded时重试</li>
<li>（8）internal：在gRPC应答的Header中的状态码是internal时重试</li>
<li>（9）resource-exhausted：在gRPC应答的Header中的状态码是resource-exhausted时重试</li>
<li>（10）unavailable：在gRPC应答的Header中的状态码是unavailable时重试</li>
</ul>
<p>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicdapi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cicdapi</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">cicdapi</span></span><br><span class="line">     <span class="attr">retries:</span></span><br><span class="line">       <span class="attr">attempts:</span> <span class="number">5</span></span><br><span class="line">       <span class="attr">perTryTimeout:</span> <span class="string">3s</span></span><br><span class="line">       <span class="attr">retryOn:</span> <span class="string">5xx,connect-failure</span></span><br></pre></td></tr></table></figure>

<h2 id="Mirror流量复制"><a href="#Mirror流量复制" class="headerlink" title="Mirror流量复制"></a>Mirror流量复制</h2><p>简述：<strong>流量复制是指在流量需要发送到某个服务时，将这个请求流量复制一份到一个指定的服务上</strong>，如下图。可以将生产系统的流量复制到一个需要更新的新版本服务上，这样完全不会对生产系统产生影响，这里只复制了一份流量，数据面代理只需要住原来的流量就可以了。<br>关键字：mirror</p>
<p><a href="https://imgtu.com/i/jUMM8I"><img src="https://s1.ax1x.com/2022/07/06/jUMM8I.jpg" alt="jUMM8I.jpg"></a></p>
<p>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">portal-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">portal-web</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">portal-web</span></span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v1.0.15</span></span><br><span class="line">      <span class="attr">mirror:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">portal-web</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1.0.16</span></span><br></pre></td></tr></table></figure>

<h2 id="HttpFaultInjection故障注入"><a href="#HttpFaultInjection故障注入" class="headerlink" title="HttpFaultInjection故障注入"></a>HttpFaultInjection故障注入</h2><p>简述：除了转发重试这些常用的http请求操作，istio还支持故障注入。主要用于测试时<strong>主动模拟一些异常场景</strong>，比如跨服务请求超时，访问中发生错误等情况。</p>
<p><strong>这个作用主要是观察微服务中，某个服务处故障时，整体服务的健康状况，观察是否会出现级联影响的情况。</strong></p>
<p>在istio中故障注入主要分为两种</p>
<p>延迟故障注入</p>
<p>延迟故障注入用来模拟超时的场景，模拟网络负载等原因导致的请求失败</p>
<p>配置参数如下：<br>（1）fixedDelay：必选字段，表示延迟的时间，单位可以是毫秒，秒，分钟，小时。要求时间必须大于1毫秒</p>
<p>（2）percentage：选填字段，配置故障发生的比例，通过这个配置可以配置故障发生的比例（无单位，支持小数，表示百分比。如果不填默认为100，注入所有请求）。</p>
<p>例：<br>……</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">portal-web</span></span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v1.0.15</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">fault：</span></span><br><span class="line">    <span class="string">delay：</span></span><br><span class="line">       <span class="string">percentage：</span></span><br><span class="line">         <span class="attr">value:</span> <span class="number">1.5</span></span><br><span class="line">       <span class="attr">fixedDelay:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure>



<p>表示对portal-web服务的请求的百分之1.5会被注入10s的延迟</p>
<p>请求中止故障注入</p>
<p>请求中止故障注入，主要是为了模拟服务端故障的情况，可以注入指定的返回码和返回信息</p>
<p>配置参数如下：<br>（1）httpStatus：是一个必选字段，表示中止的HTTP状态码</p>
<p>（2）percentage：配置的中止故障作用在多少比例的请求上，配置方式与延迟故障的一致。<br>例：<br>……</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">portal-web</span></span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v1.0.15</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">fault：</span></span><br><span class="line">    <span class="string">delay：</span></span><br><span class="line">       <span class="string">percentage：</span></span><br><span class="line">         <span class="attr">value:</span> <span class="number">1.5</span></span><br><span class="line">       <span class="attr">httpStatus:</span> <span class="number">500</span></span><br></pre></td></tr></table></figure>

<p>对portal-web服务的请求的百分之1.5会被模拟返回500的异常。</p>
<p>其实当了解了vs的大部分功能之后，我们可以看到vs的作用其实与k8s的service的作用基本是一致的，只是vs是用来修饰service的服务，可以调整、组合、拼接service，将多个service拼装成一个大的，富有规则的service。</p>
<h1 id="DestinationRule目标规则"><a href="#DestinationRule目标规则" class="headerlink" title="DestinationRule目标规则"></a>DestinationRule目标规则</h1><p>在我们刚刚查看VirtualService时候经常能看到这样一段配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">portal-web</span></span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v1.0.15</span></span><br></pre></td></tr></table></figure>

<p>之前说这段配置指的是将流量发送给portal-web的v1.0.15的版本，这样说是为了方便理解。实际上这种说法是不严谨的，<strong>这段配置真实代表的含义是将请求转发给portal-web服务的destinationRule的v1.0.15的子集。</strong></p>
<p>DestinationRule配置样例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicdpai</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">cicdapi</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure>



<h2 id="DestinationRule规则定义"><a href="#DestinationRule规则定义" class="headerlink" title="DestinationRule规则定义"></a>DestinationRule规则定义</h2><p><strong>destinationRule经常与virtualService一起使用</strong>（dr是配合vs一起使用的，但是vs并不要求一定需要使用dr，如果不使用dr，vs会直接使用service来负载调用对应的pod），virtualService用来修饰满足什么条件后被哪个后端处理。而destinationRule描述的是这个请求到达某个后端后该怎么去处理。</p>
<p>简述：vs设置服务的访问规则，具体请求服务时的规则由dr来决定。</p>
<p>关键属性：</p>
<p>（1）host：必选字段，表示规则的使用对象，对应的也是k8s中的service。域名解析方式与之前的host配置一致。</p>
<p>（2）trafficPolicy：规则的内容定义，包括负载均衡，连接池策略，异常点检查等内容。</p>
<p>（3）exportTo：Istio 1.1版本后新增的特性，用于控制DestinationRule跨命名空间的可见性，这样就能控制在一个命名空间下定义的资源对象是否可以被其他命名空间下的Sidecar执行。如果不做赋值代表全命名空间都可见。支持“.” 代表当前命名空间可见。”*” 代表全命名空间可见。</p>
<p>（4）subsets：代表一个服务的子集，一般代表一个服务的版本，与vs结合使用。每个子集都是通过label来匹配对应的pod，在istio的使用要求中建议用户为每个pod分配app、version两个标签。所以subset一般以version来划分，但这并不是硬性限制。</p>
<h3 id="1-负载均衡设置"><a href="#1-负载均衡设置" class="headerlink" title="1.负载均衡设置"></a>1.负载均衡设置</h3><p>简述：当subset中可以匹配到多个pod时可以通过istio自身的负载均衡策略将请求分配。</p>
<ol>
<li>ROUND_ROBIN：轮循算法，如果设置了dr但没有为subset设置负载策略，那么会默认使用这个策略</li>
<li>LEAST_CONN：最少连接算法，算法实现的是从两个随机选择的后端服务中选择一个链接数最少的链接</li>
<li>RANDOM：完全随机策略，从现有的健康可用的后端服务中随机抽取一个地址</li>
<li>PASSTHROUGH：直接转发到客户端链接的目标地址，不做转发（这样会有k8s的service进行负载）</li>
</ol>
<h3 id="2-连接池设置"><a href="#2-连接池设置" class="headerlink" title="2.连接池设置"></a>2.连接池设置</h3><p>简述：通过连接池管理可以配置阈值来放置一个服务的失败影响到整个应用。istio的连接池可以配置tcp流量、http流量治理</p>
<p>tcp连接池配置（TCPSetting）：</p>
<p>（1）maxConnections：表示为上有服务的所有实例的最大连接数，默认为1024.对于HTTP只适用于HTTP&#x2F;1.1因为HTTP&#x2F;2对每个主机都使用单个连接。</p>
<p>（2）connectTimeout：TCP连接超时时间。</p>
<p>（3）tcpKeeplive：是Istio1.1版本后新增的特性，定期给对端发送一个keepalive的探测包，判断连接是否可用。包含三个属性–probes（标识有多少次探测没有反应就判断连接断开，默认使用操作系统的默认配置，linux默认为9），time（标识发送探测前连接空闲了多少时间，也是用操作系统的默认配置，linux默认为2小时），interval（探测间隔，也是用操作系统的默认配置，linux默认为75秒）。</p>
<p>http连接池配置（HTTPSetting）：</p>
<p>（1）http1MaxPendingRequests：最大等待HTTP请求数，默认值为1024，只适用于HTTP&#x2F;1.1，因为HTTP&#x2F;2协议的请求在到来时会立即复用连接，不会再连接池等待</p>
<p>（2）http2MaxRequests：最大请求数，默认1024。只适用于HTTP&#x2F;2服务，因为HTTP&#x2F;1.1适用最大连接数配置maxConnections即可。</p>
<p>（3）maxRequestsPerConnection：每个连接的最大请求数。如果不配置则不作限制</p>
<p>（4）maxRetries：最大重试次数，默认为3，表示服务可以执行的最大重试次数。如果调用后端因网络抖动导致调用失败，可能会带来业务损失，一般建议配置重试，若重试成功则可以正常配置返回数据，只不过比原来响应的时间稍慢一点。但重试次数过多会对性能产生影响，尽量不要对消耗大的服务进行重试。</p>
<p>（5）idleTimeout：空闲超时，定义在多长时间内没有活动请求则关闭连接。</p>
<h3 id="3-异常实例检测设置"><a href="#3-异常实例检测设置" class="headerlink" title="3.异常实例检测设置"></a>3.异常实例检测设置</h3><p>简述：异常点检查就是定期考察被访问的服务实例的工作情况，如果连续出现访问异常，则将服务实例标记为异常并进行隔离，在一段时间内不为其分配流量，过一段时间被移除的实例会被解除移除，尝试请求，如果访问失败会进行更长实际胺的隔离，这也是istio的熔断功能。<br>参数配置：</p>
<ol>
<li>consecutiveErrors：实例被驱逐前的连续错误次数，默认为5，对于http服务返回502,503,504的返回码会认为服务异常。</li>
<li>interval：驱逐检查的时间间隔（驱逐检测的统计时间），默认为10秒，要求大于1毫秒，单位可以是时、分、毫秒</li>
<li>baseEjectionTime：最小驱逐时间。一个服务被驱逐的时间等于驱逐次数乘以最小驱逐时间。所以被驱逐的实例再被再次驱逐时会变得越来越长。时间默认为30秒，要求大于1毫秒，单位可以是时、分、毫秒。</li>
<li>maxEjectionPercent：服务的可驱逐故障实例的最大比例，默认为10%。官方不建议配置过高，过分的驱逐会影响服务的服务能力</li>
<li>minHealthPercent：最小健康比例，是istio 1.1版本后新增的特性，当负载的实例中，如果健康的实例数量低于这个比例，istio会进入恐慌模式，异常检查功能会被禁用，所有的服务不论是否是故障实例都可以接受请求。</li>
</ol>
<p>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">cicdapi</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">paas</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">host:</span> <span class="string">cicdapi</span></span><br><span class="line"> <span class="attr">trafficPolicy:</span></span><br><span class="line">   <span class="attr">connectionPool:</span></span><br><span class="line">     <span class="attr">tcp:</span></span><br><span class="line">       <span class="attr">maxConnections:</span> <span class="number">80</span></span><br><span class="line">       <span class="attr">connectTimeout:</span> <span class="string">25ms</span></span><br><span class="line">     <span class="attr">http:</span></span><br><span class="line">       <span class="attr">http2MaxRequest:</span> <span class="number">800</span></span><br><span class="line">       <span class="attr">maxRequestsPerConnection:</span> <span class="number">10</span></span><br><span class="line">   <span class="attr">outlierDetection:</span></span><br><span class="line">     <span class="attr">consecutiveErrors:</span> <span class="number">5</span></span><br><span class="line">     <span class="attr">interval:</span> <span class="string">4m</span></span><br><span class="line">     <span class="attr">baseEjectionTime:</span> <span class="string">10m</span></span><br><span class="line">     <span class="attr">maxEjectionPercent:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>检查4分钟内cicdapi服务的异常情况，连续出现5次连接异常的服务实例会被隔离10分钟，被隔离的服务数量不能超过30%。达到十分钟后实例会重新接受请求，如果依然不能正常工作会被隔离20分钟</p>
<h3 id="4-端口策略"><a href="#4-端口策略" class="headerlink" title="4.端口策略"></a>4.端口策略</h3><p>简述：当我们熟悉以上的连接池配置后，实际端口配置也没有什么特殊的地方，实际上就是为了某些端口配置一些特殊规则，比如最大连接数等</p>
<p>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">cicdapi</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">paas</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">host:</span> <span class="string">cicdapi</span></span><br><span class="line"> <span class="attr">trafficPolicy:</span></span><br><span class="line">   <span class="attr">connectionPool:</span></span><br><span class="line">     <span class="attr">tcp:</span></span><br><span class="line">       <span class="attr">maxConnections:</span> <span class="number">80</span></span><br><span class="line">   <span class="attr">portLevelSettings:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">port:</span> </span><br><span class="line">       <span class="attr">number:</span> <span class="number">8081</span></span><br><span class="line">     <span class="attr">connectionPool:</span></span><br><span class="line">       <span class="attr">tcp:</span></span><br><span class="line">         <span class="attr">maxConnections:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>cicd服务的最大连接数为80，但8081端口单独配置了最大连接数为100</p>
<h3 id="5-服务子集"><a href="#5-服务子集" class="headerlink" title="5.服务子集"></a>5.服务子集</h3><p>简述：subset主要作用就是通过label标签配置真实的后端服务。virtualService中通过制定subset的name来引用对应的服务。</p>
<p>name：必选字段，subset的名字，通过virtualService引用subset的时候就是通过name来引用的</p>
<p>labels：服务标签，通过标签来引用真实的后端服务，最常用的标签为version标签</p>
<p>trafficPolicy：应用到这个subset的流量策略</p>
<p>例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicdapi</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">paas</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">cicdapi</span></span><br><span class="line">  <span class="attr">subset:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span></span><br><span class="line">    <span class="attr">connectionPool:</span></span><br><span class="line">      <span class="attr">tcp:</span></span><br><span class="line">        <span class="attr">maxConnections:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>dr的作用主要就是配置目标服务的匹配方式和负载均衡、熔断的服务治理方式。</p>
<h1 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h1><p>之前的配置不论是vs还是dr的配置都是针对服务间的访问做的样例，没有针对过外部请求访问容器服务的样例。这种请求都需要通过istio的服务网关来配置。</p>
<p>样例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicdfront-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span> <span class="comment"># use istio default controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;cicdfront.com&quot;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicd-front</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cicdfront.com</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cicdfront-gateway</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mesh</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">cicd-front</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h2 id="Gateway规则定义"><a href="#Gateway规则定义" class="headerlink" title="Gateway规则定义"></a>Gateway规则定义</h2><p>Gateway一般需要与virtualService结合使用，Gateway定义了服务从外面怎么访问，virtualService定义了匹配到内部服务怎么流转。<br>关键配置：</p>
<p>selector：必选字段，表示Gateway负载，为入口处的Envoy运行的pod标签</p>
<p>server：必选字段，表示开放的服务列表</p>
<h2 id="后端服务Server"><a href="#后端服务Server" class="headerlink" title="后端服务Server"></a>后端服务Server</h2><p>简述：server定义了服务的访问入口</p>
<ol>
<li>port：必选字段，描述了服务在哪个端口对外开放，是对外监听端口。</li>
<li>hosts：必选字段，为Gateway发布的服务地址，是一个域名，用来匹配virtualService的hosts，会匹配到设置了同样hosts的vs。</li>
</ol>
<p>例：</p>
<p>servers:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;cicdfront.com&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="ServiceEntry"><a href="#ServiceEntry" class="headerlink" title="ServiceEntry"></a>ServiceEntry</h1><h2 id="ServiceEntry是用作外部服务配置。"><a href="#ServiceEntry是用作外部服务配置。" class="headerlink" title="ServiceEntry是用作外部服务配置。"></a>ServiceEntry是用作外部服务配置。</h2><p>简述：将网格外的服务加入网络中，像网格内的服务一样管理，实际上就是将不归属istio自动注入的服务加入到istio的服务发现。</p>
<p>配置示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cicdfront-entry</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">hosts：</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.cicddb.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure>

<h2 id="ServiceEntry规则定义"><a href="#ServiceEntry规则定义" class="headerlink" title="ServiceEntry规则定义"></a>ServiceEntry规则定义</h2><p>重要参数：</p>
<ol>
<li><p>hosts：必选字段，表示ServiceEntry相关的主机名，可以是一个DNS域名，可以使用前缀模糊匹配</p>
</li>
<li><p>addresses：表示与服务关联的虚拟IP地址。</p>
</li>
<li><p>port：表示与外部服务关联的端口。</p>
</li>
<li><p>location：设置服务时在网格内还是网格外，支持以下两种模式</p>
<p>（1）MESH_EXTERNAL：表示在网格外部，通过api访问的外部服务。<br>（2）MESH_INTERNAL：表示在网格内部，一些不能直接注册到服务网格注册中心的服务。</p>
</li>
<li><p>resolution： 表示服务的发现模式，将服务名解析到一个后端的IP上。可以设置NONE、STATIC、DNS三种模式<br>（1）NONE：用于连接的目标地址已经是一个明确的IP场景是使用。<br>（2）STATIC：用在已经使用endpoint设置了服务示例的地址场景中， 也不需要解析。<br>（3）DNS：表示用查询环境中的DNS进行解析，前提是没有在hosts中使用通配符。</p>
</li>
<li><p>subjectAltNames： 表示这个服务负载的SAN列表</p>
</li>
<li><p>endpoints：表示与网格服务关联的网络地址，可以是一个IP，可以是一个主机名。endpoints通过很多字段一同生成<br>（1）address： 必选字段，表示网络后端的服务地址<br>（2）ports：端口列表<br>（3）labels：后端的标签<br>（4）locality：后端的locality，用于亲和性路由<br>（5）weight：表示负载均衡的权重。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在正常使用中，多使用的一般只有virtualService，destinationRule、Gateway这三种功能。vs负责配置访问规则、dr负责配置目标实例和负载规则，Gateway负责配置入口规则。配置好这三种配置就可以满足我们大部分的使用场景。</p>
<blockquote>
<p>但在使用中会发现这几种问题</p>
</blockquote>
<p>istio基本所有的功能配置时都要求一个必填字段hosts,在k8s集群中 ，这个hosts是我们服务的长短域名，也就是service的名称。所以在很大程度来讲，istio都是基于service在工作。但是istio没有图形界面提供功能配置，不论是vs,dr,gw都是需要通过yaml配置的。这种配置就不能限制用户的一些误操作，比如对一个服务配置误配置了两个vs，那么哪个会是有效的vs？对一个服务配置了两个dr，那么哪个会是有效的dr？前面提过istio在1.1版本之后新增了exportTo属性，代表当前配置能否支持跨namespace，默认都是允许跨namespace生效的，这样会不会出现误引用的情况？</p>
<blockquote>
<p>所以在使用时还是建议封装istio的yaml拼装功能，通过页面进行控制，防止误配置yaml。</p>
</blockquote>
<ol>
<li><p>istio会进行服务间的流量治理，实现方式是通过iptables进行流量拦截，这样使用时为了让入口服务也能被istio治理就必须使用istio的入口网关Gateway。这样平台使用时就不能直接为用户提供route的方式访问平台。需要使用gateway进行包装才行。但并不是所有服务都需要进行包装，只有需要在集群外直接访问的服务需要进行这个包装。（大部分都是前台服务才需要进行这个步骤：浏览器 –&gt; cicd-front –&gt; cicd-api，这种情况下就需要为cicdfront生成入口网关，用户需要通过入口网关访问cicdfront才能治理这部分流量）</p>
</li>
<li><p>集群内不能直接访问集群外的url</p>
</li>
</ol>
]]></content>
      <categories>
        <category>服务网格</category>
      </categories>
      <tags>
        <tag>服务网格</tag>
        <tag>未来趋势</tag>
      </tags>
  </entry>
  <entry>
    <title>三天学通MySQL</title>
    <url>/2022/06/14/%E4%B8%89%E5%A4%A9%E5%AD%A6%E9%80%9AMySQL/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程讲解了MySQL的初级从入门到精通，学完这篇对于初级java程序员就已经够了，请尊重原创，如需转载请备注原创链接！</p>
<p>这里推荐一个MySQL教学视频，动力节点的老杜的，讲的非常好！：<a href="https://www.bilibili.com/video/BV1Vy4y1z7EX?spm_id_from=333.337.search-card.all.click&amp;vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV1Vy4y1z7EX?spm_id_from=333.337.search-card.all.click&amp;vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数据库(数据库管理系统：简单的sql语句 )</p>
<ul>
<li>SQL语句的底层也是使用的IO，只是不用这么麻烦了</li>
</ul>
<p>Java IO流程：</p>
<p>objectoutputstream –&gt; Java对象（张三20…) –&gt;序列化到文件当中。</p>
<p>反序列化</p>
<p>new java对象</p>
<p>readobject()</p>
<p>writeobject</p>
<h3 id="常见的有哪些数据库管理系统呢？"><a href="#常见的有哪些数据库管理系统呢？" class="headerlink" title="常见的有哪些数据库管理系统呢？"></a>常见的有哪些数据库管理系统呢？</h3><p>IBM–&gt;eclipse</p>
<ul>
<li>IBM发明了eclipse，曾经想收购java，最后没成功，最后被Oracle公司收购了</li>
</ul>
<p>Oracle 甲骨文(SUN:太阳)</p>
<p>Oracle是做数据库起家的</p>
<p>Oracle–&gt;MySQL AB公司</p>
<ul>
<li>后来Oracle又收购了Ab公司创办的MySQL，MySQL是开源的</li>
</ul>
<p>Oracle  MySQL   DB2  Sybase  “Ms SQLServer[<a href="#_msocom_5">A5]</a> 支持标准SQL的数据库管理系统”</p>
<ul>
<li>Oracle是重量级的数据库，安全，但是收费，一般传统行业会进行使用,比如：银行 政府，Mysql是轻量级的数据库，快，而且开源并且不收费，一般互联网公司会进行使用，比如：现在的京东，阿里等大牌公司</li>
<li>一般大学都是基于SQLServer来讲的，但是市场上大部分都用Mysql居多</li>
</ul>
<h3 id="小总结：学数据库的目的？"><a href="#小总结：学数据库的目的？" class="headerlink" title="小总结：学数据库的目的？"></a>小总结：学数据库的目的？</h3><p>为了方便对数据进行管理</p>
<h2 id="MySQL数据库的安装与配置"><a href="#MySQL数据库的安装与配置" class="headerlink" title="MySQL数据库的安装与配置"></a>MySQL数据库的安装与配置</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">创建文件：my.ini</span></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#skip-grant-tables</span></span><br><span class="line"><span class="comment">#设置3306端口</span></span><br><span class="line"><span class="attr">port</span> = <span class="string">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=<span class="string">D:\\mysql</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">D:\\mysql\data</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="string">200</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="attr">max_allowed_packet</span>=<span class="string">16M</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">环境变量：</span></span><br><span class="line"><span class="attr">新增系统变量</span> <span class="string">MYSQL_HOME=D:\lib\mysql</span></span><br><span class="line"><span class="attr">在系统变量Path后面追加;%MYSQL_HOME%\bin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">安装：mysqld</span> <span class="string">install</span></span><br><span class="line"><span class="attr">初始化：mysqld</span> <span class="string">--initialize-insecure --user=mysql</span></span><br><span class="line"><span class="attr">打开：net</span> <span class="string">start mysql</span></span><br><span class="line"><span class="attr">关闭：net</span> <span class="string">stop mysql</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">系统没有安装条件：https</span>:<span class="string">//www.microsoft.com/zh-CN/download/details.aspx?id=40784</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是端口？"><a href="#什么是端口？" class="headerlink" title="什么是端口？"></a>什么是端口？</h2><p>端口是你这个软件的代号</p>
<p>1521的端口是Oracle</p>
<p>3306就是MySQL</p>
<p>80是web服务器通用端口</p>
<p>查询网页端口号：先打开cmd页面输入ping 网址可以获取</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714171033642.png" alt="image-20220714171033642"></p>
<p>每个软件在安装时都会启动一个服务</p>
<h2 id="Mysql登入步骤"><a href="#Mysql登入步骤" class="headerlink" title="Mysql登入步骤"></a>Mysql登入步骤</h2><ol>
<li>先进入cmd</li>
<li>然后输入mysql –uroot –p+密码（这是显式登入隐式登入就输入mysql –uroot –p后回车）</li>
<li><img src="D:\开发类\MySQL笔记图片\image-20220714171233179.png" alt="image-20220714171233179"></li>
<li>然后就可以进行sql语句了，exit是退出</li>
</ol>
<h2 id="忘记root密码找回步骤"><a href="#忘记root密码找回步骤" class="headerlink" title="忘记root密码找回步骤"></a>忘记root密码找回步骤</h2><p> <img src="D:\开发类\MySQL笔记图片\image-20220714171311665.png" alt="image-20220714171311665"></p>
<h2 id="MySQL彻底删除步骤"><a href="#MySQL彻底删除步骤" class="headerlink" title="MySQL彻底删除步骤"></a>MySQL彻底删除步骤</h2><ol>
<li><p>先打开 <img src="D:\开发类\MySQL笔记图片\image-20220714171322850.png" alt="image-20220714171322850"> 这个软件</p>
</li>
<li><p>双击打开后点击remove</p>
<p><img src="D:\开发类\MySQL笔记图片\image-20220714171425210.png" alt="image-20220714171425210"></p>
<p>点击remove后只是把软件删除了，服务关闭了，此时还没彻底删除</p>
</li>
<li><p>C盘里Program Files (x86)里的MySQL删除掉</p>
</li>
<li><p>C盘里隐藏目录ProgramData里的MySQL删除掉</p>
</li>
</ol>
<h1 id="MySQL-day01"><a href="#MySQL-day01" class="headerlink" title="MySQL day01"></a>MySQL day01</h1><h2 id="MySQL的基本使用与介绍"><a href="#MySQL的基本使用与介绍" class="headerlink" title="MySQL的基本使用与介绍"></a>MySQL的基本使用与介绍</h2><h3 id="1-SQL-DB-DBMS分别是什么，它们之间的关系？"><a href="#1-SQL-DB-DBMS分别是什么，它们之间的关系？" class="headerlink" title="1.SQL,DB,DBMS分别是什么，它们之间的关系？"></a>1.SQL,DB,DBMS分别是什么，它们之间的关系？</h3><p>SQL:</p>
<p>结构化查询语句，是一门标准通用的语言。标准的SQL适合于所有的数据库产品。</p>
<p>SQL属于高级语言。只要能看懂英语单词的，写出来的sql语句，可以读懂什么意思。</p>
<p>SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行SQL(sql语句的编译由DBMS完成。)</p>
<p>DB：</p>
<p>​    DataBase(数据库，数据库实际上在硬盘上以文件的形式存在)</p>
<p>DBMS：</p>
<p>DataBase Management System(数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SQLServer…)</p>
<p>DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。</p>
<p>DBMS-(执行)-&gt;SQL-(操作)-&gt;DB</p>
<h3 id="2-什么是表"><a href="#2-什么是表" class="headerlink" title="2.什么是表?"></a>2.什么是表?</h3><p>表: table</p>
<p>表:table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。</p>
<p>一个表包括行和列:</p>
<p>行:被称为数据&#x2F;记录(data)</p>
<p>列:被称为字段(column)</p>
<p>学号(int)  姓名(varchar)  年龄(int)</p>
<p>-——————————–</p>
<p>110    张三      20</p>
<p>120   李四      21</p>
<p>每一个字段应该包括哪些属性?</p>
<p>字段名（列如：张三） 、数据类型（列如：人）、相关的约束（列如：人不能干哪些事，或者只能干哪些事） 。</p>
<h3 id="3、学习MysQL主要还是学习通用的Sql语句-那么Sql语句包括增删改查-SQL语句怎么分类呢-重点"><a href="#3、学习MysQL主要还是学习通用的Sql语句-那么Sql语句包括增删改查-SQL语句怎么分类呢-重点" class="headerlink" title="3、学习MysQL主要还是学习通用的Sql语句,那么Sql语句包括增删改查,SQL语句怎么分类呢?(重点)"></a>3、学习MysQL主要还是学习通用的Sql语句,那么Sql语句包括增删改查,SQL语句怎么分类呢?(重点)</h3><p>DQL（数据查询语言）:查询语句，凡是select语句都是DQL。</p>
<p>DML (数据操作语言) : insert delete update，对表当中的数据进行增删改。</p>
<p>DDL（数据定义语言) : create drop alter，对表结构的增删改。</p>
<p>TCL (事务控制语言）: commit提交事务，rollback回滚事务。(TCL中的T是Transaction)</p>
<p>DCL（数据控制语言） : grant授权、revoke撤销权限等。</p>
<h3 id="4．导入数据（后期练习的时候使用这个演示的数据"><a href="#4．导入数据（后期练习的时候使用这个演示的数据" class="headerlink" title="4．导入数据（后期练习的时候使用这个演示的数据)"></a>4．导入数据（后期练习的时候使用这个演示的数据)</h3><p>第一少:登录msql数据摩管理系统</p>
<p>dos命令窗口:</p>
<p>mysql -uroot –p+密码</p>
<p>第二步:查看有哪些数据库</p>
<p>show databases;(这个不是SQL语句，属于MySQL的命令。)</p>
<p>+——————–+</p>
<p>| Database       |</p>
<p>+——————–+</p>
<p>| information_schema  |</p>
<p>| mysql        |</p>
<p>| performance_schema |</p>
<p>| sys         |</p>
<p>+——————–+</p>
<p>第三步:创建属于我们自己的数据库</p>
<p>create database bjpowernode;(这个不是SQL语句，属于MysQL的命令。)</p>
<p>第四步:使用bjpowernodc数据</p>
<p>use 数据库名; (这个不是SQL语句，属于MySQL的命令。)</p>
<p>第五步:查看当前使用的数据库中有哪些表？</p>
<p>show tables;(这个不是SQL语句，属于MySQL的命令。)</p>
<p>查看其他数据库的表：show tables from+表名</p>
<p>第六步:初始化数据</p>
<p>Mysql&gt; source +文件路径</p>
<p><strong>重点：</strong>source这个命令是用来执行sql脚本的</p>
<h3 id="5-bjpowernode-sql，这个文件以sql结尾，这样的文件被称为”sq1脚本”。什么是sql脚本呢"><a href="#5-bjpowernode-sql，这个文件以sql结尾，这样的文件被称为”sq1脚本”。什么是sql脚本呢" class="headerlink" title="5.bjpowernode.sql，这个文件以sql结尾，这样的文件被称为”sq1脚本”。什么是sql脚本呢?"></a>5.bjpowernode.sql，这个文件以sql结尾，这样的文件被称为”sq1脚本”。什么是sql脚本呢?</h3><p>当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。</p>
<p>注意:直接使用source命令可以执行sql脚本。</p>
<p>sql脚本中的数据量太大的时候,无法打开，请使用source命令完成初始化。</p>
<h3 id="6-删除数据库：drop-database-数据库名"><a href="#6-删除数据库：drop-database-数据库名" class="headerlink" title="6.删除数据库：drop database+数据库名;"></a>6.删除数据库：drop database+数据库名;</h3><p>Sql语句的结尾一定要有；</p>
<h3 id="7-查看表结构："><a href="#7-查看表结构：" class="headerlink" title="7.查看表结构："></a>7.查看表结构：</h3><p>+———————–+</p>
<p>| Tables_in_bjpowernode      |</p>
<p>+———————–+</p>
<p>| dept           |  (部门表)</p>
<p>| emp          |  (员工表)</p>
<p>| salgrade         |  (工资等级表)</p>
<p>+———————–+</p>
<p>查看表结构命令：mysql&gt; desc +表名;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172020887.png" alt="image-20220714172020887"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172025690.png" alt="image-20220714172025690"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172032321.png" alt="image-20220714172032321"></p>
<h3 id="8-查看表中数据"><a href="#8-查看表中数据" class="headerlink" title="8.查看表中数据"></a>8.查看表中数据</h3><p>查看表中数据命令：mysql&gt;select * from +表名;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172403171.png" alt="image-20220714172403171"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172408331.png" alt="image-20220714172408331"></p>
<p><img src="D:\开发类\MySQL笔记图片\image-20220714172415060.png" alt="image-20220714172415060"></p>
<p>每个表中的数据都是互通的，比如可以通过员工表中的员工的上级编号可以知道他所处的部门，也可以通过员工的工资知道它所处的工资等级</p>
<h3 id="9-MySQL的常用命令？"><a href="#9-MySQL的常用命令？" class="headerlink" title="9.MySQL的常用命令？"></a>9.MySQL的常用命令？</h3><p> <img src="D:\开发类\MySQL笔记图片\image-20220714172447798.png" alt="image-20220714172447798"></p>
<p>结束一条sql语句：\c</p>
<p>退出mysql：exit</p>
<h3 id="10-查看创建表的语句："><a href="#10-查看创建表的语句：" class="headerlink" title="10.查看创建表的语句："></a>10.查看创建表的语句：</h3><p>Show create table +表名</p>
<h3 id="11-简单的查询语句-DQL"><a href="#11-简单的查询语句-DQL" class="headerlink" title="11.简单的查询语句(DQL)"></a>11.简单的查询语句(DQL)</h3><p>语法格式：</p>
<p>​    select 字段名1，字段名2，……. from 表名;</p>
<p>提示：</p>
<ol>
<li>任何一条sql语句以 ; 结尾</li>
<li>Sql语句不区分大小写</li>
</ol>
<p>查询员工的年薪？(字段可以参与数学运算。)</p>
<p>select ename,sal * 12 from emp;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172611874.png" alt="image-20220714172611874"></p>
<p>给查询结果的列重命名？</p>
<p>  select ename,sal * 12 as +要重命的名 from emp;</p>
<p>重名名想取中文？</p>
<p>  select ename,sal * 12 as +中文名 from emp;&#x2F;&#x2F;错误</p>
<p>select ename,sal * 12 as +’ 中文名’ from emp;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172638029.png" alt="image-20220714172638029"></p>
<p>注意：标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，但是建议尽量别用。</p>
<p>as关键字可以省略？</p>
<p>select ename,sal * 12 +要重命的名 from emp;</p>
<p>查询所有字段？</p>
<p>​    select * from +表名;&#x2F;&#x2F;实际开发中的时候不建议使用<em>，因为</em>会自动转换成字段，效率较低。</p>
<h3 id="12-条件查询"><a href="#12-条件查询" class="headerlink" title="12.条件查询"></a>12.条件查询</h3><p>​    语法格式：</p>
<p>​       Select</p>
<p>​           字段，字段..</p>
<p>​       From</p>
<p>​           表名</p>
<p>​       Where</p>
<p>​           条件;</p>
<p>执行顺序：先from，然后where，最后select </p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172700954.png" alt="image-20220714172700954"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172708000.png" alt="image-20220714172708000"></p>
<p><img src="D:\开发类\MySQL笔记图片\image-20220714172717876.png" alt="image-20220714172717876"></p>
<p><img src="D:\开发类\MySQL笔记图片\image-20220714172723226.png" alt="image-20220714172723226"></p>
<p><img src="D:\开发类\MySQL笔记图片\image-20220714172730615.png" alt="image-20220714172730615"></p>
<p><img src="D:\开发类\MySQL笔记图片\image-20220714172737741.png" alt="image-20220714172737741"></p>
<p>但是实际开发中between and用在数字上比较多</p>
<p>找出哪些人是的津贴为NULL？</p>
<p>​    在数据库中NULL不是一个值，NULL代表什么也没有，代表空。</p>
<p>​    空不是一个值，不能用等号衡量。</p>
<p>​    必须使用is null或者is not null来进行判断</p>
<p>​    select ename,sal,comm from emp where comm is null;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172751805.png" alt="image-20220714172751805"></p>
<p>错误语法：select ename,sal,comm from emp where comm &#x3D;null;</p>
<p>Empty set (0.00 sec)</p>
<p>找出哪些人的津贴不为NULL？</p>
<p>  select ename,sal,comm from emp where comm is not null;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172801517.png" alt="image-20220714172801517"></p>
<h4 id="Sql运算符："><a href="#Sql运算符：" class="headerlink" title="Sql运算符："></a>Sql运算符：</h4><p> <img src="D:\开发类\MySQL笔记图片\image-20220714172812616.png" alt="image-20220714172812616"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172819983.png" alt="image-20220714172819983"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172826564.png" alt="image-20220714172826564"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714172832391.png" alt="image-20220714172832391"></p>
<h3 id="13-排序-升序，降序"><a href="#13-排序-升序，降序" class="headerlink" title="13.排序(升序，降序)"></a>13.排序(升序，降序)</h3><p>按照工资升序，找出员工和薪资</p>
<p>select ename,sal</p>
<p>from emp</p>
<p>order by sal;</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>Select</p>
<p>​    字段           3</p>
<p>From</p>
<p>​    表名           1</p>
<p>Where</p>
<p>​    条件           2</p>
<p>Order by</p>
<p>​    …             4</p>
<p>Order by是最后执行的。</p>
<p>– <strong>注意</strong>：默认是升序。asc表示升序，desc表示降序。</p>
<p>select ename,sal</p>
<p>from emp order by sal;</p>
<p>– 升序</p>
<p>select ename,sal</p>
<p>from emp order by sal asc;</p>
<p>– 升序</p>
<p>select ename,sal</p>
<p>from emp order by sal desc;</p>
<p>– 降序</p>
<p>– 按照工资的降序排列，当工资相同的时候再按照名字的升序排列。</p>
<p>select ename,sal</p>
<p>from emp order by sal desc ;</p>
<p>select ename,sal</p>
<p>from emp order by sal desc ,ename asc;</p>
<p>– 注意:越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。</p>
<p>select *</p>
<p>from emp order by 6 desc;</p>
<p>– 实操不建议这样使用，测试的时候可以使用</p>
<p>– 找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。</p>
<p>select ename,job,sal</p>
<p>from emp</p>
<p>where job&#x3D;’SALESMAN’</p>
<p>order by sal desc;</p>
<h3 id="14-分组函数？"><a href="#14-分组函数？" class="headerlink" title="14.分组函数？"></a>14.分组函数？</h3><p>– count 计数</p>
<p>– sum 求和</p>
<p>– avg 平均值</p>
<p>– max 最大值</p>
<p>– min 最小值</p>
<p>– 记住：所有的分组函数都是对“某一组”数据进行操作的。</p>
<p>– 找出工资总和？</p>
<p>select sum(sal) as ‘总工资’</p>
<p>from emp;</p>
<p>– 找出最高工资？</p>
<p>select max(sal) as ‘最高工资’</p>
<p>from emp;</p>
<p>– 找出最低工资？</p>
<p>select min(sal) as ‘最低工资’</p>
<p>from emp;</p>
<p>– 找出平均工资？</p>
<p>select avg(sal) as ‘平均工资’</p>
<p>from emp;</p>
<p>– 找出总人数？</p>
<p>select count(*) as ‘总人数’</p>
<p>from emp;</p>
<p>select count(ename) as ‘总人数’</p>
<p>from emp;</p>
<p>– 分组函数一共5个，只有5个。</p>
<p>– 分组函数还有另一个名字：多行处理函数。</p>
<p>– 多行处理函数的特点：输入多行，最终输出的结构是1行。</p>
<p>– <strong>分组函数会自动忽略NULL。</strong></p>
<p>select comm</p>
<p>from emp;</p>
<p>select count(comm)</p>
<p>from emp;</p>
<p>– 测试分组函数会不会自动忽略NULL</p>
<p>select sum(comm)</p>
<p>from emp;</p>
<p>select sum(comm) </p>
<p>from emp </p>
<p>where comm is not null;（不需要额外添加这个过滤条件。sum函数自动忽略NULL。）</p>
<p>– 找出工资高于平均工资的员工</p>
<p>select avg(sal)</p>
<p>from emp; –平均工资</p>
<p>正确：select ename,sal</p>
<p>​     From emp</p>
<p>​     Where sal &gt; (select avg(sal) from emp);</p>
<p>错误：</p>
<p>– select ename,sal</p>
<p>– from emp</p>
<p>– where sal&gt;avg(sal); &#x2F;&#x2F;&gt; 1111 - Invalid use of group function</p>
<p>– 思考以上的错误信息：无效的使用了分组函数？</p>
<p>–  原因：SQL语句当中有一个语法规则，分组函数不可直接使用在where句子当中。</p>
<p><strong>提出问题：为什么分组函数不可直接使用在where句子当中呢？</strong></p>
<p>因为分组函数是在group by后面执行的，但是group by又是在where后面才执行的</p>
<p>换句话来说就是在使用where的时候组都还没分使用不了分组函数</p>
<p>当一条sql语句没有group by的话，整张表的数据会自成一组，那为什么会自成一组却还是不能用呢？因为在sql语句里面当没有写group by 时 ，sql语句会有一个隐式的group by 这个时候的group by就是把整张表自成一组，所以where里还是不能用分组函数</p>
<p>优先级：where&gt;group by&gt;分组函数，所以分组函数不能放在where中。</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714173358496.png" alt="image-20220714173358496"></p>
<p>– count(*)和count(具体的某个字段),它们有什么区别？</p>
<p>–  count(*):不是统计某个字段中数据的个数，而是统计总记录条数。(和某个字段无关)</p>
<p>–  count(comm):表示统计comm字段中不为NULL的数据总数量。</p>
<p>– 分组函数也能组合起来用：</p>
<p>select count(*),sum(sal),avg(sal),max(sal),min(sal)</p>
<p>from emp;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714173405553.png" alt="image-20220714173405553"></p>
<h3 id="15-单行处理函数"><a href="#15-单行处理函数" class="headerlink" title="15.单行处理函数"></a>15.单行处理函数</h3><p>SQL单行函数是对于每一行数据进行计算后得到一行输出结果。SQL单行函数根据数据类型分为字符函数、数字函数、日期函数、转换函数，另外还有一些别的函数。</p>
<p>– 什么是单行处理函数？</p>
<p>–  输入一行，输出一行。</p>
<p>– 计算每个员工的年薪？</p>
<p> select ename,(sal+comm)*12 as yearsal </p>
<p> from emp;</p>
<p>– <strong>重点：所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL。</strong></p>
<p>– 使用ifnull函数：</p>
<p>select ename,(ifnull(comm,0)+sal)*12 as 年薪</p>
<p>from emp;</p>
<p>– ifnull()空处理函数？</p>
<p>select ename,ifnull(comm,0)</p>
<p>from emp;</p>
<p>–  ifnull(可能为NULL的数据，被当做什么处理)：属于单行处理函数。</p>
<h3 id="16-group-by-和having"><a href="#16-group-by-和having" class="headerlink" title="16.group by 和having"></a>16.group by 和having</h3><p>– group by ：按照某个字段或者某些字段进行分组。</p>
<p>– having ： having是对分组之后的数据进行再次过滤。</p>
<p>– 案例：找出每个工作岗位的最高薪资。</p>
<p>– select max(sal) </p>
<p>– from emp group by job;</p>
<p>– 注意：分组函数一般都会和group by联合使用，这也是为什么他被称为分组函数的原因。</p>
<p>– 并且任何一个分组函数(count sum avg max min)都是在group by语句执行结束之后才会执行的。</p>
<p>– 当一条sql语句没有group by的话，整张表的数据会自成一组。</p>
<p>select ename,max(sal),job</p>
<p>from emp group by job;</p>
<ul>
<li>这个时候使用enname将没有意义，因为当一条语句中有group by的时候，select后面只能跟分组函数和参与分组的字段。</li>
</ul>
<p>– 以上在mysql当中，查询结果是有的，但是结果没有意义，在Oracle数据库当中会报错。语法错误。</p>
<p>– Oracle的语法规则比MySQL语法规则严谨。</p>
<p>– 记住一个规则：<strong>当一条语句中有group by的时候，select后面只能跟分组函数和参与分组的字段。</strong></p>
<p>– 每个工作岗位的平均薪资？</p>
<p>select job,avg(sal) </p>
<p>from emp group by job;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175213830.png" alt="image-20220714175213830"></p>
<p>– 多个字段能不能联合起来一块分组？</p>
<p>– 案例：找出每个部门不同工作岗位的最高薪资。</p>
<p>select deptno,job,max(sal)</p>
<p>from emp</p>
<p>group by deptno,job;</p>
<p>– 找出每个部门的最高薪资，要求显示薪资大于2900的数据。</p>
<p>– 第一步：找出每个部门的最高的薪资</p>
<p>select max(sal),deptno</p>
<p>from emp </p>
<p>group by deptno;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175224323.png" alt="image-20220714175224323"></p>
<p>– 第二步：找出薪资大于2900</p>
<p>select max(sal),deptno</p>
<p>from emp </p>
<p>group by deptno</p>
<p>having max(sal) &gt; 2900;</p>
<p>– 效率低</p>
<p>select max(sal),deptno</p>
<p>from emp </p>
<p>where sal &gt; 2900</p>
<p>group by deptno ;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175233628.png" alt="image-20220714175233628"></p>
<p>– 效率较高，建议能够使用where过滤的尽量使用where</p>
<p>– 找出每个部门的平均薪资，要求显示平均薪资大于2000的数据。</p>
<p>– 第一步：找出每个部门的平均薪资</p>
<p>select deptno,avg(sal)</p>
<p>from emp </p>
<p>group by deptno;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175241426.png" alt="image-20220714175241426"></p>
<p>– 第二步：要求显示平均薪资大于2000的数据。</p>
<p>select deptno,avg(sal)</p>
<p>from emp </p>
<p>group by deptno</p>
<p>having avg(sal) &gt; 2000;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175248021.png" alt="image-20220714175248021"></p>
<p>– where后面不能使用分组函数：</p>
<p>select deptno,avg(sal)</p>
<p>from emp</p>
<p>where avg(sal) &gt; 2000</p>
<p>group by deptno;</p>
<p>– 这种情况只能使用having过滤。</p>
<h3 id="17-总结一个完整的DQL语句怎么写？"><a href="#17-总结一个完整的DQL语句怎么写？" class="headerlink" title="17.总结一个完整的DQL语句怎么写？"></a>17.总结一个完整的DQL语句怎么写？</h3><p> <img src="D:\开发类\MySQL笔记图片\image-20220714175255296.png" alt="image-20220714175255296"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175302847.png" alt="image-20220714175302847"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175309562.png" alt="image-20220714175309562"></p>
<h1 id="MySQL-day02"><a href="#MySQL-day02" class="headerlink" title="MySQL day02"></a>MySQL day02</h1><h2 id="MySQL的进阶使用"><a href="#MySQL的进阶使用" class="headerlink" title="MySQL的进阶使用"></a>MySQL的进阶使用</h2><h3 id="1-关于查询结果集的去重？"><a href="#1-关于查询结果集的去重？" class="headerlink" title="1.关于查询结果集的去重？"></a>1.关于查询结果集的去重？</h3><p>select distinct job</p>
<p>from emp;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175347657.png" alt="image-20220714175347657"></p>
<p>– distinct关键字去除重复记录。</p>
<p>– select ename,distinct job </p>
<p>– from emp;</p>
<p>以上的SQL语句是错误的。</p>
<p>– 记住：distinct只能出现在所有字段的最前面。</p>
<p>select distinct deptno,job</p>
<p>from emp;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175355704.png" alt="image-20220714175355704"></p>
<p>– 案例：统计岗位的数量？</p>
<p>select count(distinct job) as ‘岗位的数量’</p>
<p>from emp;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175401608.png" alt="image-20220714175401608"></p>
<h3 id="2-连接查询"><a href="#2-连接查询" class="headerlink" title="2.连接查询"></a>2.连接查询</h3><h4 id="什么是连接查询？"><a href="#什么是连接查询？" class="headerlink" title="什么是连接查询？"></a>什么是连接查询？</h4><p>– 在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多表联合查询取出最终的结果。</p>
<p>– 在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175407646.png" alt="image-20220714175407646"></p>
<p>– 学生和班级信息存储到一张表，结果就像上面一样，数据会存在大量的重复，导致数据的冗余。</p>
<h4 id="连接查询的分类？"><a href="#连接查询的分类？" class="headerlink" title="连接查询的分类？"></a>连接查询的分类？</h4><p>– 根据语法出现的年代来划分的话，包括：</p>
<p>–      SQL92(一些老的DBA可能还在使用这种语法。DBA：DataBase Administrator，数据库管理员)</p>
<p>–      SQL99(比较新的语法)</p>
<p>– 根据表的连接方式来划分，包括：</p>
<p>–      内连接：</p>
<p>–             等值连接</p>
<p>–             非等值连接</p>
<p>–             自连接</p>
<p>–      外连接：</p>
<p>–         左外连接(左连接)</p>
<p>–         右外连接(右连接)</p>
<p>–      全连接(这个不细讲，因为很少用)</p>
<h4 id="在表的连接查询方面有一种现象被称为：笛卡尔积现象-笛卡尔乘积现象"><a href="#在表的连接查询方面有一种现象被称为：笛卡尔积现象-笛卡尔乘积现象" class="headerlink" title="在表的连接查询方面有一种现象被称为：笛卡尔积现象(笛卡尔乘积现象)"></a>在表的连接查询方面有一种现象被称为：笛卡尔积现象(笛卡尔乘积现象)</h4><ul>
<li>笛卡尔乘积是指在数学中，两个<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88">集合</a><em>X</em>和<em>Y</em>的笛卡尔积（Cartesian product），又称<a href="https://baike.baidu.com/item/%E7%9B%B4%E7%A7%AF/6537064">直积</a>，表示为<em>X</em> × <em>Y</em>，第一个对象是<em>X</em>的成员而第二个对象是<em>Y</em>的所有可能<a href="https://baike.baidu.com/item/%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>的其中一个成员</li>
</ul>
<p>– 案例：找出每一个员工的部门名称，要求显示员工名和部门名。</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175445412.png" alt="image-20220714175445412"></p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175451229.png" alt="image-20220714175451229"></p>
<p>select ename,dname </p>
<p>from emp,dept;</p>
<p>– 笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175459643.png" alt="image-20220714175459643"></p>
<p>关于表的别名：</p>
<p>​    Select e.ename,d.dname </p>
<p>​    From emp e,dept d;</p>
<p>–  表的别名有什么好处？</p>
<p>–      第一：执行效率高。</p>
<p>–      第二：可读性好。</p>
<h4 id="怎么避免笛卡尔积现象？当然是加条件进行过滤。"><a href="#怎么避免笛卡尔积现象？当然是加条件进行过滤。" class="headerlink" title="怎么避免笛卡尔积现象？当然是加条件进行过滤。"></a>怎么避免笛卡尔积现象？当然是加条件进行过滤。</h4><p>– 思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？</p>
<p>–      不会，次数还是56次，只不过显示的是有效记录。</p>
<p>– 案例：找出每一个员工的部门名称，要求显示员工名和部门名。</p>
<h4 id="内连接之等值连接：最大特点是：条件是等量关系。"><a href="#内连接之等值连接：最大特点是：条件是等量关系。" class="headerlink" title="内连接之等值连接：最大特点是：条件是等量关系。"></a>内连接之等值连接：最大特点是：条件是等量关系。</h4><p>案例：查询每个员工的部门名称，要求显示员工名和部门名。</p>
<p>SQL92：(太老，不用了)</p>
<p>​       select e.ename as ‘姓名’,d.dname as ‘所在部门’ </p>
<p>​       from emp e,dept d</p>
<p>​       where e.deptno &#x3D; d.deptno;</p>
<p>SQL99:(常用的)</p>
<p>​       select e.ename as ‘姓名’,d.dname as ‘所在部门’ </p>
<p>​       from emp e</p>
<p>​       join dept d</p>
<p>​       on e.deptno &#x3D; d.deptno;</p>
<p>其实join前面还有个inner，但是inner可以省略，带着inner目的是可读性好一些，inner表示内连接。</p>
<p>​       select e.ename as ‘姓名’,d.dname as ‘所在部门’ </p>
<p>​       from emp e</p>
<p>​       inner join dept d</p>
<p>​       on e.deptno &#x3D; d.deptno;</p>
<p>语法：</p>
<p>​    …</p>
<p>​       A表</p>
<p>​    join</p>
<p>​       B表</p>
<p>​    on</p>
<p>​       连接条件</p>
<p>​    where</p>
<p>​       过滤条件</p>
<p>SQL99语法结构更清晰一些：表的连接条件和后来的where条件分离了。</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175526630.png" alt="image-20220714175526630"></p>
<h4 id="内连接之非等值连接：最大特点是：连接条件中的关系是非等量关系。"><a href="#内连接之非等值连接：最大特点是：连接条件中的关系是非等量关系。" class="headerlink" title="内连接之非等值连接：最大特点是：连接条件中的关系是非等量关系。"></a>内连接之非等值连接：最大特点是：连接条件中的关系是非等量关系。</h4><p>– 案例：找出每个员工的工资等级，要求显示员工名，工资，工资等级。</p>
<p>– 先找出员工名字和工资</p>
<p>select ename,sal</p>
<p>from emp;</p>
<p> <img src="D:\开发类\MySQL笔记图片\image-20220714175539988.png" alt="image-20220714175539988"></p>
<p>– 再找出工资等级表</p>
<p>select *</p>
<p>from salgrade;</p>
<p>– 连起来查询</p>
<p>select e.ename,e.sal,s.grade</p>
<p>from emp e</p>
<p>join salgrade s</p>
<p>on e.sal between s.losal and s.hisal;</p>
<h4 id="自连接：最大特点是-一张表看作两张表。自己连接自己。"><a href="#自连接：最大特点是-一张表看作两张表。自己连接自己。" class="headerlink" title="自连接：最大特点是:一张表看作两张表。自己连接自己。"></a>自连接：最大特点是:一张表看作两张表。自己连接自己。</h4><p>– 案例：找出员工的上级领导，要求显示员工名和对应的领导名。</p>
<p>select empno,ename,mgr</p>
<p>from emp;</p>
<p>emp a员工表：</p>
<p>emp b 领导表：</p>
<p>员工的领导编号 &#x3D; 领导的员工编号</p>
<p>select a.ename as ‘员工名’,b.ename as ‘领导名’</p>
<p>from emp a</p>
<p>join emp b</p>
<p>on b.empno &#x3D; a.mgr</p>
<p>order by a.ename asc;</p>
<h4 id="外连接（比较重要，开发中最常用）"><a href="#外连接（比较重要，开发中最常用）" class="headerlink" title="外连接（比较重要，开发中最常用）"></a>外连接（比较重要，开发中最常用）</h4><h5 id="什么是外连接，外连接和内连接有什么区别？"><a href="#什么是外连接，外连接和内连接有什么区别？" class="headerlink" title="什么是外连接，外连接和内连接有什么区别？"></a>什么是外连接，外连接和内连接有什么区别？</h5><p>内连接：</p>
<p>​           假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。</p>
<p>​           AB两张表没有主副之分，两张表是平等的。</p>
<p>​    外连接：</p>
<p>​           假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中</p>
<p>​           的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p>
<p>​    外连接的分类？</p>
<p>​          左外连接(左连接)：表示左边的这张表是主表。</p>
<p>​          右外连接(右连接)：表示右边的这张表是主表。</p>
<p>​           </p>
<p>​           左连接有右连接的方法，右连接也会有对应的左连接的写法。</p>
<p>案例：找出每个员工的上级领导？</p>
<p>emp a员工表：</p>
<p>emp b 领导表：</p>
<p>内连接[<a href="#_msocom_15">A15]</a> ：(自连接)</p>
<p>select a.ename as ‘员工’,b.ename as ‘领导’</p>
<p>from emp a</p>
<p>join emp b</p>
<p>on b.empno &#x3D; a.mgr</p>
<p>order by a.ename asc;</p>
<p>外连接：(左外连接[<a href="#_msocom_16">A16]</a> ，左连接)</p>
<p>select a.ename as ‘员工’,b.ename as ‘领导’</p>
<p>from emp a</p>
<p>left join emp b</p>
<p>on b.empno &#x3D; a.mgr</p>
<p>order by a.ename asc;</p>
<p>outer是可以省略的，outer代表外连接</p>
<p>select a.ename as ‘员工’,b.ename as ‘领导’</p>
<p>from emp a</p>
<p>left outer join emp b</p>
<p>on b.empno &#x3D; a.mgr</p>
<p>order by a.ename asc;</p>
<p>外连接：(右外连接[<a href="#_msocom_17">A17]</a> ，右连接)</p>
<p>select a.ename as ‘员工’,b.ename as ‘领导’</p>
<p>from emp b</p>
<p>right join emp a</p>
<p>on b.empno &#x3D; a.mgr</p>
<p>order by a.ename asc;</p>
<p>外连接最重要的特点是：主表的数据无条件的全部查询出来。</p>
<p>案例：找出哪个部门没有员工？</p>
<p>Emp员工表：</p>
<p>Dept部门表：</p>
<p>select d.*</p>
<p>from emp e</p>
<p>right join dept d</p>
<p>on e.deptno &#x3D; d.deptno</p>
<p>where e.empno is null;</p>
<h4 id="全连接-A18-很少用，了解就行"><a href="#全连接-A18-很少用，了解就行" class="headerlink" title="全连接[A18] (很少用，了解就行)"></a>全连接[<a href="#_msocom_18">A18]</a> (很少用，了解就行)</h4><p>Oracle数据库支持full join，mysql是不支持full join的，但仍然可以同过左外连接+ union+右外连接实现</p>
<p>语法：</p>
<p>SELECT * FROM t1</p>
<p>LEFT JOIN t2 ON t1.id &#x3D; t2.id</p>
<p>UNION</p>
<p>SELECT * FROM t1</p>
<p>RIGHT JOIN t2 ON t1.id &#x3D; t2.id</p>
<h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><p>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉连接也称作笛卡尔积。</p>
<p>语法：</p>
<p>select * </p>
<p>from book as a cross</p>
<p>join stu as b </p>
<p>order by a.id</p>
<h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><p>案例：找出每一个员工的部门名称以及工资等级。</p>
<p>Emp员工表：e</p>
<p>Dept部门表：d</p>
<p>Salgrad工资等级表: s</p>
<p>select e.ename as ‘姓名’,d.dname as ‘部门’,s.grade as ‘工资等级’</p>
<p>from emp e</p>
<p>left join dept d</p>
<p>on e.deptno &#x3D; d.deptno</p>
<p>left join salgrade s</p>
<p>on e.sal between s.losal and s.hisal;</p>
<p>案例：找出每一个员工的部门名称，工资等级，以及上级领导。</p>
<p>select e.ename as ‘姓名’,d.dname as ‘部门’,s.grade as ‘工资等级’,b.ename as ‘上级领导’ </p>
<p>from emp e</p>
<p>left join dept d</p>
<p>on e.deptno &#x3D; d.deptno</p>
<p>left join salgrade s</p>
<p>on e.sal between s.losal and s.hisal</p>
<p>left join emp b[<a href="#_msocom_19">A19]</a> </p>
<p>on b.empno &#x3D; e.mgr;</p>
<p>语法：select 字段…</p>
<p>​     From 主表</p>
<p>​     Join 副表1</p>
<p>​     On  连接条件1</p>
<p>​     Join 副表2</p>
<p>On  连接条件2</p>
<p>……</p>
<p>注意：主表先和副表1进行表连接，连接之后主表继续和副表2进行连接。</p>
<p>写SQL语句先看题目，然后按照题目一步一步写SQL语句。</p>
<p>小知识：本机ip：127.0.0.1  或者写localhost也行表示本机名</p>
<h4 id="子查询：什么是子查询？子查询都可以出现在哪里？"><a href="#子查询：什么是子查询？子查询都可以出现在哪里？" class="headerlink" title="子查询：什么是子查询？子查询都可以出现在哪里？"></a>子查询：什么是子查询？子查询都可以出现在哪里？</h4><p>select语句中嵌套select语句，被嵌套的select语句是子查询。</p>
<p>子查询可以出现在哪里？</p>
<p>​       select</p>
<p>​           ..select..</p>
<p>​       from</p>
<p>​           ..select..</p>
<p>​       where</p>
<p>​           ..select..</p>
<h5 id="where子句中使用子查询"><a href="#where子句中使用子查询" class="headerlink" title="where子句中使用子查询"></a>where子句中使用子查询</h5><p>案例：找出高于平均薪资的员工信息。</p>
<p>select *</p>
<p>from emp</p>
<p>where sal &gt;avg(sal);    – 错误的写法，where后面不能直接使用分组函数。</p>
<p>第一步：找出平均薪资</p>
<p>select avg(sal)</p>
<p>from emp;</p>
<p>第二步：where过滤</p>
<p>select *</p>
<p>from emp</p>
<p>where sal &gt; 2073.214286;</p>
<p>第一步和第二步合并：</p>
<p>select *</p>
<p>from emp</p>
<p>where sal &gt; (select avg(sal)</p>
<p>from emp);</p>
<h5 id="from后面嵌套子查询-A20"><a href="#from后面嵌套子查询-A20" class="headerlink" title="from后面嵌套子查询[A20]"></a>from后面嵌套子查询[<a href="#_msocom_20">A20]</a></h5><p>案例：找出每个部门平均薪水的薪资等级。</p>
<p>第一步：找出每个部门平均薪水的薪资等级。</p>
<p>select deptno,avg(sal)</p>
<p>from emp</p>
<p>group by deptno;</p>
<p>第二步：将以上的查询结果当做临时表t，让t表和salgrade表连接，条件是t.avgsal between s.losal and s.hisal</p>
<p>select t.deptno as ‘部门编号’,t.avgsal as ‘平均工资’,s.grade as ‘工资等级’</p>
<p>from (select deptno,avg(sal) as avgsal from emp group by deptno) t</p>
<p>left join salgrade s</p>
<p>on t.avgsal between s.losal and s.hisal;</p>
<p>案列：找出每个部门平均的薪水等级。</p>
<p>第一步：找出每个员工的薪水等级。</p>
<p>select e.ename as ‘姓名’,e.sal as ‘薪水’,e.deptno as ‘部门’,s.grade as ‘薪资等级’</p>
<p>from emp e</p>
<p>left join salgrade s</p>
<p>on e.sal between s.losal and s.hisal;</p>
<p>第二步：基于以上结果，继续按照deptno分组，求grade平均值。</p>
<p>select e.deptno as ‘部门’,avg(s.grade) as ‘平均等级’</p>
<p>from emp e</p>
<p>left join salgrade s</p>
<p>on e.sal between s.losal and s.hisal</p>
<p>group by e.deptno;</p>
<p>在select后面嵌套子查询。</p>
<p>案列：找出每个员工所在的部门名称，要求显示员工名和部门名。</p>
<p>select e.ename,d.dname</p>
<p>from emp e</p>
<p>join dept d</p>
<p>on e.deptno &#x3D; d.deptno</p>
<p>order by e.ename asc;</p>
<p>select e.ename,(select d.dname</p>
<p>from dept d where e.deptno &#x3D; d.deptno) as dname</p>
<p>from emp e</p>
<p>order by e.ename asc;</p>
<p>select ‘SMITH’,20,’RESEARCH’</p>
<p>from emp e;</p>
<h3 id="union-可以将查询结果集相加"><a href="#union-可以将查询结果集相加" class="headerlink" title="union (可以将查询结果集相加)"></a>union (可以将查询结果集相加)</h3><p>案列：找出工作岗位是SALESMAN和MANAGER的员工？</p>
<p>第一种：or</p>
<p>select ename,job</p>
<p>from emp </p>
<p>where job&#x3D;’MANAGER’ or job&#x3D;’SALESMAN’;</p>
<p>第二种：in</p>
<p>select ename,job</p>
<p>from emp </p>
<p>where job in(‘MANAGER’,’SALESMAN’);</p>
<p>第三种：union</p>
<p>select ename,job</p>
<p>from emp </p>
<p>where job&#x3D;’MANAGER’</p>
<p>union</p>
<p>select ename,job</p>
<p>from emp </p>
<p>where job&#x3D;’SALESMAN’;</p>
<p>union的用处：它可以把两张不相干的表中的数据拼接在一起显示？</p>
<p>select ename </p>
<p>from emp</p>
<p>union</p>
<p>select dname</p>
<p>from dept;</p>
<p>注意：union使用时两张表查询的列数必须相同，不然将会出错！</p>
<p>select ename,sal</p>
<p>from emp</p>
<p>union </p>
<p>select dname</p>
<p>from dept;</p>
<p>The used SELECT statements have a different number of columns</p>
<h3 id="limit-重点中的重点，以后分页查询全靠它"><a href="#limit-重点中的重点，以后分页查询全靠它" class="headerlink" title="limit(重点中的重点，以后分页查询全靠它)"></a>limit(重点中的重点，以后分页查询全靠它)</h3><p>limit是mysql特有的，其他数据库中没有，不通用。(Oracle中有一个相同的机制，叫做rownum)</p>
<p>limit取结果集中的部分数据，这是它的作用。</p>
<h4 id="语法机制："><a href="#语法机制：" class="headerlink" title="语法机制："></a>语法机制：</h4><p>limit startIndex,length</p>
<p>​    startIndex表示起始位置，从0开始，0表示第一条数据。</p>
<p>​    length表示取几个</p>
<p>​       </p>
<p>案例：取出工资前5名的员工</p>
<p>select ename,sal</p>
<p>from emp</p>
<p>order by sal desc;</p>
<p>取前5个：</p>
<p>select ename,sal</p>
<p>from emp </p>
<p>order by sal desc</p>
<p>limit 0,5;</p>
<p>从0开始，0表示第一条数据,也可以直接写要查范围的数字，把0省略后默认也是从0开始。</p>
<p>select ename,sal</p>
<p>from emp </p>
<p>order by sal desc</p>
<p>limit 5;</p>
<p>limit是SQL语句最后执行的一个环节：</p>
<p>案列：找出工资排名在第4到第9名的员工？</p>
<p>select ename,sal </p>
<p>from emp </p>
<p>order by sal desc</p>
<p>limit 3,6;</p>
<p>注意：length表示取几个，而不是范围</p>
<h4 id="通用的标准分页SQL？"><a href="#通用的标准分页SQL？" class="headerlink" title="通用的标准分页SQL？"></a>通用的标准分页SQL？</h4><p>每页显示3条记录：</p>
<p>第1页：0,3</p>
<p>第2页：3,3</p>
<p>第3页：6,3</p>
<p>第4页：9,3</p>
<p>第5页：12,3</p>
<p>每页显示pageSize条记录：</p>
<p>第pageNO页：(pageNO -1) * pageSize</p>
<p>pageSize是什么？是每页显示多少条记录</p>
<p>pageNO是什么？显示第几页</p>
<p>java代码{</p>
<p>​    int pageNO &#x3D;2;&#x2F;&#x2F;页码是2</p>
<p>​    int pageSize &#x3D;10;&#x2F;&#x2F;每页显示10条</p>
<p>​    </p>
<p>​    limit (pageNO -1) * pageSize,pageSize</p>
<p>}</p>
<h2 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h2><h3 id="建表语句的语法格式："><a href="#建表语句的语法格式：" class="headerlink" title="建表语句的语法格式："></a>建表语句的语法格式：</h3><p>​    create table 表名(</p>
<p>​           字段名1 数据类型,</p>
<p>​           字段名2 数据类型,</p>
<p>​           字段名3 数据类型,</p>
<p>​           ….</p>
<p>​    );</p>
<h3 id="关于MySQL当中字段的数据类型？以下只说常见的"><a href="#关于MySQL当中字段的数据类型？以下只说常见的" class="headerlink" title="关于MySQL当中字段的数据类型？以下只说常见的"></a>关于MySQL当中字段的数据类型？以下只说常见的</h3><p>int                   整数型(java中的int)</p>
<p>bigint             长整型(java中的long)</p>
<p>float                 浮点型(java中的float double)</p>
<p>char    [<a href="#_msocom_21">A21]</a>              定长字符串[<a href="#_msocom_22">A22]</a> (String)</p>
<p>varchar[<a href="#_msocom_23">A23]</a>               可变长字符串[<a href="#_msocom_24">A24]</a> (StringBuffer&#x2F;StringBuilder) 255</p>
<p>date                  日期类型(对应java中的java.sql.Date类型)</p>
<p>BLOB                 二进制大对象(存储图片。视频等流媒体信息)   Binary Large OBject (对应java中的Object)</p>
<p>CLOB                 字符大对象(存储较大文本，比如，可以存储4G的字符串。)  Character Large Object (对应java中的Object)</p>
<h3 id="char和varchar怎么选择"><a href="#char和varchar怎么选择" class="headerlink" title="char和varchar怎么选择?"></a>char和varchar怎么选择?</h3><p>在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如:</p>
<p>性别、生日等都是采用char.</p>
<p>当一个字段的数据长度不确定，例如:简介、姓名等都是采用varchar。</p>
<h3 id="BLOB和CLOB类型的使用？"><a href="#BLOB和CLOB类型的使用？" class="headerlink" title="BLOB和CLOB类型的使用？"></a>BLOB和CLOB类型的使用？</h3><h3 id="建表语句："><a href="#建表语句：" class="headerlink" title="建表语句："></a>建表语句：</h3><p>表名在数据库当中一般建议以：t_或者tbl_开始。</p>
<p>创建学生表：</p>
<p>​      学生信息包括：</p>
<p>​             学号，姓名，性别，班级编号，生日</p>
<p>​             学号：biging</p>
<p>​             姓名：varchar</p>
<p>​             性别：char</p>
<p>​             班级编号：int</p>
<p>​             生日：char</p>
<p>​             </p>
<p>​      create table t_student(</p>
<p>​         no bigint,</p>
<p>​         name varchar(255),</p>
<p>​         sex char(1),</p>
<p>​         classno varchar(255),</p>
<p>​         birth char(10)</p>
<p>​      );</p>
<p>desc t_student;  查看t_student的表结构</p>
<h3 id="insert语句插入数据"><a href="#insert语句插入数据" class="headerlink" title="insert语句插入数据"></a>insert语句插入数据</h3><p>语法格式：</p>
<p>  insert into 表名(字段名1，字段名2，字段名3，….) </p>
<p>  values(值1，值2，值3，….)</p>
<p>  要求：字段的数量和值的数量相同，并且数据类型要对应相同。</p>
<p>insert into t_student(no,name,sex,classno,birth)</p>
<p>values(1,’张三’,’1’,’高三八班’);</p>
<p>– Column count doesn’t match value count at row 1</p>
<p>insert into t_student(no,name,sex,classno,birth)</p>
<p>values(1,’张三’,’1’,’高三八班’,’1999-10-01’);</p>
<p>select * </p>
<p>from t_student;</p>
<p>insert into t_student(name,no,sex,classno,birth)</p>
<p>values(‘李四’,1,’1’,’高三八班’,’1999-10-01’);</p>
<p>select * </p>
<p>from t_student;</p>
<p>insert into t_student(name)</p>
<p>values(‘王五’);</p>
<p>除了name字段之外，剩下的所有字段自动插入NULL。</p>
<p>select * </p>
<p>from t_student;</p>
<p>insert into t_student(no)</p>
<p>values(3);</p>
<p>select * </p>
<p>from t_student;</p>
<p>drop table if exists t_student;&#x2F;&#x2F;当这个表存在的话删除。</p>
<p>create table t_student(</p>
<p>​         no bigint,</p>
<p>​         name varchar(255),</p>
<p>​         sex char(1)     default[<a href="#_msocom_25">A25]</a> 1,</p>
<p>​         classno varchar(255),</p>
<p>​         birth char(10)</p>
<p>​      );</p>
<p>desc t_student;</p>
<p>insert into t_student(name) </p>
<p>values(‘张三’);</p>
<p>select *</p>
<p>from t_student;</p>
<p>此时sex的默认值为1</p>
<p>需要注意的地方：</p>
<p>  当一条insert语句执行成功之后，表格当中必然会多出一行记录。</p>
<p>  即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行</p>
<p>  insert语句插入数据了，只能使用update进行更新。</p>
<p>insert into t_student</p>
<p>values(1,’张三’,’1’,’高三八班’,’1999-10-01’);</p>
<p>select * </p>
<p>from t_student;</p>
<p>字段可以忽略不写，但是后面的value对数量和顺序都有要求。</p>
<p>insert into t_student</p>
<p>values(1,’张三’,’1’,’高三八班’);</p>
<p>– Column count doesn’t match value count at row 1</p>
<h3 id="一次插入多行数据"><a href="#一次插入多行数据" class="headerlink" title="一次插入多行数据"></a>一次插入多行数据</h3><p>insert into t_student</p>
<p>values(1,’张三’,’1’,’高三八班’,’1999-10-01’),</p>
<p>(2,’张三2’,’3’,’高三八班’,’1999-11-01’);</p>
<p>select * </p>
<p>from t_student;</p>
<h3 id="表的复制"><a href="#表的复制" class="headerlink" title="表的复制"></a>表的复制</h3><p>create table emp1 as select * from emp;</p>
<p>select *</p>
<p>from emp1;</p>
<p>create table emp2 as select ename,job,sal from emp;</p>
<p>select *</p>
<p>from emp2;</p>
<p>语法：</p>
<p>  create table 表名 as select语句；</p>
<p>  将查询结果当做表创建出来。</p>
<h3 id="将查询结果插入到一张表中？-A26"><a href="#将查询结果插入到一张表中？-A26" class="headerlink" title="将查询结果插入到一张表中？[A26]"></a>将查询结果插入到一张表中？[<a href="#_msocom_26">A26]</a></h3><p>create table dept1 as select * from dept;</p>
<p>insert into dept1 select * from dept;</p>
<p>select * from dept1;</p>
<h3 id="修改数据：update"><a href="#修改数据：update" class="headerlink" title="修改数据：update"></a>修改数据：update</h3><h4 id="语法格式："><a href="#语法格式：" class="headerlink" title="语法格式："></a>语法格式：</h4><p>  update 表名 set 字段名1&#x3D;值,字段名2&#x3D;值2 …. where 条件;</p>
<p>  注意：没有条件整张表数据全部都会更新</p>
<p>  案例：将部门10的LOC修改为SHANGAI，将部门名称修改为RENSHIBU</p>
<p>  update dept1 set loc&#x3D;’SHANGAI’,dname &#x3D;’RENSHIBU’</p>
<p>  where deptno&#x3D;10;</p>
<p>  select *</p>
<p>  from dept1;</p>
<p>更新所有记录</p>
<p>  update dept1 set loc &#x3D;’x’,dname &#x3D;’y’;</p>
<p>  select *</p>
<p>  from dept1;</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><h4 id="语法格式：-1"><a href="#语法格式：-1" class="headerlink" title="语法格式："></a>语法格式：</h4><p>delete from 表名 where 条件;</p>
<p>注意：没有条件全部删除。</p>
<p>删除10部门数据？</p>
<p>  delete from dept1 </p>
<p>  where deptno &#x3D;10;</p>
<p>  select *</p>
<p>  from dept1;</p>
<p>删除所有记录？</p>
<p>​      delete from dept1;</p>
<h3 id="怎么删除大表的数据？-重点"><a href="#怎么删除大表的数据？-重点" class="headerlink" title="怎么删除大表的数据？(重点)"></a>怎么删除大表的数据？(重点)</h3><p>  truncate table 表名; &#x2F;&#x2F;表被截断，不可回滚。数据将永久丢失。</p>
<h3 id="删除表？"><a href="#删除表？" class="headerlink" title="删除表？"></a>删除表？</h3><p>  drop table 表名;&#x2F;&#x2F;这个通用。</p>
<p>  drop table if exists 表名;&#x2F;&#x2F;Oracle不支持这种写法。</p>
<h3 id="表结构修改"><a href="#表结构修改" class="headerlink" title="表结构修改"></a>表结构修改</h3><p>对于表结构的修改，这里不讲了，使用工具完成即可，因为在实际开发中表一旦设计好之后，</p>
<p>对表结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使需要修改表结构，</p>
<p>我们也可以直接使用工具操作。修改表结构的语句不会出现在Java代码当中。</p>
<p>出现在java代码当中的sql包括: insert delete update select(这些都是对表中的数据进行操作。)</p>
<h4 id="增删改查有一个术语：CRUD操作"><a href="#增删改查有一个术语：CRUD操作" class="headerlink" title="增删改查有一个术语：CRUD操作"></a>增删改查有一个术语：CRUD操作</h4><p>Create(增) Retrieve(检索) Update(修改) Delete(删除)</p>
<h3 id="什么是约束？常见的约束有哪些呢？"><a href="#什么是约束？常见的约束有哪些呢？" class="headerlink" title="什么是约束？常见的约束有哪些呢？"></a>什么是约束？常见的约束有哪些呢？</h3><p>在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的</p>
<p>合法性、有效性、完整性。</p>
<h4 id="常见的约束有哪些呢？"><a href="#常见的约束有哪些呢？" class="headerlink" title="常见的约束有哪些呢？"></a>常见的约束有哪些呢？</h4><p>  非空约束(not nul1):约束的字段不能为NULL</p>
<p>  唯一约束(unique):约束的字段不能重复</p>
<p>  主键约束(primary key):约束的字段既不能为NULL，也不能重复（简称PK)</p>
<p>  外键约束(foreign)：…(简称PK)</p>
<p>  检查约束(check):注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。</p>
<h5 id="非空约束-not-null-A27"><a href="#非空约束-not-null-A27" class="headerlink" title="非空约束(not null[A27] )"></a>非空约束(not null[<a href="#_msocom_27">A27]</a> )</h5><p>drop table if exists t_user;</p>
<p>create table t_user(</p>
<p>  id int,</p>
<p>  username varchar(255) not null,</p>
<p>  password varchar(255) </p>
<p>);</p>
<p>insert into t_user(id,password)</p>
<p>values(1,’123’);</p>
<p>设了非空约束的字段不能为空</p>
<p>insert into t_user(id,username,password)</p>
<p>values(1,’张三’,’123’);</p>
<p>select *</p>
<p>from t_user;</p>
<h1 id="MySQL-day03"><a href="#MySQL-day03" class="headerlink" title="MySQL day03"></a>MySQL day03</h1><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="唯一性约束-unique-："><a href="#唯一性约束-unique-：" class="headerlink" title="唯一性约束( unique )："></a>唯一性约束( unique )：</h3><p>唯一约束修饰的字段具有唯一性，不能重复。但可以为NULL[<a href="#_msocom_28">A28]</a> 。</p>
<p>案例：给某一列字段添加unique</p>
<p>drop table if exists t_user;</p>
<p>create table t_user(</p>
<p>id int,</p>
<p>username varchar(255) unique &#x2F;&#x2F;列级约束</p>
<p>);</p>
<p>insert into t_user</p>
<p>values (1,’张三’);</p>
<p>– 尝试插入重复数据</p>
<p>insert into t_user</p>
<p>values (1,’张三’);</p>
<p>insert into t_user(id) </p>
<p>values (2);</p>
<p>insert into t_user(id) </p>
<p>values (3);</p>
<p>insert into t_user(id) </p>
<p>values (4);</p>
<p>select *</p>
<p>from t_user;</p>
<p>案例：给两个列或者多个列添加unique</p>
<p>drop table if exists t_user;</p>
<p>create table t_user(</p>
<p>id int,</p>
<p>usercode varchar(255),</p>
<p>username varchar(255),</p>
<p>unique(usercode,username) &#x2F;&#x2F;多个字段联合起来添加一个约束unique(表级约束)</p>
<p>);</p>
<p>insert into t_user</p>
<p>values (1,’111’,’张三’);</p>
<p>insert into t_user</p>
<p>values (2,’111’,’李四’);</p>
<p>insert into t_user</p>
<p>values (3,’222’,’张三’);</p>
<p>select *</p>
<p>from t_user;</p>
<p>insert into t_user</p>
<p>values (4,’111’,’张三’);</p>
<p>drop table if exists t_user;</p>
<p>create table t_user(</p>
<p>id int,</p>
<p>usercode varchar(255) unique,</p>
<p>username varchar(255) unique</p>
<p>);</p>
<p>insert into t_user</p>
<p>values (1,’111’,’张三’);</p>
<p>insert into t_user</p>
<p>values (2,’111’,’张三’);</p>
<h5 id="列级约束和表级约束的区别"><a href="#列级约束和表级约束的区别" class="headerlink" title="列级约束和表级约束的区别"></a>列级约束和表级约束的区别</h5><p>列级约束就是对该字段进行约束，这个字段满足要求就进行约束</p>
<p>表级约束就是对多个字段进行约束，多个字段拼起来满足要求就进行约束</p>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><h4 id="怎么给一张表添加主键约束呢？-A29"><a href="#怎么给一张表添加主键约束呢？-A29" class="headerlink" title="怎么给一张表添加主键约束呢？[A29]"></a>怎么给一张表添加主键约束呢？[<a href="#_msocom_29">A29]</a></h4><p>drop table if exists t_user;</p>
<p>create table t_user(</p>
<p>id int primary key, &#x2F;&#x2F;列级约束</p>
<p>username varchar(255) ,</p>
<p>email varchar(255) </p>
<p>);</p>
<p>insert into t_user(id,username,email)</p>
<p>values(1,’张三’,‘<a href="mailto:&#122;&#115;&#x40;&#49;&#x32;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#122;&#115;&#x40;&#49;&#x32;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a>‘);</p>
<p>insert into t_user(id,username,email)</p>
<p>values(2,’李四’,‘<a href="mailto:&#x6c;&#115;&#x40;&#x31;&#50;&#51;&#46;&#99;&#111;&#109;">&#x6c;&#115;&#x40;&#x31;&#50;&#51;&#46;&#99;&#111;&#109;</a>‘);</p>
<p>insert into t_user(id,username,email)</p>
<p>values(3,’王五’,‘<a href="mailto:&#119;&#x77;&#64;&#x31;&#x32;&#x33;&#46;&#x63;&#x6f;&#109;">&#119;&#x77;&#64;&#x31;&#x32;&#x33;&#46;&#x63;&#x6f;&#109;</a>‘);</p>
<p>select *</p>
<p>from t_user;</p>
<p>insert into t_user(id,username,email)</p>
<p>values(1,’小舞’,‘<a href="mailto:&#x78;&#x77;&#x40;&#49;&#50;&#51;&#46;&#99;&#x6f;&#x6d;">&#x78;&#x77;&#x40;&#49;&#50;&#51;&#46;&#99;&#x6f;&#x6d;</a>‘);</p>
<p>insert into t_user(username,email)</p>
<p>values(‘小舞’,‘<a href="mailto:&#x78;&#x77;&#x40;&#x31;&#50;&#x33;&#46;&#99;&#x6f;&#109;">&#x78;&#x77;&#x40;&#x31;&#50;&#x33;&#46;&#99;&#x6f;&#109;</a>‘);</p>
<p>根据以上的测试得出: id是主键，因为添加了主键约束，主键字段中的数据不能为NULL</p>
<p>主键的特点:不能为NULL，也不能重复。</p>
<h4 id="主键相关的术语"><a href="#主键相关的术语" class="headerlink" title="主键相关的术语?"></a>主键相关的术语?</h4><p>主键约束: primary key</p>
<p>主键字段: id字段添加primary key之后，id叫做主键字段</p>
<p>主键值: id字段中的每一个值都是主键值</p>
<h4 id="主键有什么作用"><a href="#主键有什么作用" class="headerlink" title="主键有什么作用?"></a>主键有什么作用?</h4><p>-表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。</p>
<p>-主键的作用: 主键值是这行记录在这张表当中的唯一标识。(就像一个人的身份证号码一样。)</p>
<h4 id="主键的分类"><a href="#主键的分类" class="headerlink" title="主键的分类?"></a>主键的分类?</h4><p>根据主键字段的字段数量来划分:</p>
<p>单一主键（推荐的,常用的。)</p>
<p>复合主键(多个字段联合起来添加一个主键约束)(复合主键不建议使用，因为复合主键违背三范式。)</p>
<p>根据主键性质来划分:</p>
<p>自然主键[<a href="#_msocom_30">A30]</a> ：主键值最好就是一个和业务没有任何关系的自然数。(推荐使用)</p>
<p>业务主键:主键值和系统的业务挂钩，例如:拿着银行卡的卡号做主键，拿着身份证号码作为主键。(不推荐用，建议业务使用唯一性约束)</p>
<p>最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。</p>
<p>一张表的主键约束只能有1个。(必须记住)</p>
<p>表级约束的方式就是换成在字段的最后面写primary key(字段名)</p>
<p>mysql提供主键值自增：</p>
<p>drop table if exists t_user;</p>
<p>create table t_user(</p>
<p>id int primary key auto_increment,&#x2F;&#x2F;id字段自动维护一个自增的数字，从1开始，以1递增。</p>
<p>username varchar(255)</p>
<p>);</p>
<p>insert into t_user(username)</p>
<p>values (‘a’);</p>
<p>insert into t_user(username)</p>
<p>values (‘b’);</p>
<p>insert into t_user(username)</p>
<p>values (‘c’);</p>
<p>insert into t_user(username)</p>
<p>values (‘d’);</p>
<p>select *</p>
<p>from t_user;</p>
<p>提示：Oracle当中也提供了一个自增机制，叫做：序列(sequence)对象。</p>
<h3 id="外键约束-A31"><a href="#外键约束-A31" class="headerlink" title="外键约束[A31]"></a>外键约束[<a href="#_msocom_31">A31]</a></h3><h4 id="关于外键约束的相关术语"><a href="#关于外键约束的相关术语" class="headerlink" title="关于外键约束的相关术语:"></a>关于外键约束的相关术语:</h4><p>外键约束:foreign key</p>
<p>外键字段:添加有外键约束的字段</p>
<p>外键值:外键字段中的每一个值。</p>
<p>业务背景:</p>
<p>请设计数据库表,用来维护学生和班级的信息?</p>
<p>第一种方案：一张表存储所有数据</p>
<p>缺点：数据冗余（不推荐）</p>
<p>第二种方案：两张表（班级表和学生表）</p>
<p>将以上表的建表语句写出来:</p>
<p>t_student中的classno字段引用t _class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。</p>
<p>顺序要求:</p>
<p>删除数据的时候,先删除子表,再删除父表。</p>
<p>添加数据的时候，先添加父表,在添加子表。</p>
<p>创建表的时候,先创建父表，再创建子表。</p>
<p>删除表的时候,先删除子表，在删除父表。</p>
<p>drop table if exists t_student;</p>
<p>drop table if exists t_class;</p>
<p>create table t_class(</p>
<p>cno int,</p>
<p>cname varchar(255),</p>
<p>primary key(cno)</p>
<p>);</p>
<p>create table t_student(</p>
<p>sno int,</p>
<p>sname varchar(255),</p>
<p>classno int,</p>
<p>foreign key(classno) references t_class(cno)</p>
<p>);</p>
<p>insert into t_class</p>
<p>values (</p>
<p>101,’高三一班’);</p>
<p>insert into t_class</p>
<p>values (</p>
<p>102,’高三二班’);</p>
<p>insert into t_student</p>
<p>values (</p>
<p>1,’张三1’,101</p>
<p>);</p>
<p>insert into t_student</p>
<p>values (</p>
<p>2,’张三2’,102</p>
<p>);</p>
<p>insert into t_student</p>
<p>values (</p>
<p>3,’张三3’,101</p>
<p>);</p>
<p>insert into t_student</p>
<p>values (</p>
<p>4,’张三4’,102</p>
<p>);</p>
<p>insert into t_student</p>
<p>values (</p>
<p>5,’张三5’,101</p>
<p>);</p>
<p>select *</p>
<p>from t_class;</p>
<p>select *</p>
<p>from t_student;</p>
<p>insert into t_student</p>
<p>valuse(</p>
<p>6,’李四’,103</p>
<p>);</p>
<p>&gt; 1452 - Cannot add or update a child row: a foreign key constraint fails (<code>bjpowernode</code>.<code>t_student</code>, CONSTRAINT <code>t_student_ibfk_1</code> FOREIGN KEY (<code>classno</code>) REFERENCES <code>t_class</code> (<code>cno</code>))</p>
<p>外键值可以为NULL</p>
<p>insert into t_student(sno,sname)</p>
<p>values(</p>
<p>8,’李四’</p>
<p>);</p>
<p>select *</p>
<p>from t_student;</p>
<p>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？</p>
<p>注意：被引用的字段不一定是主键，但至少具有unique约束。</p>
<h3 id="存储引擎-整个内容属于了解内容"><a href="#存储引擎-整个内容属于了解内容" class="headerlink" title="存储引擎?(整个内容属于了解内容)"></a>存储引擎?(整个内容属于了解内容)</h3><h4 id="完整的建表语句"><a href="#完整的建表语句" class="headerlink" title="完整的建表语句"></a>完整的建表语句</h4><p>CREATE TABLE <code>t_x</code>(</p>
<p><code>id</code> int (11) DEFAULT NULL</p>
<p>)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 ;</p>
<p>注意:在MySQL当中，凡是标识符是可以使用飘号括起来的。但是最好别用，因为不通用.</p>
<p>建表的时候可以指定存储引擎,也可以指定字符集。</p>
<p>mysql默认使用的存储引擎是InnoDB方式。</p>
<p>默认采用的字符集是UTF8</p>
<h4 id="什么是存储引擎呢"><a href="#什么是存储引擎呢" class="headerlink" title="什么是存储引擎呢?"></a>什么是存储引擎呢?</h4><p>存储引擎这个名字只有在mysql中存在。</p>
<p>(oracle中有对应的机制，但是不叫做存储引擎，Oracle中没有特殊的名字，就是”表的存储方式”)</p>
<p>mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。</p>
<p>每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p>
<p>查看当前mysql支持的存储引擎？</p>
<p>Show engines \G</p>
<p>Mysql 5.5.36版本支持的存储引擎有9个：</p>
<p>*************************** 1. row ***************************</p>
<p>Engine: InnoDB</p>
<p>Support: DEFAULT</p>
<p>Comment: Supports transactions, row-level locking, and foreign keys</p>
<p>Transactions: YES</p>
<p>XA: YES</p>
<p>Savepoints: YES</p>
<p>*************************** 2. row ***************************</p>
<p>Engine: MRG_MYISAM</p>
<p>Support: YES</p>
<p>Comment: Collection of identical MyISAM tables</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>*************************** 3. row ***************************</p>
<p>Engine: MEMORY[<a href="#_msocom_32">A32]</a> </p>
<p>Support: YES</p>
<p>Comment: Hash based, stored in memory, useful for temporary tables</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>*************************** 4. row ***************************</p>
<p>Engine: BLACKHOLE</p>
<p>Support: YES</p>
<p>Comment: &#x2F;dev&#x2F;null storage engine (anything you write to it disappears)</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>*************************** 5. row ***************************</p>
<p>Engine: MyISAM</p>
<p>Support: YES</p>
<p>Comment: MyISAM storage engine</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>*************************** 6. row ***************************</p>
<p>Engine: CSV</p>
<p>Support: YES</p>
<p>Comment: CSV storage engine</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>*************************** 7. row ***************************</p>
<p>Engine: ARCHIVE</p>
<p>Support: YES</p>
<p>Comment: Archive storage engine</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>*************************** 8. row ***************************</p>
<p>Engine: PERFORMANCE_SCHEMA</p>
<p>Support: YES</p>
<p>Comment: Performance Schema</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>*************************** 9. row ***************************</p>
<p>Engine: FEDERATED</p>
<p>Support: NO</p>
<p>Comment: Federated MySQL storage engine</p>
<p>Transactions: NULL</p>
<p>XA: NULL</p>
<p>Savepoints: NULL</p>
<p>常用的存储引擎：</p>
<p>Engine: MEMORY[<a href="#_msocom_33">A33]</a> </p>
<p>Support: YES</p>
<p>Comment: Hash based, stored in memory, useful for temporary tables</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>MyISAM这种存储引擎不支持事务。</p>
<p>MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。</p>
<p>MyISAM采用三个文件组织一张表:</p>
<p>xxx.frm (存储格式的文件)</p>
<p>xxx. MYD (存储表中数据的文件)</p>
<p>xxx.MYI （存储表中索引的文件)</p>
<p>优点:可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。</p>
<p>缺点:不支持事务。</p>
<p>-——————————————————————————</p>
<p>Engine: InnoDB[<a href="#_msocom_34">A34]</a> [<a href="#_msocom_35">A35]</a> </p>
<p>Support: DEFAULT</p>
<p>Comment: Supports transactions, row-level locking, and foreign keys</p>
<p>Transactions: YES</p>
<p>XA: YES</p>
<p>Savepoints: YES</p>
<p>优点:支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。</p>
<p>表的结构存储在xxx.frm文件中</p>
<p>数据存储在tablespace这样的表空间中(逻辑概念),无法被压缩,无法转换成只读。</p>
<p>这种InnoDB存储引擎在MysQL数据库崩溃之后提供自动恢复机制。</p>
<p>InnoDB支持级联删除和级联更新[<a href="#_msocom_36">A36]</a> 。</p>
<p>-——————————————————————————</p>
<p>Engine: MEMORY[<a href="#_msocom_37">A37]</a> [<a href="#_msocom_38">A38]</a> </p>
<p>Support: YES    </p>
<p>Comment: Hash based, stored in memory, useful for temporary tables</p>
<p>Transactions: NO</p>
<p>XA: NO</p>
<p>Savepoints: NO</p>
<p>缺点:不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。</p>
<p>优点:查询速度最快。</p>
<p>以前叫做HEPA引擎。</p>
<p>事务( Transaction)</p>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h2><p>一个事务是一个完整的业务逻辑单元,不可再分。</p>
<p>比如:银行账户转账，从A账户向B账户转账10000.需要执行两条update语句:</p>
<p>update t_act set balance &#x3D; balance - 10000 where actno &#x3D; ‘act-001’;</p>
<p>update t_act set balance &#x3D; balance +1000o where actno &#x3D; ‘act-002’;</p>
<p>以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。</p>
<p>要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机</p>
<p>制”。</p>
<p>和事务相关的语句只有:DML语句。(insert delete update)</p>
<p>为什么?因为它们这三个语句都是和数据库表当中的”数据”相关的.</p>
<p>事务的存在是为了保证数据的完整性,安全性。</p>
<p>假设所有的业务都能使用1条DM语句搞定，还需要事务机制吗?</p>
<p>不需要事务。</p>
<p>但实际情况不是这样的，通常一个”事儿(事务【业务】)”需要多条DM语句共同联合完成。</p>
<h3 id="事务语句"><a href="#事务语句" class="headerlink" title="事务语句"></a>事务语句</h3><p>Commit 事务提交</p>
<p>Rollback 事务回滚</p>
<p>Savepoint[<a href="#_msocom_39">A39]</a> 事务保存点</p>
<h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性?"></a>事务的特性?</h3><p>事务包括四大特性:ACID</p>
<p>A:原子性:事务是最小的工作单元，不可再分。</p>
<p>C:一致性:事务必须保证多条DM语句同时成功或者同时失败。</p>
<p>I:隔离性:事务A与事务B之间具有隔离。</p>
<p>D:持久性:持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</p>
<h3 id="关于事务之间的隔离性"><a href="#关于事务之间的隔离性" class="headerlink" title="关于事务之间的隔离性"></a>关于事务之间的隔离性</h3><p>事务隔离性存在隔离级别,理论上隔离级别包括4个:</p>
<p>第一级别:读未提交[<a href="#_msocom_40">A40]</a> (read uncommitted)</p>
<p>对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。</p>
<p>读未提交存在脏读(Dirty Read）现象:表示读到了脏的数据。</p>
<p>第二级别:读已提交[<a href="#_msocom_41">A41]</a> (read committed)</p>
<p>对方事务提交之后的数据我方可以读取到。</p>
<p>这种隔离级别解决了:脏读现象没有了</p>
<p>读己提交存在的问题是:不可重复读。</p>
<p>第三级别:可重复读[<a href="#_msocom_42">A42]</a> (repeatable read)</p>
<p>这种隔离级别解决了:不可重复读问题。</p>
<p>​      这种隔离级别存在的问题是:读取到的数据是幻象。</p>
<p>​    第四级别:序列化读&#x2F;串行化读</p>
<p>解决了所有问题。</p>
<p>效率低。需要事务排队。</p>
<p>oracle数据库默认的隔离级别是:读己提交。</p>
<p>mysql数据库默认的隔离级别是:可重复读。</p>
<h3 id="演示事务"><a href="#演示事务" class="headerlink" title="演示事务"></a>演示事务</h3><p>mysql事务默认情况下是自动提交的。</p>
<p>(什么是自动提交？只要执行任意一条DML语句则提交一次。)</p>
<p>怎么关闭自动提交?</p>
<p>start transaction ;</p>
<h3 id="使用两个事务演示以上的隔离级别"><a href="#使用两个事务演示以上的隔离级别" class="headerlink" title="使用两个事务演示以上的隔离级别"></a>使用两个事务演示以上的隔离级别</h3><p>第一:演示read uncommitted</p>
<p>设置事务的全局隔离级别: </p>
<p>set global transaction isolation level 隔离级别;</p>
<p>查看事务的全局隔离级别：</p>
<p>​    Select @@global.tx_isolation;</p>
<p>第二：演示 read committed</p>
<p>第三：演示 repeatable read</p>
<p>第四：演示 serializable</p>
<p>Mysql远程登录：mysql -h192.168.151.18 –root –p密码</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>​    </p>
<h3 id="什么是索引？有什么用？"><a href="#什么是索引？有什么用？" class="headerlink" title="什么是索引？有什么用？"></a>什么是索引？有什么用？</h3><p>​       索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。</p>
<p>​       在数据库方面，查询一张表的时候有两种检索方式：</p>
<p>​           第一种方式：全表扫描</p>
<p>​           第二种方式：根据索引检索（效率很高）</p>
<p>​       索引为什么可以提高检索效率呢？</p>
<p>​           其实最根本的原理是缩小了扫描的范围。</p>
<p>​       </p>
<p>​       索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中</p>
<p>​       的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改</p>
<p>​       这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p>
<p>​       添加索引是给某一个字段，或者说某些字段添加索引。</p>
<p>​       select ename,sal from emp where ename &#x3D; ‘SMITH’;</p>
<p>​       当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。</p>
<p>​       当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。</p>
<p>​    </p>
<h3 id="怎么创建索引对象？怎么删除索引对象？"><a href="#怎么创建索引对象？怎么删除索引对象？" class="headerlink" title="怎么创建索引对象？怎么删除索引对象？"></a>怎么创建索引对象？怎么删除索引对象？</h3><p>​       创建索引对象：</p>
<p>​           create index 索引名称 on 表名(字段名);</p>
<p>​       删除索引对象：</p>
<p>​           drop index 索引名称 on 表名;</p>
<h3 id="什么时候考虑给字段添加索引？（满足什么条件）"><a href="#什么时候考虑给字段添加索引？（满足什么条件）" class="headerlink" title="什么时候考虑给字段添加索引？（满足什么条件）"></a>什么时候考虑给字段添加索引？（满足什么条件）</h3><p>​       * 数据量庞大。（根据客户的需求，根据线上的环境）</p>
<p>​       * 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）</p>
<p>​       * 该字段经常出现在where子句中。（经常根据哪个字段查询）</p>
<p>​    </p>
<p>注意：主键和具有unique约束的字段自动会添加索引。</p>
<p>​            根据主键查询效率较高。尽量根据主键检索。</p>
<h3 id="查看SQL语句的执行计划："><a href="#查看SQL语句的执行计划：" class="headerlink" title="查看SQL语句的执行计划："></a>查看SQL语句的执行计划：</h3><p>Explain +sql语句；</p>
<p>explain select ename,sal </p>
<p>from emp</p>
<p>where sal&#x3D;5000;</p>
<h3 id="给薪资sal字段添加索引："><a href="#给薪资sal字段添加索引：" class="headerlink" title="给薪资sal字段添加索引："></a>给薪资sal字段添加索引：</h3><p>Create index 索引名on 表名(字段名)；</p>
<p>create index emp_sal_index on emp(sal);</p>
<p>explain select ename,sal </p>
<p>from emp</p>
<p>where sal&#x3D;5000;</p>
<h3 id="索引底层实现图解："><a href="#索引底层实现图解：" class="headerlink" title="索引底层实现图解："></a>索引底层实现图解：</h3><p>索引底层采用的数据结构是：B + Tree</p>
<p>​    </p>
<h3 id="索引的实现原理？"><a href="#索引的实现原理？" class="headerlink" title="索引的实现原理？"></a>索引的实现原理？</h3><p>​       通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，</p>
<p>​       最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。</p>
<p>​           select ename from emp where ename &#x3D; ‘SMITH’;</p>
<p>​           通过索引转换为：</p>
<p>​           select ename from emp where 物理地址 &#x3D; 0x3;</p>
<h3 id="索引的分类？"><a href="#索引的分类？" class="headerlink" title="索引的分类？"></a>索引的分类？</h3><p>​       单一索引：给单个字段添加索引</p>
<p>​       复合索引: 给多个字段联合起来添加1个索引</p>
<p>​       主键索引：主键上会自动添加索引</p>
<p>​       唯一索引：有unique约束的字段上会自动添加索引</p>
<p>​       ….</p>
<p>​    </p>
<h3 id="索引什么时候失效？"><a href="#索引什么时候失效？" class="headerlink" title="索引什么时候失效？"></a>索引什么时候失效？</h3><p>​       select ename from emp where ename like ‘%A%’;</p>
<p>​       模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。</p>
<h3 id="Mysql索引管理"><a href="#Mysql索引管理" class="headerlink" title="Mysql索引管理"></a>Mysql索引管理</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>\1. 索引的功能就是加速查找</p>
<p>\2. mysql中的primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束的功能</p>
<h4 id="MySQL的索引分类"><a href="#MySQL的索引分类" class="headerlink" title="MySQL的索引分类"></a>MySQL的索引分类</h4><h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><p>1.普通索引index :加速查找</p>
<p>2.唯一索引</p>
<p>  主键索引：primary key ：加速查找+约束（不为空且唯一）</p>
<p>  唯一索引：unique：加速查找+约束 （唯一）</p>
<p>3.联合索引</p>
<p>  -primary key(id,name):联合主键索引</p>
<p>  -unique(id,name):联合唯一索引</p>
<p>  -index(id,name):联合普通索引</p>
<p>4.全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。</p>
<p>5.空间索引spatial :了解就好，几乎不用</p>
<h5 id="索引的两大类型hash与btree"><a href="#索引的两大类型hash与btree" class="headerlink" title="索引的两大类型hash与btree"></a>索引的两大类型hash与btree</h5><p>我们可以在创建上述索引的时候，为其指定索引类型，分两类</p>
<p>hash类型的索引：查询单条快，范围查询慢</p>
<p>btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）</p>
<p>不同的存储引擎支持的索引类型也不一样</p>
<p>InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；</p>
<p>Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；</p>
<p>NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；</p>
<h5 id="创建-x2F-删除索引的语法"><a href="#创建-x2F-删除索引的语法" class="headerlink" title="创建&#x2F;删除索引的语法"></a>创建&#x2F;删除索引的语法</h5><h6 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h6><p>  -在创建表时就创建（需要注意的几点）</p>
<p>  create table s1(</p>
<p>  id int ,#可以在这加primary key</p>
<p>  #id int index #不可以这样加索引，因为index只是索引，没有约束一说，</p>
<p>  #不能像主键，还有唯一约束一样，在定义字段的时候加索引</p>
<p>  name char(20),</p>
<p>  age int,</p>
<p>  email varchar(30)</p>
<p>  #primary key(id) #也可以在这加</p>
<p>  index(id) #可以这样加</p>
<p>  );</p>
<p>  -在创建表后在创建</p>
<p>  create index name on s1(name); #添加普通索引</p>
<p>  create unique age on s1(age);添加唯一索引</p>
<p>  alter table s1 add primary key(id); #添加住建索引，也就是给id字段增加一个主键约束</p>
<p>  create index name on s1(id,name); #添加普通联合索引</p>
<h6 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h6><p>  drop index id on s1;</p>
<p>  drop index name on s1; #删除普通索引</p>
<p>  drop index age on s1; #删除唯一索引，就和普通索引一样，不用在index前加unique来删，直接就可以删了</p>
<p>alter table s1 drop primary key; #删除主键(因为它添加的时候是按照alter来增加的，那么我们也用alter来删)</p>
<h2 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h2><p>​    </p>
<h3 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h3><p>​       站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。</p>
<p>​    </p>
<p>怎么创建视图？怎么删除视图？</p>
<p>​       create view myview as select empno,ename from emp;</p>
<p>​       drop view myview;</p>
<p>​       注意：只有DQL语句才能以视图对象的方式创建出来。</p>
<p>​    </p>
<p>对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）</p>
<p>可以对视图进行CRUD操作。</p>
<h3 id="面向视图操作？"><a href="#面向视图操作？" class="headerlink" title="面向视图操作？"></a>面向视图操作？</h3><p>​       mysql&gt; select * from myview;</p>
<p>​     </p>
<p>​       create table emp_bak as select * from emp;</p>
<p>​       create view myview1 as select empno,ename,sal from emp_bak;</p>
<p>​       update myview1 set ename&#x3D;’hehe’,sal&#x3D;1 where empno &#x3D; 7369; &#x2F;&#x2F; 通过视图修改原表数据。</p>
<p>​       delete from myview1 where empno &#x3D; 7369; &#x2F;&#x2F; 通过视图删除原表数据。</p>
<p>​    </p>
<h3 id="视图的作用？"><a href="#视图的作用？" class="headerlink" title="视图的作用？"></a>视图的作用？</h3><p>​       视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员</p>
<p>​       只对视图对象进行CRUD。</p>
<h2 id="DBA命令"><a href="#DBA命令" class="headerlink" title="DBA命令"></a>DBA命令</h2><p>​    </p>
<h3 id="将数据库当中的数据导出"><a href="#将数据库当中的数据导出" class="headerlink" title="将数据库当中的数据导出"></a>将数据库当中的数据导出</h3><p>​    在windows的dos命令窗口中执行：（导出整个库）</p>
<p>​       mysqldump 数据库名&gt;磁盘名:\数据库名.sql -uroot –p密码</p>
<p>mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p333</p>
<p>​       在windows的dos命令窗口中执行：（导出指定数据库当中的指定表）</p>
<p>​           mysqldump 数据库名表名&gt;D:\数据库名.sql -uroot –p123</p>
<p>​           mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot –p123</p>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>​       create database 数据库名;</p>
<p>​       use 数据库名;</p>
<p>​       source 文件路径</p>
<h2 id="数据库设计三范式（重点内容，面试经常问）"><a href="#数据库设计三范式（重点内容，面试经常问）" class="headerlink" title="数据库设计三范式（重点内容，面试经常问）"></a>数据库设计三范式（重点内容，面试经常问）</h2><h3 id="什么是设计范式？"><a href="#什么是设计范式？" class="headerlink" title="什么是设计范式？"></a>什么是设计范式？</h3><p>​       设计表的依据。按照这个三范式设计的表不会出现数据冗余。</p>
<p>​       三范式最终目的都是为了解决数据冗余。</p>
<h3 id="三范式都是哪些？"><a href="#三范式都是哪些？" class="headerlink" title="三范式都是哪些？"></a>三范式都是哪些？</h3><h4 id="第一范式："><a href="#第一范式：" class="headerlink" title="第一范式："></a>第一范式：</h4><p>任何一张表都应该有主键，并且每一个字段原子性不可再分。</p>
<h4 id="第二范式："><a href="#第二范式：" class="headerlink" title="第二范式："></a>第二范式：</h4><p>建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。</p>
<p>​           多对多？三张表，关系表两个外键。</p>
<p>​           t_student学生表</p>
<p>​           sno(pk)     sname</p>
<p>​           -——————</p>
<p>​           1             张三</p>
<p>​           2             李四</p>
<p>​           3             王五</p>
<p>​           t_teacher 讲师表</p>
<p>​           tno(pk)     tname</p>
<p>​           -——————–</p>
<p>​           1             王老师</p>
<p>​           2             张老师</p>
<p>​           3             李老师</p>
<p>​           t_student_teacher_relation 学生讲师关系表</p>
<p>​           id(pk)      sno(fk)     tno(fk)</p>
<p>​           -———————————</p>
<p>​           1             1             3</p>
<p>​           2             1             1</p>
<p>​           3             2             2</p>
<p>​           4             2             3</p>
<p>​           5             3             1</p>
<p>​           6             3             3</p>
<p>​       </p>
<h4 id="第三范式："><a href="#第三范式：" class="headerlink" title="第三范式："></a>第三范式：</h4><p>建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</p>
<p>​           一对多？两张表，多的表加外键。</p>
<p>​           班级t_class</p>
<p>​           cno(pk)        cname</p>
<p>​           -————————-</p>
<p>​           1                 班级1</p>
<p>​           2                 班级2</p>
<p>​           学生t_student</p>
<p>​           sno(pk)        sname             classno(fk)</p>
<p>​           -——————————————–</p>
<p>​           101           张1           1</p>
<p>​           102           张2           1</p>
<p>​           103           张3           2</p>
<p>​           104           张4           2</p>
<p>​           105           张5           2</p>
<p>​       </p>
<p>​       提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</p>
<h3 id="一对一怎么设计？"><a href="#一对一怎么设计？" class="headerlink" title="一对一怎么设计？"></a>一对一怎么设计？</h3><h4 id="一对一设计有两种方案：主键共享"><a href="#一对一设计有两种方案：主键共享" class="headerlink" title="一对一设计有两种方案：主键共享"></a>一对一设计有两种方案：主键共享</h4><p>​           t_user_login 用户登录表</p>
<p>​           id(pk)      username          password</p>
<p>​           -————————————-</p>
<p>​           1             zs                 123</p>
<p>​           2             ls                 456</p>
<p>​           t_user_detail 用户详细信息表</p>
<p>​           id(pk+fk)   realname          tel         ….</p>
<p>​           -———————————————–</p>
<p>​           1             张三               1111111111</p>
<p>​           2             李四               1111415621</p>
<h4 id="一对一设计有两种方案：外键唯一。"><a href="#一对一设计有两种方案：外键唯一。" class="headerlink" title="一对一设计有两种方案：外键唯一。"></a>一对一设计有两种方案：外键唯一。</h4><p>​           t_user_login 用户登录表</p>
<p>​           id(pk)      username          password</p>
<p>​           -————————————-</p>
<p>​           1             zs                 123</p>
<p>​           2             ls                 456</p>
<p>​           t_user_detail 用户详细信息表</p>
<p>​           id(pk)     realname       tel            userid(fk+unique)….</p>
<p>​           -———————————————————-</p>
<p>​           1             张三               1111111111    2</p>
<p>​           2             李四               1111415621    1</p>
<hr>
<p> [<a href="#_msoanchor_1">A1]</a>SQL语句的底层也是使用的IO，只是不用这么麻烦了</p>
<p> [<a href="#_msoanchor_2">A2]</a>IBM发明了eclipse，曾经想收购java，最后没成功</p>
<p>最后被Oracle公司收购了</p>
<p> [<a href="#_msoanchor_3">A3]</a>后来Oracle又收购了Ab公司创办的MySQL，MySQL是开源的</p>
<p> [<a href="#_msoanchor_4">A4]</a>Oracle是重量级的数据库，安全，但是收费，一般传统行业会进行使用,比如：银行 政府</p>
<p>Mysql是轻量级的数据库，快，而且开源并且不收费，一般互联网公司会进行使用，比如：现在的京东，阿里等大牌公司</p>
<p> [<a href="#_msoanchor_5">A5]</a>一般大学都是基于SQLServer来讲的，但是市场上大部分都用Mysql居多</p>
<p> [<a href="#_msoanchor_6">A6]</a>这是显式登入</p>
<p>隐式登入就输入mysql –uroot –p后回车</p>
<p> [<a href="#_msoanchor_7">A7]</a>张三</p>
<p> [<a href="#_msoanchor_8">A8]</a>人</p>
<p> [<a href="#_msoanchor_9">A9]</a>人不能干哪些事，或者只能干哪些事</p>
<p> [<a href="#_msoanchor_10">A10]</a>Sql语句的结尾一定要有；</p>
<p> [<a href="#_msoanchor_11">A11]</a>不需要额外添加这个过滤条件。sum函数自动忽略NULL。</p>
<p> [<a href="#_msoanchor_12">A12]</a>SQL单行函数是对于每一行数据进行计算后得到一行输出结果。SQL单行函数根据数据类型分为字符函数、数字函数、日期函数、转换函数，另外还有一些别的函数。</p>
<p> [<a href="#_msoanchor_13">A13]</a>没有意义，因为当一条语句中有group by的时候，select后面只能跟分组函数和参与分组的字段。</p>
<p> [<a href="#_msoanchor_14">A14]</a>笛卡尔乘积是指在数学中，两个<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88">集合</a><em>X</em>和<em>Y</em>的笛卡尔积（Cartesian product），又称<a href="https://baike.baidu.com/item/%E7%9B%B4%E7%A7%AF/6537064">直积</a>，表示为<em>X</em> × <em>Y</em>，第一个对象是<em>X</em>的成员而第二个对象是<em>Y</em>的所有可能<a href="https://baike.baidu.com/item/%E6%9C%89%E5%BA%8F%E5%AF%B9">有序对</a>的其中一个成员</p>
<p> [<a href="#_msoanchor_15">A15]</a>内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。</p>
<p> [<a href="#_msoanchor_16">A16]</a>是以左表为基准，将a.stuid &#x3D; b.stuid的数据进行连接，然后将左表没有的对应项显示，右表的列为NULL</p>
<p> [<a href="#_msoanchor_17">A17]</a>是以右表为基准，将a.stuid &#x3D; b.stuid的数据进行连接，然以将右表没有的对应项显示，左表的列为NULL</p>
<p> [<a href="#_msoanchor_18">A18]</a>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>
<p> [<a href="#_msoanchor_19">A19]</a>这里一定要用外连接，不然会造成数据丢失</p>
<p> [<a href="#_msoanchor_20">A20]</a>重点，要多练</p>
<p> [<a href="#_msoanchor_21">A21]</a>Char的速度最快，因为char的底层不用经过if判断，char一般用在固定的字符串里，比如性别，生日</p>
<p> [<a href="#_msoanchor_22">A22]</a>比如你定了char(6)，那么只要你存的内容小于等于6，那么你的长度就是6，大于了定的长度就报错</p>
<p> [<a href="#_msoanchor_23">A23]</a>Varchar效率没char这么快，因为它的底层要经过if判断把长度传过去</p>
<p> [<a href="#_msoanchor_24">A24]</a>比如你定了varchar(6)，你存的内容小于等于6，你存的多少长度就是多少，varchar会动态的存储长度</p>
<p> [<a href="#_msoanchor_25">A25]</a>设置默认值</p>
<p> [<a href="#_msoanchor_26">A26]</a>插入和被插入的表列数得一样</p>
<p> [<a href="#_msoanchor_27">A27]</a>Not null 只有列级约束，没有表级约束</p>
<p> [<a href="#_msoanchor_28">A28]</a>NULL不是一个值</p>
<p> [<a href="#_msoanchor_29">A29]</a>字段后面写 primary key</p>
<p> [<a href="#_msoanchor_30">A30]</a>这里的性质分类只是宏观意义上的分类，对于一些具有强唯一性不可更变性的可以视为“自然主键”</p>
<p> [<a href="#_msoanchor_31">A31]</a>foreign key(子表外键字段) references 父表名称(父表外键字段)</p>
<p> [<a href="#_msoanchor_32">A32]</a>常用的</p>
<p> [<a href="#_msoanchor_33">A33]</a>常用的</p>
<p> [<a href="#_msoanchor_34">A34]</a>InnoDB属于重量级存储引擎，但是安全度最高，一般在开发项目时我们为了保证数据的安全性，一般都会选择InnoDB存储引擎</p>
<p> [<a href="#_msoanchor_35">A35]</a>支持事务，重量级，安全是它的代号</p>
<p> [<a href="#_msoanchor_36">A36]</a>级联删除就是外键中父表被删除了数据它子表对应的该数据也会删除，级联更新就是外键中父表更改了数据它子表对应的该数据也会随之更改，但是实际开发中不建议这样使用，因为这样会使得数据不安全</p>
<p> [<a href="#_msoanchor_37">A37]</a>常用的</p>
<p> [<a href="#_msoanchor_38">A38]</a>检索速度非常快，但是数据不能很好的永久性的保存，断电之后数据可能会消失</p>
<p> [<a href="#_msoanchor_39">A39]</a>类似于游戏存档，设了保存点后可以使回滚的时候回滚的少一点</p>
<p> [<a href="#_msoanchor_40">A40]</a>比如隔壁教师刚说完的话我这个教室立马就听到了</p>
<p> [<a href="#_msoanchor_41">A41]</a>别人一修改数据我读的数据就会被更改，即使我没关闭事务</p>
<p> [<a href="#_msoanchor_42">A42]</a>无论别人怎么修改只要我的事务没有关闭读的数据就一直都是我一开始读的数据</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>远程过程调用(RPC)详解</title>
    <url>/2022/07/09/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8(RPC)%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>前言：</p>
<p>本文为CSDN博主「和代码去流浪」的原创文章，本篇仅供学习使用，尊重原创</p>
<p>原文链接：<a href="https://blog.csdn.net/lgxzzz/article/details/120921461">https://blog.csdn.net/lgxzzz/article/details/120921461</a></p>
<hr>
<p>本文介绍了什么是远程过程调用(<a href="https://so.csdn.net/so/search?q=RPC&spm=1001.2101.3001.7020">RPC</a>)，RPC 有哪些常用的方法，RPC 经历了哪些发展阶段，以及比较了各种 RPC 技术的优劣。</p>
<h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h2><p>RPC 是远程过程调用（Remote Procedure Call）的缩写形式，Birrell 和 Nelson 在 1984 发表于 <a href="https://so.csdn.net/so/search?q=ACM&spm=1001.2101.3001.7020">ACM</a> Transactions on Computer Systems 的论文《Implementing remote procedure calls》对 RPC 做了经典的诠释。RPC 是指计算机 A 上的进程，调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。而这一过程，对于开发人员来说是透明的。</p>
<p><a href="https://imgtu.com/i/jyJOQx"><img src="https://s1.ax1x.com/2022/07/10/jyJOQx.jpg" alt="jyJOQx.jpg"></a></p>
<p>图1 描述了数据报在一个简单的RPC传递的过程</p>
<p>注：上述论文，可以在线阅读 <a href="https://www.cs.virginia.edu/~zaher/classes/CS656/birrel.pdf">http://www.cs.virginia.edu/~zaher&#x2F;classes&#x2F;CS656&#x2F;birrel.pdf</a>。</p>
<p>远程过程调用采用客户机&#x2F;服务器(C&#x2F;S)模式。请求程序就是一个客户机，而服务提供程序就是一台服务器。和常规或本地过程调用一样，远程过程调用是同步操作，在远程过程结果返回之前，需要暂时中止请求程序。使用相同地址空间的低权进程或低权线程允许同时运行多个远程过程调用。</p>
<h2 id="RPC-的基本操作"><a href="#RPC-的基本操作" class="headerlink" title="RPC 的基本操作"></a>RPC 的基本操作</h2><p>让我们看看本地过程调用是如何实现的。考虑下面的 C 语言的调用：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">count = <span class="keyword">read</span>(fd, buf, nbytes);</span><br></pre></td></tr></table></figure>

<p>其中，fd 为一个整型数，表示一个文件。buf 为一个字符数组，用于存储读入的数据。 nbytes 为另一个整型数，用于记录实际读入的字节数。如果该调用位于主程序中，那么在调用之前堆栈的状态如图2(a)所示。为了进行调用，调用方首先把参数反序压入堆栈，即为最后一个参数先压入，如图2(b)所示。在 read 操作运行完毕后，它将返回值放在某个寄存器中，移出返回地址，并将控制权交回给调用方。调用方随后将参数从堆栈中移出，使堆栈还原到最初的状态。</p>
<p><a href="https://imgtu.com/i/jyJHY9"><img src="https://s1.ax1x.com/2022/07/10/jyJHY9.jpg" alt="jyJHY9.jpg"></a></p>
<p>图2 过程调用中的参数传递</p>
<p>RPC 背后的思想是尽量使远程过程调用具有与本地调用相同的形式。假设程序需要从某个文件读取数据，程序员在代码中执行 read 调用来取得数据。在传统的系统中， read 例程由链接器从库中提取出来，然后链接器再将它插入目标程序中。 read 过程是一个短过程，一般通过执行一个等效的 read 系统调用来实现。即，read 过程是一个位于用户代码与本地操作系统之间的接口。</p>
<p>虽然 read 中执行了系统调用，但它本身依然是通过将参数压入堆栈的常规方式调用的。如图2(b)所示，程序员并不知道 read 干了啥。</p>
<p>RPC 是通过类似的途径来获得透明性。当 read 实际上是一个远程过程时（比如在文件服务器所在的机器上运行的过程），库中就放入 read 的另外一个版本，称为客户存根（client stub）。这种版本的 read 过程同样遵循图2(b)的调用次序，这点与原来的 read 过程相同。另一个相同点是其中也执行了本地操作系统调用。唯一不同点是它不要求操作系统提供数据，而是将参数打包成消息，而后请求此消息发送到服务器，如图3所示。在对 send 的调用后，客户存根调用 receive 过程，随即阻塞自己，直到收到响应消息。</p>
<p><a href="https://imgtu.com/i/jyJoo4"><img src="https://s1.ax1x.com/2022/07/10/jyJoo4.jpg" alt="jyJoo4.jpg"></a></p>
<p>图3 客户与服务器之间的RPC原理</p>
<p>当消息到达服务器时，服务器上的操作系统将它传递给服务器存根（server stub）。服务器存根是客户存根在服务器端的等价物，也是一段代码，用来将通过网络输入的请求转换为本地过程调用。服务器存根一般先调用 receive ，然后被阻塞，等待消息输入。收到消息后，服务器将参数由消息中提取出来，然后以常规方式调用服务器上的相应过程（如图3所示）。从服务器角度看，过程好像是由客户直接调用的一样：参数和返回地址都位于堆栈中，一切都很正常。服务器执行所要求的操作，随后将得到的结果以常规的方式返回给调用方。以 read 为例，服务器将用数据填充 read 中第二个参数指向的缓冲区，该缓存区是属于服务器存根内部的。</p>
<p>调用完后，服务器存根要将控制权教会给客户发出调用的过程，它将结果（缓冲区）打包成消息，随后调用 send 将结果返回给客户。事后，服务器存根一般会再次调用 receive，等待下一个输入的请求。</p>
<p>客户机器接收到消息后，客户操作系统发现该消息属于某个客户进程（实际上该进程是客户存根，只是操作系统无法区分二者）。操作系统将消息复制到相应的缓存区中，随后解除对客户进程的阻塞。客户存根检查该消息，将结果提取出来并复制给调用者，而后以通常的方式返回。当调用者在 read 调用进行完毕后重新获得控制权时，它所知道的唯一事就是已经得到了所需的数据。它不指导操作是在本地操作系统进行，还是远程完成。</p>
<p>整个方法，客户方可以简单地忽略不关心的内容。客户所涉及的操作只是执行普通的（本地）过程调用来访问远程服务，它并不需要直接调用 send 和 receive 。消息传递的所有细节都隐藏在双方的库过程中，就像传统库隐藏了执行实际系统调用的细节一样。</p>
<p>概况来说，远程过程调用包含如下步骤：</p>
<ol>
<li>客户过程以正常的方式调用客户存根；</li>
<li>客户存根生成一个消息，然后调用本地操作系统；</li>
<li>客户端操作系统将消息发送给远程操作系统；</li>
<li>远程操作系统将消息交给服务器存根；</li>
<li>服务器存根调将参数提取出来，而后调用服务器；</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根；</li>
<li>服务器存根将结果打包成一个消息，而后调用本地操作系统；</li>
<li>服务器操作系统将含有结果的消息发送给客户端操作系统；</li>
<li>客户端操作系统将消息交给客户存根；</li>
<li>客户存根将结果从消息中提取出来，返回给调用它的客户存根。</li>
</ol>
<p>以上步骤就是将客户过程对客户存根发出的本地调用转换成对服务器过程的本地调用，而客户端和服务器都不会意识到中间步骤的存在。</p>
<p>RPC 的主要好处是双重的。首先,程序员可以使用过程调用语义来调用远程函数并获取响应。其次,简化了编写分布式应用程序的难度,因为 RPC 隐藏了所有的网络代码存根函数。应用程序不必担心一些细节,比如 socket、端口号以及数据的转换和解析。在 OSI 参考模型,RPC 跨越了会话层和表示层。</p>
<h2 id="实现远程过程调用"><a href="#实现远程过程调用" class="headerlink" title="实现远程过程调用"></a>实现远程过程调用</h2><p>要实现远程过程调用，需考虑以下几个问题。</p>
<h3 id="如何传递参数"><a href="#如何传递参数" class="headerlink" title="如何传递参数"></a>如何传递参数</h3><p>传递值参数</p>
<p>传递值参数比较简单，下图图展示了一个简单 RPC 进行远程计算的例子。其中，远程过程 add(i,j) 有两个参数 i 和 j， 其结果是返回 i 和 j 的算术和。</p>
<p><a href="https://imgtu.com/i/jyJLS1"><img src="https://s1.ax1x.com/2022/07/10/jyJLS1.jpg" alt="jyJLS1.jpg"></a></p>
<p>图4 通过RPC进行远程计算的步骤</p>
<p>通过 RPC 进行远程计算的步骤有：</p>
<ol>
<li>将参数放入消息中，并在消息中添加要调用的过程的名称或者编码。</li>
<li>消息到达服务器后，服务器存根堆该消息进行分析，以判明需要调用哪个过程，随后执行相应的调用。</li>
<li>服务器运行完毕后，服务器存根将服务器得到的结果打包成消息送回客户存根，客户存根将结果从消息中提取出来，把结果值返回给客户端。</li>
</ol>
<p>当然，这里只是做了简单的演示，在实际分布式系统中，还需要考虑其他情况，因为不同的机器对于数字、字符和其他类型的数据项的表示方式常有差异。比如整数型，就有 Big Endian 和 Little Endian 之分。</p>
<p>传递引用参数</p>
<p>传递引用参数相对来说比较困难。单纯传递参数的引用（也包含指针）是完全没有意义的，因为引用地址传递给远程计算机,其指向的内存位置可能跟远程系统上完全不同。如果你想支持传递引用参数,你必须发送参数的副本,将它们放置在远程系统内存中，向他们传递一个指向服务器函数的指针，然后将对象发送回客户端，复制它的引用。如果远程过程调用必须支持引用复杂的结构，比如树和链表，他们需要将结构复制到一个无指针的表示里面（比如，一个扁平的树)，并传输到在远程端来重建数据结构。</p>
<h3 id="如何表示数据"><a href="#如何表示数据" class="headerlink" title="如何表示数据"></a>如何表示数据</h3><p>在本地系统上不存在数据不相容的问题，因为数据格式总是相同的。而在分布式系统中，不同远程机器上可能有不同的字节顺序，不同大小的整数，以及不同的浮点表示。对于 RPC，如果想与异构系统通信，我们就需要想出一个“标准”来对所有数据类型进行编码，并可以作为参数传递。例如，ONC RPC 使用 XDR (eXternal Data Representation) 格式 。这些数据表示格式可以使用隐式或显式类型。隐式类型，是指只传递值，而不传递变量的名称或类型。常见的例子是 ONC RPC 的 XDR 和 DCE RPC 的 NDR。显式类型，指需要传递每个字段的类型以及值。常见的例子是 ISO 标准 ASN.1 (Abstract Syntax Notation)、JSON (JavaScript Object Notation)、Google Protocol Buffers、以及各种基于 XML 的数据表示格式。</p>
<h3 id="如何选用传输协议"><a href="#如何选用传输协议" class="headerlink" title="如何选用传输协议"></a>如何选用传输协议</h3><p>有些实现只允许使用一个协议(例如 TCP )。大多数 RPC 实现支持几个，并允许用户选择。</p>
<h3 id="出错时-会发生什么"><a href="#出错时-会发生什么" class="headerlink" title="出错时,会发生什么"></a>出错时,会发生什么</h3><p>相比于本地过程调用，远程过程调用出错的机会将会更多。由于本地过程调用没有过程调用失败的概念，项目使用远程过程调用必须准备测试远程过程调用的失败或捕获异常。</p>
<h3 id="远程调用的语义是什么"><a href="#远程调用的语义是什么" class="headerlink" title="远程调用的语义是什么"></a><a href="https://so.csdn.net/so/search?q=%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8&spm=1001.2101.3001.7020">远程调用</a>的语义是什么</h3><p>调用一个普通的过程语义很简单:当我们调用时，过程被执行。远程过程完全一次性调用成功是非常难以实现。执行远程过程可以有如下结果:</p>
<ul>
<li>如果服务器崩溃或进程在运行服务器代码之前就死了，那么远程过程会被执行0次；</li>
<li>如果一切工作正常，远程过程会被执行1次；</li>
<li>如果服务器返回服务器存根后在发送响应前就奔溃了，远程过程会被执行1次或者多次。客户端接收不到返回的响应,可以决定再试一次,因此出现多次执行函数。如果没有再试一次,函数执行一次；</li>
<li>如果客户机超时和重新传输，那么远程过程会被执行多次。也有可能是原始请求延迟了。两者都可能会执行或不执行。</li>
</ul>
<p>RPC 系统通常会提供至少一次或最多一次的语义，或者在两者之间选择。如果需要了解应用程序的性质和远程过程的功能是否安全，可以通过多次调用同一个函数来验证。如果一个函数可以运行任何次数而不影响结果，这是幂等（idempotent）函数的，如每天的时间、数学函数、读取静态数据等。否则,它是一个非幂等（nonidempotent）函数，如添加或修改一个文件)。</p>
<h3 id="远程调用的性能怎么样"><a href="#远程调用的性能怎么样" class="headerlink" title="远程调用的性能怎么样"></a>远程调用的性能怎么样</h3><p>毫无疑问,一个远程过程调用将会比常规的本地过程调用慢得多，因为产生了额外的步骤以及网络传输本身存在延迟。然而，这并不应该阻止我们使用远程过程调用。</p>
<h3 id="远程调用安全吗？"><a href="#远程调用安全吗？" class="headerlink" title="远程调用安全吗？"></a>远程调用安全吗？</h3><p>使用 RPC,我们必须关注各种安全问题:</p>
<ul>
<li>客户端发送消息到远程过程，那个过程是可信的吗?</li>
<li>客户端发送消息到远程计算机，那个远程机器是可信的吗?</li>
<li>服务器如何验证接收的消息是来自合法的客户端吗?服务器如何识别客户端?</li>
<li>消息在网络中传播如何防止时被其他进程嗅探?</li>
<li>可以由其他进程消息被拦截和修改时遍历网络从客户端到服务器或服务器端?</li>
<li>协议能防止重播攻击吗?</li>
<li>如何防止消息在网络传播中被意外损坏或截断?</li>
</ul>
<h2 id="远程过程调用的优点"><a href="#远程过程调用的优点" class="headerlink" title="远程过程调用的优点"></a>远程过程调用的优点</h2><p>远程过程调用有诸多的优点：</p>
<ul>
<li>你不必担心传输地址问题。服务器可以绑定到任何可用的端口,然后用 RPC 名称服务来注册端口。客户端将通过该名称服务来找到对应的端口号所需要的程序。而这一切对于程序员来说是透明的。</li>
<li>系统可以独立于传输提供者。自动生成服务器存根使其可以在系统上的任何一个传输提供者上可用,包括 TCP 和 UDP，而这些，客户端可以动态选择的。当代码发送以后，接收消息是自动生成的，而不需要额外的编程代码。</li>
<li>应用程序在客户端只需要知道一个传输地址——名称服务，负责告诉应用程序去哪里连接服务器函数集。</li>
<li>使用函数调用模型来代替 socket 的发送&#x2F;接收(读&#x2F;写)接口。用户不需要处理参数的解析。</li>
</ul>
<h2 id="RPC-API"><a href="#RPC-API" class="headerlink" title="RPC API"></a>RPC API</h2><p>任何 RPC 实现都需要提供一组支持库。这些包括:</p>
<ul>
<li>名称服务操作： 注册和查找绑定信息(端口、机器)。允许一个应用程序使用动态端口(操作系统分配的)；</li>
<li>绑定操作：使用适当的协议建立客户机&#x2F;服务器通信(建立通信端点)；</li>
<li>终端操作：注册端点信息(协议、端口号、机器名)到名称服务并监听过程调用请求。这些函数通常被自动生成的主程序——服务器存根(骨架)所调用；</li>
<li>安全操作：系统应该提供机制保证客户端和服务器之间能够相互验证,两者之间提供一个安全的通信通道；</li>
<li>国际化操作(可能)：这是很少的一部分 RPC 包可能包括了转换时间格式、货币格式和特定于语言的在字符串表的字符串的功能；</li>
<li>封送处理&#x2F;数据转换操作：函数将数据序列化为一个普通的的字节数组，通过网络进行传递，并能够重建；</li>
<li>存根内存管理和垃圾收集：存根可能需要分配内存来存储参数，特别是模拟引用传递语义。RPC 包需要分配和清理任何这样的分配。他们也可能需要为创建网络缓冲区而分配内存。RPC 包支持对象，RPC 系统需要一种跟踪远程客户端是否仍有引用对象或一个对象是否可以删除。</li>
<li>程序标识操作：允许应用程序访问(或处理) RPC 接口集的标识符，这样的服务器提供的接口集可以被用来交流和使用。</li>
<li>对象和函数的标识操作： 允许将远程函数或远程对象的引用传递给其他进程。并不是所有的 RPC 系统都支持。</li>
</ul>
<p>所以，判断一种通信方式是否是 RPC，就看它是否提供上述的 API。</p>
<h2 id="第一代-RPC"><a href="#第一代-RPC" class="headerlink" title="第一代 RPC"></a>第一代 RPC</h2><h3 id="ONC-RPC-以前称为-Sun-RPC"><a href="#ONC-RPC-以前称为-Sun-RPC" class="headerlink" title="ONC RPC(以前称为 Sun RPC)"></a>ONC RPC(以前称为 Sun RPC)</h3><p>Sun 公司是第一个提供商业化 RPC 库和 RPC 编译器。在1980年代中期 Sun 计算机提供 RPC，并在 Sun Network File System(NFS) 得到支持。该协议被主要以 Sun 和 AT&amp;T 为首的 Open Network Computing （开放网络计算）作为一个标准来推动。这是一个非常轻量级 RPC 系统可用在大多数 POSIX 和类 POSIX 操作系统中使用，包括 Linux、SunOS、OS X 和各种发布版本的 BSD。这样的系统被称为 Sun RPC 或 ONC RPC。</p>
<p>ONC RPC 提供了一个编译器，需要一个远程过程接口的定义来生成客户机和服务器的存根函数。这个编译器叫做 rpcgen。在运行此编译器之前，程序员必须提供接口定义。包含函数声明的接口定义，通过版本号进行分组，并被一个独特的程序编码来标识。该程序编码能够让客户来确定所需的接口。版本号是非常有用的,即使客户没有更新到最新的代码仍然可以连接到一个新的服务器，只要该服务器还支持旧接口。</p>
<p>参数通过网络转化成一种隐式类型序列化格式被称为 XDR (eXternal Data Representation)。这将确保参数能够发送到异构系统可以被正常使用，及时这些系统可能使用了不同的字节顺序，不同大小的整数，或不同的浮点或字符串表示。最后，Sun RPC 提供了一个实现必要的支持 RPC 协议和 socket 例程的运行时库。</p>
<p>所有的程序员都需要写是一个客户端程序(<a href="https://www.cs.rutgers.edu/~pxk/417/notes/rpc/client.c">client.c</a>),服务器功能(<a href="https://www.cs.rutgers.edu/~pxk/417/notes/rpc/server.c">server.c</a>)和 RPC 接口定义(<a href="https://www.cs.rutgers.edu/~pxk/417/notes/rpc/date.x">date.x</a>)。当 RPC 接口定义(后缀为.x 的文件，例如 date.x)是用 rpcgen 编译的,会创建三个或四个文件。下面是 date.x 的例子:</p>
<ul>
<li>date.h：包含项目的定义、版本和声明的函数。客户端和服务器端功能应该包括这个文件。</li>
<li>date_svc.c ：C 语言代码来实现服务器存根。</li>
<li>date_clnt.c ：C 语言代码来实现客户端存根。</li>
<li>date_xdr.c ：包含 XDR 例程来将数据转化为 XDR 格式。如果这个文件生成,它应该编译并用来链接在客户端和服务器的函数。</li>
</ul>
<p>创建客户端和服务器可执行文件的第一步是定义在文件 <a href="https://www.cs.rutgers.edu/~pxk/417/notes/rpc/date.x">date.x</a> 里的编译数据。之后，客户端和服务器端函数可能被编译，并链接各自 rpcgen 生成的存根函数。</p>
<p>在旧版本里，传输协议只能将字符串“tcp”或字符串“udp”来指定各自的 IP 服务 RPC，且仅限于 Linux 实现的 RPC。为了使接口更加灵活，UNIX 系统从版本 4 (SunOS 从版本 5)开始网络选择程序允许一个更普通的规范。他们搜索文件(&#x2F;etc&#x2F;netconfig)，来查找第一个满足您需求的提供者。最后一个参数可以是:</p>
<ul>
<li>“netpath”：搜索 NETPATH 环境变量用于首选传输提供者的序列；</li>
<li>“circuit_n”：找到第一个在 NETPATH 列表中的虚拟电路提供者；</li>
<li>“datagram_n”：找到第一个 NETPATH 列表中的数据报提供者；</li>
<li>“visible”：找到第一个在 &#x2F;etc&#x2F;netconfig 的可见传输提供者；</li>
<li>“circuit_v”：找到第一个在 &#x2F;etc&#x2F;netconfig 的可见虚拟电路传输提供者；</li>
<li>“datagram_v”：找到第一个在 &#x2F;etc&#x2F;netconfig 的可见数据报传输提供者；</li>
</ul>
<p>每个远程过程调用最初仅限于接受一个输入参数。系统只是后来修改为支持多个参数。支持单一参数 RPC 在一些 rpcgen 的版本中仍然是默认的，比如苹果的 OS X。传递多个参数必须通过定义一个结构，包含所需的参数，初始化它，并传递这个结构。</p>
<p>远程过程调用返回一个指针指向结果而不是期望的结果。服务器函数必须修改来能接受一个 RPC 定义（.x 文件）中声明的值的指针作为输入，并返回一个结果值的指针。在服务器上，一个指针必须是指向静态数据的指针。否则，当过程返回或释放过程的框架所指出的区域将未定义。在客户端,返回指针可以让我们区分一个失败的 RPC(空指针)和一个空返回从服务器(间接空指针)。</p>
<p>RPC 过程的名称若在 RPC 定义文件中做了定义，则会转换为小写，并在后缀价下划线，后跟一个版本号。例如，BIN_DATE 转成为引用函数 bin_date_1 。您的服务器必须实现 bin_date_1。</p>
<h3 id="当我们运行这个程序时-会发生什么"><a href="#当我们运行这个程序时-会发生什么" class="headerlink" title="当我们运行这个程序时,会发生什么?"></a>当我们运行这个程序时,会发生什么?</h3><p>服务器</p>
<p>当我们启动服务器，服务器存根代码(程序)在后台运行运行。它创建一个 socket 并可绑定任何本地端口到 socket。然后调用一个在 RPC 库的函数 svc_register，来注册程序编号和版本。这个是用来联系 port mapper（端口映射器）。port mapper 是一个独立的进程，通常是在系统启动时启动。它跟踪端口号、版本号以及程序编号。在 UNIX 系统版本4中，这个进程称为 rpcbind。在 Linux 、OS X 和 BSD 系统,它被称为 portmap。</p>
<p><a href="https://imgtu.com/i/jyJbWR"><img src="https://s1.ax1x.com/2022/07/10/jyJbWR.jpg" alt="jyJbWR.jpg"></a></p>
<p>图5 ONC RPC 中的函数查找</p>
<p>客户端</p>
<p>当我们开始客户端程序时，它首先用远程系统的名称、程序编号、版本号和协议来调用 clnt_create 。它接触远程系统上的端口映射器,来为系统找到合适的端口。</p>
<p>然后客户端调用 RPC 存根函数(在本例中为 bin_date_1)。该函数发送一条消息(如，数据报)到服务器(使用早些时候发现的端口号)并等待响应。对于数据报服务来说，若没有接收到响应，它将重新发送一个固定的次数请求。</p>
<p>消息接着被远程系统接收到，它调用服务器函数(bin_date_1)并将返回值返回给客户端存根。客户端存根而后返回到客户端发出调用的代码。</p>
<h2 id="分布式计算环境中的-RPC-DCE-RPC"><a href="#分布式计算环境中的-RPC-DCE-RPC" class="headerlink" title="分布式计算环境中的 RPC(DCE RPC)"></a>分布式计算环境中的 RPC(DCE RPC)</h2><p>DCE(Distributed Computing Environment，分布式计算环境)是一组由OFS(Open Software Foundation，开放软件基金会)设计的组件，用来提供支持分布式应用和分布式环境。与 X&#x2F;Open 合并后,这组织成为了 The Open Group （开放式开发组）。DCE 提供的组件包括一个分布式文件服务、时间服务、目录服务以及其他服务。当然，我们感兴趣的是 DCE 的远程过程调用。它非常类似于 Sun RPC。接口是由 Interface Definition Notation (IDN) 定义的。类似于 Sun RPC，接口定义就像函数原型。</p>
<p>Sun RPC 不足之处在于，服务器的标识是一个“独特”的 32-bit 数字。虽然这是一个比在 socket 中 16-bit 可用空间更大的空间，但仍然无法满足数字唯一性的需求。DCE RPC 考虑到了这一缺陷，它无需程序员来处理编码。在编写应用程序时的第一步是从 uuidgen 程序获得一个惟一的 ID。这个程序会生成一个包含 ID 接口的原型 IDN 文件，并保证永远不会再次使用。它是一个 128-bit 的值，其中包含一个位置代码和创建时间的编码。然后用户编辑原型文件，填写远程过程声明。</p>
<p>在这一步后，IDN 的编译器 dceidl（类似于 rpcgen）会生成一个头、客户机存根和服务器存根。</p>
<p>Sun RPC 的另一个缺陷是，客户端必须知道服务器在哪台机器上。当它要访问时，必须要询问机器上的 RPC 名称服务程序编码所对应的端口号。DCE 支持将多个机器组织成为管理实体，称为 cells。cell 目录服务器使得每台机器知道如何与另外一台负责维护 cell 信息服务机器交互。</p>
<p>在 Sun RPC 中，服务器只能用本地名称服务(端口映射器)来注册其程序编号到端口映射。而在 DCE 中，服务器用 RPC 守护进程(名称服务器)来注册其端点(端口)到本地机器，并且用 cell 目录服务器注册其程序名字到机器的映射。当客户机想要与一个 RPC 服务器建立通信，它首先要求其 cell 目录服务器来定位服务器所在的机器。然后客户端从 RPC 守护进程处获得机器上服务器进程的端口号。DCE 的跨 cell 还支持更复杂的搜索。</p>
<p>DCE RPC 定义了 NDR (Network Data Representation) 用于对网络进行编码来封送信息。与用一个单一的规范来表示不同的数据类型相比，NDR 支持多规范（multi-canonical）格式。允许客户端来选择使用哪种格式，理想的情况是不需要将它从本地类型来转换。如果这不同于服务器的本地数据表示,服务器将仍然需要转换，但多规范格式可以避免当客户端和服务器都共享相同的本地格式的情况下转换为其他外部格式。例如,在一个规定了大端字节序网络数据格式的情况下，客户端和服务器只支持小端字节序，那么客户端必须将每个数据从小端字节序转为大端字节序，而当服务器接受到消息后,将每个数据转回小端字节序。多规范网络数据表示将允许客户端发送网络消息包含小端字节序格式的数据。</p>
<p><a href="https://imgtu.com/i/jyJXy6"><img src="https://s1.ax1x.com/2022/07/10/jyJXy6.jpg" alt="jyJXy6.jpg"></a></p>
<p>图6 DCE RPC 中的函数查找</p>
<h2 id="第二代-RPC-支持对象"><a href="#第二代-RPC-支持对象" class="headerlink" title="第二代 RPC:支持对象"></a>第二代 RPC:支持对象</h2><p>面向对象的语言开始在1980年代末兴起，很明显，当时的 Sun ONC 和 DCE RPC 系统都没有提供任何支持诸如从远程类实例化远程对象、跟踪对象的实例或提供支持多态性。现有的 RPC 机制虽然可以运作，但他们仍然不支持自动、透明的方式的面向对象编程技术。</p>
<h3 id="微软-DCOM-COM"><a href="#微软-DCOM-COM" class="headerlink" title="微软 DCOM(COM+)"></a>微软 DCOM(COM+)</h3><p>1992年4月,微软发布 Windows 3.1 包括一种机制称为 OLE (Object Linking and Embedding)。这允许一个程序动态链接其他库来支持的其他功能。如将一个电子表格嵌入到 Word 文档。OLE 演变成了 COM (Component Object Model)。一个 COM 对象是一个二进制文件。使用 COM 服务的程序来访问标准化接口的 COM 对象而不是其内部结构。COM 对象用全局唯一标识符(GUID)来命名，用类的 ID 来识别对象的类。几种方法来创建一个 COM 对象(例如 CoGetInstanceFromFile)。COM 库在系统注册表中查找相应的二进制代码(一个 DLL 或可执行文件)，来创建对象，并给调用者返回一个接口指针。COM 的着眼点是在于同一台计算机上不同应用程序之间的通讯需求.</p>
<p>DCOM（ Distributed Component Object Model）是 COM 的扩展，它支持不同的两台机器上的组件间的通信，而且不论它们是运行在局域网、广域网、还是 Internet 上。借助 DCOM 你的应用程序将能够进行任意空间分布。DCOM 于1996年在 Windows NT4.0 中引入的，后来更名为 COM+。由于 DCOM 是为了支持访问远程 COM 对象，需要创建一个对象的过程，此时需要提供服务器的网络名以及类 ID。微软提供了一些机制来实现这一点。最透明的方式是远程计算机的名称固定在注册表（或 DCOM 类存储）里，与特定类 ID 相关联。以此方式，应用程序不知道它正在访问一个远程对象，并且可以使用与访问本地 COM 对象相同的接口指针。另一方面，应用程序也可指定一个机器名作为参数。</p>
<p>由于 DCOM 是 COM 这个组件技术的无缝升级，所以你能够从你现有的有关 COM 得知识中获益，你的以前在 COM 中开发的应用程序、组件、工具都可以移入分布式的环境中。DCOM 将为你屏蔽底层网络协议的细节，你只需要集中精力于你的应用。</p>
<p>DCOM 最大的缺点是这是微软独家的解决办法，在跨防火墙方面的工作做得不是很好（大多数RPC系统也有类似的问题），因为防火墙必须允许某些端口来允许 ORPC 和 DCOM 通过。</p>
<h3 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h3><p>虽然 DCE 修复的一些 Sun RPC 的缺点，但某些缺陷依然存在。例如，如果服务器没有运行，客户端是无法连接到远程过程进行调用的。管理员必须要确保在任何客户端试图连接到服务器之前将服务器启动。如果一个新服务或接口添加到了系统，客户端是不能发现的。最后,面向对象语言期望在函数调用中体现多态性，即不同类型的数据的函数的行为应该有所不同，而这点恰恰是传统的 RPC 所不支持的。</p>
<p>CORBA (Common Object Request Broker Architecture) 就是为了解决上面提到的各种问题。是由 OMG 组织制订的一种标准的面向对象应用程 序体系规范。或者说 CORBA体系结构是对象管理组织（OMG）为解决分布式处理环境(DCE)中，硬件和软件系统的互连而提出的一种解决方案。OMG 成立于1989年，作为一个非营利性组织，集中致力于开发在技术上具有先进性、在商业上具有可行性并且独立于厂商的软件互联规范，推广面向对象模型技术，增强软件的可移植性（Portability）、可重用性（Reusability）和互操作性（Interoperability）。该组织成立之初，成员包括 Unisys、Sun、Cannon、Hewlett-Packard 和 Philips 等在业界享有声誉的软硬件厂商，目前该组织拥有800多家成员。</p>
<p>CORBA 体系的主要内容包括以下几部分：</p>
<ul>
<li>对象请求代理 （Object Request Broker，ORB）：负责对象在分布环境中透明地收发请求和响应，它是构建分布对象应用、在异构或同构环境下实现应用间互操作的基础。</li>
<li>对象服务（Object Services）：为使用和实现对象而提供的基本对象集合，这些服务应独立于应用领域。主要的 CORBA 服务有：名录服务（Naming Service）、事件服务（Event Service）、生命周期服务（Life Cycle Service）、关系服务（Relationship Service）以及事务服务（Transaction Service）等。这些服务几乎包括分布系统和面向对象系统的各个方面，每个组成部分都非常复杂。</li>
<li>公共设施（Common Facilitites）：向终端用户提供一组共享服务接口，例如系统管理、组合文档和电子邮件等。</li>
<li>应用接口（Application Interfaces）。由销售商提供的可控制其接口的产品，相应于传统的应用层表示，处于参考模型的最高层。</li>
<li>领域接口（Domain Interfaces）：为应用领域服务而提供的接口，如OMG 组织为 PDM 系统制定的规范。</li>
</ul>
<p>当客户端发出请求时,ORB 做了如下事情:</p>
<ul>
<li>在客户端编组参数；</li>
<li>定位服务器对象。如果有必要的话,它会在服务器创建一个过程来处理请求；</li>
<li>如果服务器是远程是,就使用 RPC 或 socket 来传送请求；</li>
<li>在服务器上将参数解析成为服务器格式；</li>
<li>在服务器上组装返回值；</li>
<li>如果服务器是远程的，就将返回值传回；</li>
<li>在客户端对返回结果进行解析；</li>
</ul>
<p>IDL(Interface Definition Language) 是用于指定类的名字、属性和方法。它不包含对象的实现。IDL 编译器生成代码来处理编组、解封以及ORB与网络之间的交互。它会生成客户机和服务器存根。IDL 是编程语言中立，支持包括C、C++、Java、Perl、Python、Ada、COBOL、Smalltalk、Objective C 和 LISP 等语言。一个示例IDL如下所示:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Module StudentObject &#123;</span><br><span class="line">    Struct StudentInfo &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">float</span> gpa;</span><br><span class="line">    &#125;;</span><br><span class="line">    exception Unknown &#123;&#125;;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">Student</span> &#123;</span><br><span class="line">        <span class="function">StudentInfo <span class="title">getinfo</span>(<span class="params"><span class="keyword">in</span> <span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function">            <span class="title">raises</span>(<span class="params">unknown</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">putinfo</span>(<span class="params"><span class="keyword">in</span> StudentInfo data</span>)</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDL数据类型包括:</p>
<ul>
<li>基本类型:long, short, string, float, …</li>
<li>构造类型:struct、union、枚举、序列</li>
<li>对象引用</li>
<li>any 类型:一个动态类型的值</li>
</ul>
<p>编程中最常见的实现方式是通过对象引用来实现请求。下面是一个使用 IDL 的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> ... <span class="comment">// get object reference</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">StudentInfo</span> <span class="variable">sinfo</span> <span class="operator">=</span> st.getinfo(<span class="string">&quot;Fred Grampp&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    ... <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CORBA 规范中，没有明确说明不同厂商的中间件产品要实现所有的服务功能，并且允许厂商开发自己的服务类型。因此, 不同厂商的 ORB 产品对 CORBA 服务的支持能力不同，使我们在针对待开发系统的功能进行中间件产品选择时，有更多的选择余地。</p>
<p>CORBA 的不足有：</p>
<ul>
<li>尽管有多家供应商提供CORBA产品，但是仍找不到能够单独为异种网络中的所有环境提供实现的供应商。不同的 CORBA 实现之间会出现缺乏互操作性的现象，从而造成一些问题；而且，由于供应商常常会自行定义扩展，而 CORBA 又缺乏针对多线程环境的规范，对于像 C 或 C++ 这样的语言，源码兼容性并未完全实现。</li>
<li>CORBA 过于复杂，要熟悉 CORBA，并进行相应的设计和编程，需要许多个月来掌握，而要达到专家水平，则需要好几年。</li>
</ul>
<p>更多有关 CORBA 的优缺点，可以参阅 Michi Henning 的《<a href="http://queue.acm.org/detail.cfm?id=1142044">The rise and fall of CORBA</a>》。</p>
<h3 id="Java-RMI"><a href="#Java-RMI" class="headerlink" title="Java RMI"></a>Java RMI</h3><p>CORBA 旨在提供一组全面的服务来管理在异构环境中(不同语言、操作系统、网络)的对象。Java 在其最初只支持通过 socket 来实现分布式通信。1995年,作为 Java 的缔造者，Sun 公司开始创建一个 Java 的扩展，称为 Java RMI(Remote Method Invocation，远程方法调用)。Java RMI 允许程序员创建分布式应用程序时，可以从其他 Java 虚拟机(JVM)调用远程对象的方法。</p>
<p>一旦应用程序(客户端)引用了远程对象，就可以进行远程调用了。这是通过 RMI 提供的命名服务(RMI 注册中心)来查找远程对象，来接收作为返回值的引用。Java RMI 在概念上类似于 RPC，但能在不同地址空间支持对象调用的语义。</p>
<p>与大多数其他诸如 CORBA 的 RPC 系统不同，RMI 只支持基于 Java 来构建，但也正是这个原因， RMI 对于语言来说更加整洁，无需做额外的数据序列化工作。Java RMI 的设计目标应该是:</p>
<ul>
<li>能够适应语言、集成到语言、易于使用；</li>
<li>支持无缝的远程调用对象；</li>
<li>支持服务器到 applet 的回调；</li>
<li>保障 Java 对象的安全环境；</li>
<li>支持分布式垃圾回收；</li>
<li>支持多种传输。</li>
</ul>
<p>分布式对象模型与本地 Java 对象模型相似点在于:</p>
<ul>
<li>引用一个对象可以作为参数传递或作为返回的结果；</li>
<li>远程对象可以投到任何使用 Java 语法实现的远程接口的集合上；</li>
<li>内置 Java instanceof 操作符可以用来测试远程对象是否支持远程接口。</li>
</ul>
<p>不同点在于:</p>
<ul>
<li>远程对象的类是与远程接口进行交互，而不是与这些接口的实现类交互；</li>
<li>Non-remote 参数对于远程方法调用来说是通过复制，而不是通过引用；</li>
<li>远程对象是通过引用来传递，而不是复制实际的远程实现；</li>
<li>客户端必须处理额外的异常。</li>
</ul>
<p>接口和类</p>
<p>所有的远程接口都继承自 <code>java.rmi.Remote</code> 接口。例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">bankaccount</span> <span class="keyword">extends</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">float</span> amount)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.RemoteException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">float</span> amount)</span></span><br><span class="line">        <span class="keyword">throws</span> OverdrawnException,</span><br><span class="line">        java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意,每个方法必须在 throws 里面声明 <code>java.rmi.RemoteException</code> 。 只要客户端调用远程方法出现失败，这个异常就会抛出。</p>
<p>远程对象类</p>
<p><code>Java.rmi.server.RemoteObject</code> 类提供了远程对象实现的语义包括hashCode、equals　和　toString。 <code>java.rmi.server.RemoteServer</code>　及其子类提供让对象实现远程可见。<code>java.rmi.server.UnicastRemoteObject</code> 类定义了客户机与服务器对象实例建立一对一的连接.</p>
<p>存根</p>
<p>Java RMI 通过创建存根函数来工作。存根由 rmic 编译器生成。自 Java 1.5 以来,Java 支持在运行时动态生成存根类。编译器 rmic 会提供各种编译选项。</p>
<p>定位对象</p>
<p>引导名称服务提供了用于存储对远程对象的命名引用。一个远程对象引用可以存储使用类 <code>java.rmi.Naming</code> 提供的基于 URL 的方法。例如,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BankAccount</span> <span class="variable">acct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankAcctImpl</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://java.sun.com/account&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind url to remote object</span></span><br><span class="line"></span><br><span class="line">java.rmi.Naming.bind(url, acct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// look up account</span></span><br><span class="line"></span><br><span class="line">acct = (BankAccount)java.rmi.Naming.lookup(url);</span><br></pre></td></tr></table></figure>

<p><a href="https://imgtu.com/i/jyJjOK"><img src="https://s1.ax1x.com/2022/07/10/jyJjOK.jpg" alt="jyJjOK.jpg"></a></p>
<p>图7 Java RMI 工作流程</p>
<p>RMI 架构</p>
<p>RMI 是一个三层架构(图8)。最上面是 Stub&#x2F;Skeleton layer（存根&#x2F;骨架层）。方法调用从 Stub、Remote Reference Layer (远程引用层)和 Transport Layer（传输层）向下，传递给主机，然后再次经传 Transport Layer 层，向上穿过 Remote Reference Layer 和 Skeleton ，到达服务器对象。 Stub 扮演着远程服务器对象的代理的角色，使该对象可被客户激活。Remote Reference Layer 处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。Transport Layer 管理实际的连接，并且追踪可以接受方法调用的远程对象。服务器端的 Skeleton 完成对服务器对象实际的方法调用，并获取返回值。返回值向下经 Remote Reference Layer 、服务器端的 Transport Layer 传递回客户端，再向上经 Transport Layer 和 Remote Reference Layer 返回。最后，Stub 程序获得返回值。</p>
<p>要完成以上步骤需要有以下几个步骤：</p>
<ul>
<li>生成一个远程接口；</li>
<li>实现远程对象(服务器端程序)；</li>
<li>生成 Stub 和 Skeleton(服务器端程序)；</li>
<li>编写服务器程序 ；</li>
<li>编写客户程序 ；</li>
<li>注册远程对象；</li>
<li>启动远程对象</li>
</ul>
<p><a href="https://imgtu.com/i/jyJxeO"><img src="https://s1.ax1x.com/2022/07/10/jyJxeO.jpg" alt="jyJxeO.jpg"></a></p>
<p>图8 Java RMI 架构</p>
<p>RMI 分布式垃圾回收</p>
<p>根据 Java 虚拟机的垃圾回收机制原理，在分布式环境下，服务器进程需要知道哪些对象不再由客户端引用，从而可以被删除(垃圾回收)。在 JVM中,Java 使用引用计数。当引用计数归零时，对象将会垃圾回收。在RMI,Java 支持两种操作:dirty 和 clean。本地 JVM 定期发送一个 dirty 到服务器来说明该对象仍在使用。定期重发 dirty 的周期是由服务器租赁时间来决定的。当客户端没有需要更多的本地引用远程对象时,它发送一个 clean 调用给服务器。不像 DCOM,服务器不需要计算每个客户机使用的对象,只是简单的做下通知。如果它租赁时间到期之前没有接收到任何 dirty 或者 clean 的消息，则可以安排将对象删除。</p>
<h2 id="第三代-RPC-以及-Web-Services"><a href="#第三代-RPC-以及-Web-Services" class="headerlink" title="第三代 RPC 以及 Web Services"></a>第三代 RPC 以及 Web Services</h2><p>由于互联网的兴起，Web 浏览器成为占主导地位的用于访问信息的模型。现在的应用设计的首要任务大多数是提供用户通过浏览器来访问，而不是编程访问或操作数据。</p>
<p>网页设计关注的是内容。解析展现方面往往是繁琐的。传统 RPC 解决方案可以工作在互联网上，但问题是，他们通常严重依赖于动态端口分配，往往要进行额外的防火墙配置。</p>
<p>Web Services 成为一组协议,允许服务被发布、发现，并用于技术无关的形式。即服务不应该依赖于客户的语言、操作系统或机器架构。</p>
<p>Web Services 的实现一般是使用 Web 服务器作为服务请求的管道。客户端访问该服务，首先是通过一个 HTTP 协议发送请求到服务器上的 Web 服务器。Web 服务器配置识别 URL 的一部分路径名或文件名后缀并将请求传递给特定的浏览器插件模块。这个模块可以除去头、解析数据(如果需要),并根据需要调用其他函数或模块。对于这个实现流，一个常见的例子是浏览器对于 Java Servlet 的支持。HTTP 请求会被转发到 JVM 运行的服务端代码来执行处理。</p>
<h3 id="XML-RPC"><a href="#XML-RPC" class="headerlink" title="XML-RPC"></a>XML-RPC</h3><p>XML-RPC 是1998年作为一个 RPC 消息传递协议，将请求和响应封装解析为人类可读的 XML 格式。XML 格式基于 HTTP 协议，缓解了传统企业的防火墙需要为 RPC 服务器应用程序打开额外的端口的问题。</p>
<p>下面是一个 XML-RPC 消息的例子:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span></span><br><span class="line">        sample.sumAndDifference</span><br><span class="line">    <span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">int</span>&gt;</span> 5 <span class="tag">&lt;/<span class="name">int</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">int</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">int</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，方法 sumAndDifference 有两个整数参数 5 和 3。</p>
<p>XML-RPC 支持的基本数据类型是:int、string、boolean、double 和 dateTime.iso8601。此外,还有 base64 类型用于编码任意二进制数据。array 和 struct 允许定义数组和结构。</p>
<p>XML-RPC 不限制语任何特定的语言，也不是一套完整的软件来处理远程过程，诸如存根生成、对象管理和服务查找都不在协议内。现在有很多库针可以针对不同的语言，比如 Apache XML-RPC 可以用于 Java、Python 和 Perl。</p>
<p>XML-RPC 是一个简单的规范(约7页)，没有雄心勃勃的目标——它只关注消息，而并不处理诸如垃圾收集、远程对象、远程过程的名称服务和其他方面的问题。然而，即使没有广泛的产业支持，简单的协议却能广泛采用。</p>
<h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><p>SOAP（Simple Object Access Protocol，简单对象访问协议），是以 XML-RPC 规范作为创建 SOAP 的依据，成立于1998年，获得微软和 IBM 的大力支持。该协议在创建初期只作为一种对象访问协议，但由于 SOAP 的发展，其协议已经不单只是用于简单的访问对象，所以这种 SOAP 缩写已经在标准的1.2版后被废止了。1.2版在2003年6月24日成为 W3C 的推荐版本。SOAP 指定 XML 作为无状态的消息交换格式，包括了 RPC 式的过程调用。</p>
<p>有关 SOAP 的标准可以参阅 <a href="https://www.w3.org/TR/soap/">SOAP Specifications</a>。</p>
<p>SOAP 只是一种消息格式，并未定义垃圾回收、对象引用、存根生成和传输协议。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">env:Envelope</span> <span class="attr">xmlns:env</span>=<span class="string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">env:Header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">m:reservation</span> <span class="attr">xmlns:m</span>=<span class="string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">env:role</span>=<span class="string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">env:mustUnderstand</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">m:reference</span>&gt;</span>uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="tag">&lt;/<span class="name">m:reference</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">m:dateAndTime</span>&gt;</span>2001-11-29T13:20:00.000-05:00<span class="tag">&lt;/<span class="name">m:dateAndTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">m:reservation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">n:passenger</span> <span class="attr">xmlns:n</span>=<span class="string">&quot;http://mycompany.example.com/employees&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">env:role</span>=<span class="string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">env:mustUnderstand</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="tag">&lt;/<span class="name">n:name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">n:passenger</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">env:Header</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">env:Body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p:itinerary</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p:departure</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:departing</span>&gt;</span>New York<span class="tag">&lt;/<span class="name">p:departing</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:arriving</span>&gt;</span>Los Angeles<span class="tag">&lt;/<span class="name">p:arriving</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:departureDate</span>&gt;</span>2001-12-14<span class="tag">&lt;/<span class="name">p:departureDate</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:departureTime</span>&gt;</span>late afternoon<span class="tag">&lt;/<span class="name">p:departureTime</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:seatPreference</span>&gt;</span>aisle<span class="tag">&lt;/<span class="name">p:seatPreference</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">p:departure</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p:return</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:departing</span>&gt;</span>Los Angeles<span class="tag">&lt;/<span class="name">p:departing</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:arriving</span>&gt;</span>New York<span class="tag">&lt;/<span class="name">p:arriving</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:departureDate</span>&gt;</span>2001-12-20<span class="tag">&lt;/<span class="name">p:departureDate</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:departureTime</span>&gt;</span>mid-morning<span class="tag">&lt;/<span class="name">p:departureTime</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p:seatPreference</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">p:return</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p:itinerary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">q:lodging</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:q</span>=<span class="string">&quot;http://travelcompany.example.org/reservation/hotels&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">q:preference</span>&gt;</span>none<span class="tag">&lt;/<span class="name">q:preference</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">q:lodging</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">env:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">env:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;soap:Envelope&gt;</code>是 SOAP 消息中的根节点，是 SOAP 消息中必须的部分。<code>&lt;soap:Header&gt;</code>是 SOAP 消息中可选部分，是指消息头。<code>&lt;soap:Body&gt;</code>是 SOAP 中必须部分，是指消息体。</p>
<p>上面例子的 SOAP 消息结构如下：</p>
<p><a href="https://imgtu.com/i/jyJzwD"><img src="https://s1.ax1x.com/2022/07/10/jyJzwD.jpg" alt="jyJzwD.jpg"></a></p>
<p>图9 SOAP 消息结构</p>
<p>SOAP 它只是提供了一个标准化的消息结构，为了实现它往往需要用 WSDL 来描述 Web Services 的方法。WSDL (Web Services Description Language) 是基于 XML 的一种用于描述 Web Services 以及如何访问 Web Services 的语言。</p>
<p>WSDL 文档包括以下几个部分:</p>
<ul>
<li>类型（Types）:定义了 Web Services 使用的数据类型；</li>
<li>消息（n&#x2F;a）:描述使用消息的数据元素或参数；</li>
<li>接口（Interface）:描述服务提供的操作。这包括操作以及每个操作所使用的输入和输出消息；</li>
<li>绑定（Binding）:为每个端口定义消息格式和协议细节。例如,它可以定义 RPC 式的消息；</li>
<li>服务（Service）：系统功能相关的集合，包括其关联的接口、操作、消息等；</li>
<li>终点（Endpoint）：定义了地址或者 Web Services 的连接点；</li>
<li>操作（Operation）：定义了 SOAP 的动作，以及消息编码的方式。</li>
</ul>
<p>下面是一个 WSDL 2.0 版本的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/ns/wsdl&quot;</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:tns</span>=<span class="string">&quot;http://www.tmsws.com/wsdl20sample&quot;</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:whttp</span>=<span class="string">&quot;http://schemas.xmlsoap.org/wsdl/http/&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:wsoap</span>=<span class="string">&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.tmsws.com/wsdl20sample&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">documentation</span>&gt;</span></span><br><span class="line">    This is a sample WSDL 2.0 document. </span><br><span class="line"><span class="tag">&lt;/<span class="name">documentation</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Abstract type --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">types</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">xmlns</span>=<span class="string">&quot;http://www.tmsws.com/wsdl20sample&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.example.com/wsdl20sample&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;request&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;response&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">types</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Abstract interfaces --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interface</span> <span class="attr">name</span>=<span class="string">&quot;Interface1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fault</span> <span class="attr">name</span>=<span class="string">&quot;Error1&quot;</span> <span class="attr">element</span>=<span class="string">&quot;tns:response&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">operation</span> <span class="attr">name</span>=<span class="string">&quot;Get&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;http://www.w3.org/ns/wsdl/in-out&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">messageLabel</span>=<span class="string">&quot;In&quot;</span> <span class="attr">element</span>=<span class="string">&quot;tns:request&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">output</span> <span class="attr">messageLabel</span>=<span class="string">&quot;Out&quot;</span> <span class="attr">element</span>=<span class="string">&quot;tns:response&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">operation</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Concrete Binding Over HTTP --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">&quot;HttpBinding&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;tns:Interface1&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;http://www.w3.org/ns/wsdl/http&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">operation</span> <span class="attr">ref</span>=<span class="string">&quot;tns:Get&quot;</span> <span class="attr">whttp:method</span>=<span class="string">&quot;GET&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Concrete Binding with SOAP--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">&quot;SoapBinding&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;tns:Interface1&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;http://www.w3.org/ns/wsdl/soap&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">wsoap:protocol</span>=<span class="string">&quot;http://www.w3.org/2003/05/soap/bindings/HTTP/&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">wsoap:mepDefault</span>=<span class="string">&quot;http://www.w3.org/2003/05/soap/mep/request-response&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">operation</span> <span class="attr">ref</span>=<span class="string">&quot;tns:Get&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Web Service offering endpoints for both bindings--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">&quot;Service1&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;tns:Interface1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">endpoint</span> <span class="attr">name</span>=<span class="string">&quot;HttpEndpoint&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">binding</span>=<span class="string">&quot;tns:HttpBinding&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">address</span>=<span class="string">&quot;http://www.example.com/rest/&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">endpoint</span> <span class="attr">name</span>=<span class="string">&quot;SoapEndpoint&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">binding</span>=<span class="string">&quot;tns:SoapBinding&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">address</span>=<span class="string">&quot;http://www.example.com/soap/&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Microsoft-NET-Remoting"><a href="#Microsoft-NET-Remoting" class="headerlink" title="Microsoft .NET Remoting"></a>Microsoft .NET Remoting</h3><p>从微软的产品角度来看，可以说 .NET Remoting 就是 DCOM 的一种升级，它改善了很多功能，并极好的融合到 .NET 平台下。Microsoft .NET Remoting 提供了一种允许对象通过应用程序域与另一对象进行交互的框架。</p>
<p>.NET Remoting 提供了一种允许对象通过应用程序域与另一对象进行交互的框架。这种框架提供了多种服务，包括激活和生存期支持，以及负责与远程应用程序进行消息传输的通讯通道。格式化程序用于在消息通过通道传输之前，对其进行编码和解码。应用程序可以在注重性能的场合使用二进制编码，在需要与其他远程处理框架进行交互的场合使用 XML 编码。在从一个应用程序域向另一个应用程序域传输消息时，所有的 XML 编码都使用 SOAP 协议。出于安全性方面的考虑，远程处理提供了大量挂钩，使得在消息流通过通道进行传输之前，安全接收器能够访问消息和序列化流</p>
<p>.NET Remoting 对象</p>
<p>有三类对象可以配置为 .NET Remoting 对象。您可以根据应用程序的需要来选择对象类型：</p>
<ul>
<li>Single Call（单一调用对象）： Single Call 能且只能为一个请求提供服务。在需要对象完成的工作量有限的情况下 Single Call 非常有用。Single Call 对象通常不要求存储状态信息，并且不能在方法调用之间保留状态信息。但是，Single Call对象可以配置为负载平衡模式。</li>
<li>Singleton Objects（单一元素对象）： Singleton Objects 可以为多个客户端提供服务，因此可以通过保存客户端调用的状态信息来实现数据共享。当客户端之间需要明确地共享数据，并且不能忽略创建和维护对象的开销时，这类对象非常有用。</li>
<li>Client-Activated Objects (CAO，客户端激活的对象)： CAO 是服务器端的对象，将根据来自客户端的请求激活这些对象。这种激活服务器对象的方法与传统的 COM coclass 激活方法非常相似。当客户端使用“new”运算符提交对服务器对象的请求时，会向远程应用程序发送一个激活请求消息。随后，服务器创建被请求类的实例，并向调用它的客户端应用程序返回 ObjRef。然后，使用此 ObjRef 在客户端上创建代理。客户端的方法调用将在代理上执行。客户端激活的对象可以为特定的客户端（不能跨越不同的客户端对象）保存方法调用之间的状态信息。每个“new”调用都会向服务器类型的独立实例返回代理。</li>
</ul>
<p>在 .NET Remoting 中，可以通过以下方式在应用程序之间传递对象：</p>
<ul>
<li>作为方法调用中的参数，例如：<code>public int myRemoteMethod (MyRemoteObject myObj)</code></li>
<li>方法调用的返回值,例如：<code>public MyRemoteObject myRemoteMethod(String myString)</code></li>
<li>访问 .NET 组件的属性或字段得到的值,例如：<code>myObj.myNestedObject</code></li>
</ul>
<p>对于 Marshal By Value (MBV,按值封送)的对象，当它在应用程序之间传递时，将创建一个完整的副本。</p>
<p>对于 Marshal By Reference (MBR，按引用封送)的对象，当它在应用程序之间传递时，将创建该对象的引用。当对象引用 (ObjRef) 到达远程应用程序后，将转变成“代理”返回给原始对象。 　　 下面是一个简单 .NET Remoting 服务器对象的代码示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">using <span class="title class_">System</span>;</span><br><span class="line">using <span class="title class_">System</span>.<span class="property">Runtime</span>.<span class="property">Remoting</span>;</span><br><span class="line"><span class="keyword">namespace</span> myRemoteService</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Well Known Web Service object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRemoteObject</span> : <span class="title class_">MarshalByRefObject</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Method myRemoteMethod</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">myRemoteMethod</span>(<span class="params"><span class="built_in">String</span> s</span>) </span><br><span class="line">        &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是客户端代码来访问这个对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Channels;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Channels.Http;</span><br><span class="line"><span class="keyword">using</span> myRemoteService;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ChannelServices.RegisterChannel(<span class="keyword">new</span> HttpChannel());</span><br><span class="line">      <span class="comment">// Create an instance of a myRemoteObject class </span></span><br><span class="line">   myRemoteObject myObj = ( myRemoteObject)Activator.GetObject(<span class="keyword">typeof</span>(myRemoteObject),</span><br><span class="line">            <span class="string">&quot;http://myHost:7021/host/myRemoteObject.soap&quot;</span>);</span><br><span class="line">      myObj. myRemoteMethod (<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>租用生存期</p>
<p>对于那些具有在应用程序之外传送的对象引用的对象，将创建一个租用。租用具有一个租用时间。如果租用时间为 0，则租用过期，对象就断开与 .NET Romoting 框架的连接。一旦 AppDomain 中的所有对象引用都被释放，则下次垃圾回收时，该对象将被回收。租用控制了对象的生存期。</p>
<p>对象有默认的租用阶段。当客户端要在同一服务器对象中维护状态时，可以通过许多方法扩展租用阶段，使对象继续生存:</p>
<ul>
<li>服务器对象可以将其租用时间设置为无限，这样 Remoting 在垃圾回收时就不会回收此对象。</li>
<li>客户端可以调用 <code>RemotingServices.GetLifetimeService</code> 方法，从 AppDomain 的租用管理器获取服务器对象的租用。然后，客户端可以通过 Lease 对象调用 Lease.Renew 方法以延长租用。</li>
<li>客户端可用 AppDomain 的租用管理器为特定的租用注册负责人。当 Remoting 对象的租用过期时，租用管理器将通知负责人提出续租的申请。</li>
<li>如果设置了 <code>ILease::RenewOnCallTime</code> 属性，则每次调用 Remoting 对象时，都会用 RenewOnCallTime 属性指定的总时间更新租用。</li>
</ul>
<p>集成 .NET Remoting 对象</p>
<p>.NET Remoting 对象可以集成在：</p>
<ul>
<li>托管可执行项: .NET Remoting 对象可以集成在任何常规的 .NET EXE 或托管服务中。</li>
<li>.NET 组件服务: .NET Remoting 对象可以集成在 .NET 组件服务基础结构中，以便利用各种 COM+ 服务，例如：事务、JIT 和对象池等。</li>
<li>IIS : .NET Remoting 对象可以集成在 Internet Information Server (IIS) 中。默认情况下，集成在 IIS 中的 Remoting 对象通过 HTTP 通道接收消息。要在 IIS 中集成 Remoting 对象，必须创建一个虚拟的根，并将 remoting.config 文件复制到其中。包含 Remoting 对象的可执行文件或 DLL 应放在 IIS 根指向的目录下的 bin 目录中。需要注意的是，IIS 根名称应该与配置文件中指定的应用程序名称相同。当第一个消息到达应用程序时，Remoting 配置文件会自动加载。使用这种方法，可以提供 .NET Remoting 对象作为 Web 服务。</li>
</ul>
<p>下面是一个 Remoting.cfg 文件的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">system.runtime.remoting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">name</span>=<span class="string">&quot;RemotingHello&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wellknown</span> <span class="attr">mode</span>=<span class="string">&quot;SingleCall&quot;</span> </span></span><br><span class="line"><span class="tag">                   <span class="attr">type</span>=<span class="string">&quot;Hello.HelloService, Hello&quot;</span> </span></span><br><span class="line"><span class="tag">                   <span class="attr">objectUri</span>=<span class="string">&quot;HelloService.soap&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">channels</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">channel</span> <span class="attr">port</span>=<span class="string">&quot;8000&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;System.Runtime.Remoting.Channels.Http.HttpChannel, </span></span></span><br><span class="line"><span class="string"><span class="tag">System.Runtime.Remoting&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">channels</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">system.runtime.remoting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通道服务 (System.Runtime.Remoting.Channels)</p>
<p>.NET 应用程序和 AppDomain 之间使用消息进行通信。.NET 通道服务为这一通信过程提供了基础传输机制。</p>
<p>.NET 框架提供了 HTTP 和 TCP 通道，但是第三方也可以编写并使用自己的通道。默认情况下，HTTP 通道使用 SOAP 进行通信，TCP 通道使用二进制有效负载。</p>
<p>通过使用可以编写到集成混合应用程序中的自定义通道，可以插入通道服务（使用 IChannel）。</p>
<p>下面是一个加载通道服务的例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">myRemotingObj</span></span><br><span class="line">&#123;</span><br><span class="line">    HttpChannel httpChannel;</span><br><span class="line">    TcpChannel tcpChannel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myRemotingMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        httpChannel =  <span class="keyword">new</span> HttpChannel();</span><br><span class="line">        tcpChannel  =  <span class="keyword">new</span> TcpChannel();</span><br><span class="line">        ChannelServices.RegisterChannel(httpChannel);</span><br><span class="line">        <span class="comment">// Register the HTTP Channel </span></span><br><span class="line">        ChannelServices.RegisterChannel(tcpChannel);</span><br><span class="line">        <span class="comment">// Register the TCP Channel  </span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>序列化格式化程序 (System.Runtime.Serialization.Formatters)</p>
<p>.NET 序列化格式化程序对 .NET 应用程序和 AppDomain 之间的消息进行编码和解码。在 .NET 运行时中有两个本地格式化程序，分别为二进制 (<code>System.Runtime.Serialization.Formatters.Binary</code>) 和 SOAP (<code>System.Runtime.Serialization.Formatters.Soap</code>)。</p>
<p>通过实现 IRemotingFormatter 接口，并将其插入到上文介绍的通道中，可以插入序列化格式化程序。这样，您可以灵活地选择通道和格式化程序的组合方式，采用最适合应用程序的方案。</p>
<p>例如：您可以采用 HTTP 通道和二进制格式化程序（串行化二进制数据），也可以采用 TCP 通道和 SOAP 格式。</p>
<p>Remoting 上下文</p>
<p>上下文是一个包含共享公共运行时属性的对象的范围。某些上下文属性的例子是与同步和线程紧密相关的。当 .NET 对象被激活时，运行时将检查当前上下文是否一致，如果不一致，将创建新的上下文。多个对象可以同时在一个上下文中运行，并且一个 AppDomain 中可以有多个上下文。</p>
<p>一个上下文中的对象调用另一个上下文中的对象时，调用将通过上下文代理来执行，并且会受组合的上下文属性的强制策略影响。新对象的上下文通常是基于类的元数据属性选择的。</p>
<p>可以与上下文绑定的类称作上下文绑定类。上下文绑定类可以具有称为上下文属性的专用自定义属性。上下文属性是完全可扩展的，您可以创建这些属性并将它们附加到自己的类中。与上下文绑定的对象是从 <code>System.ContextBoundObject</code> 导出的。</p>
<p>.NET Remoting 元数据和配置文件</p>
<p>元数据</p>
<p>.NET 框架使用元数据和程序集来存储有关组件的信息，使得跨语言编程成为可能。.NET Remoting 使用元数据来动态创建代理对象。在客户端创建的代理对象具有与原始类相同的成员。但是，代理对象的实现仅仅将所有请求通过 .NET Remoting 运行时转发给原始对象。序列化格式化程序使用元数据在方法调用和有效负载数据流之间来回转换。</p>
<p>客户端可以通过以下方法获取访问 Remoting 对象所需的元数据信息：</p>
<ul>
<li>服务器对象的 .NET 程序集 : 服务器对象可以创建元数据程序集，并将其分发给客户端。在编译客户端对象时，客户端对象可以引用这些程序集。在客户端和服务器都是托管组件的封闭环境中，这种方法非常有用。</li>
<li>Remoting 对象可以提供 WSDL文件，用于说明对象及其方法。所有可以根据 WSDL 文件读取和生成 SOAP 请求的客户端都可以调用此对象，或使用 SOAP 与之通信。使用与 .NET SDK 一同分发的 SOAPSUDS.EXE 工具，.NET Remoting 服务器对象可以生成具有元数据功能的 WSDL 文件。当某个组织希望提供所有客户都能访问和使用的公共服务时，这种方法非常有用。</li>
<li>.NET 客户可以使用 SOAPSUDS 工具从服务器上下载 XML 架构（在服务器上生成），生成仅包含元数据（没有代码）的源文件或程序集。您可以根据需要将源文件编译到客户端应用程序中。如果多层应用程序中某一层的对象需要访问其他层的 Remoting 对象，则经常使用此方法。</li>
</ul>
<p>配置文件</p>
<p>　　 配置文件（.config 文件）用于指定给定对象的各种 Remoting 特有信息。通常情况下，每个 AppDomain 都有自己的配置文件。使用配置文件有助于实现位置的透明性。配置文件中指定的详细信息也可以通过编程来完成。使用配置文件的主要好处在于，它将与客户端代码无关的配置信息分离出来，这样在日后更改时仅需要修改配置文件，而不用编辑和重新编译源文件。.NET Remoting 的客户端和服务器对象都使用配置文件。</p>
<p>典型的配置文件包含以下信息及其他信息：</p>
<ul>
<li>集成应用程序信息</li>
<li>对象名称</li>
<li>对象的 URI</li>
<li>注册的通道（可以同时注册多个通道）</li>
<li>服务器对象的租用时间信息</li>
</ul>
<p>下面是一个配置文件示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">system.runtime.remoting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">name</span>=<span class="string">&quot;HelloNew&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">lifetime</span> <span class="attr">leaseTime</span>=<span class="string">&quot;20ms&quot;</span> <span class="attr">sponsorshipTimeout</span>=<span class="string">&quot;20ms&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">renewOnCallTime</span>=<span class="string">&quot;20ms&quot;</span> /&gt;</span>  </span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">client</span> <span class="attr">url</span>=<span class="string">&quot;http://localhost:8000/RemotingHello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wellknown</span> <span class="attr">type</span>=<span class="string">&quot;Hello.HelloService, MyHello&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">url</span>=<span class="string">&quot;http://localhost:8000/RemotingHello/HelloService.soap&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activated</span> <span class="attr">type</span>=<span class="string">&quot;Hello.AddService, MyHello&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">client</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">channels</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">channel</span> <span class="attr">port</span>=<span class="string">&quot;8001&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;System.Runtime.Remoting.Channels.Http.HttpChannel, </span></span></span><br><span class="line"><span class="string"><span class="tag">      System.Runtime.Remoting&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">channels</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">system.runtime.remoting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>.NET Remoting 方案</p>
<p>了解 .NET Remoting 如何工作之后，让我们来看一下各种方案，分析如何在不同的方案中充分发挥 .NET Remoting 的优势。下表列出了可能的客户端&#x2F;服务器组合，以及默认情况下采用的底层协议和有效负载。请注意，.NET Remoting 框架是可扩展的，您可以编写自己的通信通道和序列化格式化程序。</p>
<table>
<thead>
<tr>
<th align="left">客户端</th>
<th align="left">服务器</th>
<th align="left">有效负载</th>
<th align="left">协议</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.NET 组件</td>
<td align="left">.NET 组件</td>
<td align="left">SOAP&#x2F;XML</td>
<td align="left">http</td>
</tr>
<tr>
<td align="left">.NET 组件</td>
<td align="left">.NET 组件</td>
<td align="left">二进制</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">托管&#x2F;非托管</td>
<td align="left">.NET Web 服务</td>
<td align="left">SOAP&#x2F;XML</td>
<td align="left">http</td>
</tr>
<tr>
<td align="left">.NET 组件</td>
<td align="left">非托管的传统 COM 组件</td>
<td align="left">NDR（网络数据表示形式）</td>
<td align="left">DCOM</td>
</tr>
<tr>
<td align="left">非托管的传统 COM 组件</td>
<td align="left">.NET 组件</td>
<td align="left">NDR</td>
<td align="left">DCOM</td>
</tr>
</tbody></table>
<p>使用 HTTP-SOAP</p>
<p>Web 服务是可以通过 URL 寻址的资源，并通过编程向需要使用这些资源的客户端返回信息。客户端使用 Web Services 时不必考虑其实现细节。Web Services 使用称为“合约”的严格定义的接口，此接口采用 Web 服务说明语言 (WSDL) 文件描述。</p>
<p>.NET Remoting 对象可以集成在 IIS 中，作为 Web 服务提供。任何可以使用 WSDL 文件的客户端都可以按照 WSDL 文件中指定的合约，对 Remoting 对象执行 SOAP 调用。IIS 使用 ISAPI 扩展将这些请求路由到相应的对象。这样，Remoting 对象就可以作为 Web 服务对象来使用，从而充分发挥 .NET 框架基础结构的作用。如果您希望不同平台&#x2F;环境的程序均能够访问对象，可以采用这种配置。这种配置便于客户端通过防火墙访问您的 .NET 对象。</p>
<p><a href="https://imgtu.com/i/jyYSTe"><img src="https://s1.ax1x.com/2022/07/10/jyYSTe.jpg" alt="jyYSTe.jpg"></a></p>
<p>图10 .NET 使用 HTTP-SOAP</p>
<p>使用 SOAP-HTTP 通道</p>
<p>默认情况下，HTTP 通道使用 SOAP 格式化程序。因此，如果客户端需要通过 Internet 访问对象，可以使用 HTTP 通道。因为这种方法使用 HTTP，所以此配置允许通过防火墙远程访问 .NET 对象。只需要按前一节中介绍的方法将这些对象集成在 IIS 中，即可将它配置为 Web 服务对象。随后，客户端就可以读取这些对象的 WSDL 文件，使用 SOAP 与 Remoting 对象通信。</p>
<p>使用 TCP 通道</p>
<p>默认情况下，TCP 通道使用二进制格式化程序。此格式化程序以二进制格式对数据进行序列化，并使用原始 socket 在网络中传送数据。如果对象部署在受防火墙保护的封闭环境中，此方法是理想的选择。这种方法使用 socket 在对象之间传递二进制数据，因此性能极佳。由于它使用 TCP 通道来提供对象，因此在封闭环境中具有低开销的优点。由于防火墙和配置的问题，此方法不宜在 Internet 上使用。</p>
<p><a href="https://imgtu.com/i/jyY9FH"><img src="https://s1.ax1x.com/2022/07/10/jyY9FH.jpg" alt="jyY9FH.jpg"></a></p>
<p>图11 .NET 使用 TCP 通道</p>
<p>使用非托管的 COM 组件</p>
<p>可以通过 COM Interop Service 调用非托管的传统 COM 组件。当 .NET Remoting 客户端对象创建 COM 对象的实例时，该对象通过运行时可调用包装程序 (RCW) 来提供。其中，RCW 担当真正的非托管对象的代理。对于 .NET 客户，这些包装程序看起来和 .NET 客户端的任何其他托管类一样。但实际上，它们仅仅是托管 (.NET) 和非托管 (COM) 代码之间的封送调用。</p>
<p>同样地，您可以将 .NET Remoting 服务器对象提供给传统 COM 客户端。当 COM 客户端创建 .NET 对象的实例时，该对象通过 COM 可调用包装程序 (CCW) 来提供。其中，CCW 担当真正的托管对象的代理。 　　 这两种方案都使用 DCOM 通信。如果环境中既有传统的 COM 组件，又有 .NET 组件，那么这种互操作性将为您提供便利。 　　</p>
<p>总结</p>
<p>Microsoft .NET 框架提供了强大、可扩展、独立于语言的框架，适合开发可靠、可伸缩的分布式系统。.NET Romoting 框架提供了根据系统需求进行远程交互的强大手段。.NET Remoting 实现了与 Web 服务的无缝集成，并提供了一种方法，可以提供 .NET 对象以供跨平台访问。</p>
<h3 id="Java-中的-XML-Web-Services"><a href="#Java-中的-XML-Web-Services" class="headerlink" title="Java 中的 XML Web Services"></a>Java 中的 XML Web Services</h3><p>Java RMI 与远程对象进行交互，其实现是需要基于 Java 的模型。此外,它没有使用 Web Services 和基于 HTTP 的消息传递。现在，已经出现了大量的软件来支持基于 Java 的 Web Services。JAX-WS (Java API for XML Web Services) 就是作为 Web Services 消息息和远程过程调用的规范。它允许一个调用基于Java的web服务使用Java RMI(即。,相对透明的程序员)。JAX-WS 的一个目标是平台互操作性。其 API 使用 SOAP 和WSDL。双方不需要 Java 环境。</p>
<p>创建一个 RPC 端点</p>
<p>在服务器端,进行下面的步骤来创建一个 RPC 端点:</p>
<ul>
<li>定义一个接口(Java接口)；</li>
<li>实现服务；</li>
<li>创建一个发布者,用于创建服务的实例，并发布一个服务名字。</li>
</ul>
<p>在客户端:</p>
<ul>
<li>创建一个代理(客户端存根)。wsimport 命令根据 WSDL 文档,创建一个客户机存根；</li>
<li>编写一个客户端，通过代理创建远程服务的一个实例(存根),调用它的方法。</li>
</ul>
<p>JAX-RPC 执行流程如下:</p>
<ul>
<li>Java 客户机调用存根上的方法(代理)；</li>
<li>存根调用适当的 Web 服务；</li>
<li>Web 服务器被调用并指导 JAX-WS 框架；</li>
<li>框架调用实现；</li>
<li>实现返回结果给该框架；</li>
<li>该框架将结果返回给 Web 服务器；</li>
<li>服务器将结果发送给客户端存根；</li>
<li>客户端存根返回信息给调用者；</li>
</ul>
<p><a href="https://imgtu.com/i/jyYPfA"><img src="https://s1.ax1x.com/2022/07/10/jyYPfA.jpg" alt="jyYPfA.jpg"></a></p>
<p>图12 JAX-WS 调用流程</p>
<h3 id="超越-SOAP"><a href="#超越-SOAP" class="headerlink" title="超越 SOAP"></a>超越 SOAP</h3><p>SOAP 虽然仍然是广泛部署应用，但在许多环境中很多厂商已经抛弃了 SOAP，转而使用其他更轻量、更容易理解、或者与 Web 交互模型更干净的机制。例如,Google 的 API 在2006年后就不再支持 SOAP 接口，而是使用AJAX、XML-RPC 和 REST 作为替代。一个匿名的微软员工批评 SOAP 过于复杂，因为“我们希望我们的工具来阅读它,而不是人”。不管上述言论是否准确，有一点是可以肯定的，SOAP 显然是一个复杂和高度冗长的格式。</p>
<p>AJAX</p>
<p>Web 浏览器最初的设计，是为 Web 页面提供非动态的交互模型。Web 浏览器是建立在同步的请求-响应(request-response)的交互模型。发送一个请求到服务器,服务器返回整个页面。在当时没有更新部分页面的好方法，而唯一可行的方法是利用帧，即将不同的页面加载到每一帧，其实现是笨重的，也有很大的限制性。而改变了这一切的关键因素是：</p>
<ul>
<li>文档对象模型（Document Object Model）和 JavaScript 的出现,使得可以以编程方式来更改 Web 页面的各个部分；</li>
<li>AJAX 提供了与服务器以非阻塞方式进行交互，即允许底层 JavaScript 在等待服务器结果时，用户仍然可以与页面进行交互。</li>
</ul>
<p>AJAX 全称是 Asynchronous JavaScript And XML（异步的 JavaScript 和 XML）。让我们看看这些三项:</p>
<ul>
<li>它是异步的,因为客户端等待服务器结果不会被阻塞；</li>
<li>AJAX 集成到了 JavaScript，作为浏览器解释 Web 页面的一部分。JavaScript 使用 HTTPRequest 来调用 AJAX 请求。JavaScript 也可能修改文档对象模型，定义了页面的样子；</li>
<li>数据以 XML 文档形式发送和接收。（在后期发展中，AJAX 也支持其他的数据格式，比如 JSON）</li>
</ul>
<p>AJAX 在推动 Web 2.0 的过程中发挥了重要的，比如产生了很多高度交互的服务,如Google Maps、Writely等。基本上,它允许 JavaScript 发出HTTP 请求，获取和处理结果，刷新局部页面元素而不是整个页面。在大多数浏览器请求的格式如下:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xmlhttp.open(“HEAD”, “index.html”, <span class="literal">true</span>)Tell <span class="built_in">object</span>:</span><br></pre></td></tr></table></figure>

<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>SOAP 在创建自己的消息传递协议时是基于HTTP，但实际上 REST (REpresentational State Transfer) 的方式才是保持 Web 的原理和使用 HTTP 协议的核心部分。</p>
<p>原始的 HTTP 协议已经定义了四个命令，清晰地映射到各种数据(定义为“资源”)操作:</p>
<ul>
<li>PUT (插入)</li>
<li>GET (选择)</li>
<li>POST (更新)</li>
<li>DELETE (删除)</li>
</ul>
<p>REST 其背后的理念是使用这些 HTTP 命令来请求和操作数据。作为 HTTP协议的一部分，REST 使用 URL 来引用对象和操作。考虑这个 HTTP 操作列表的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span> <span class="variable constant_">GET</span> <span class="comment">//www.waylau.com/parts</span></span><br></pre></td></tr></table></figure>

<p>这个命令将返回一个 XML 文档,其中包含部分的列表。注意,返回的不是一个网页,只是一个包含所请求的数据 XML 数据结构。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p:Parts</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.waylau.com&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Part</span> <span class="attr">id</span>=<span class="string">&quot;00345&quot;</span> <span class="attr">xlink:href</span>=<span class="string">&quot;http://www.waylau.com/parts/00345&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Part</span> <span class="attr">id</span>=<span class="string">&quot;00346&quot;</span> <span class="attr">xlink:href</span>=<span class="string">&quot;http://www.waylau.com/parts/00346&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Part</span> <span class="attr">id</span>=<span class="string">&quot;00347&quot;</span> <span class="attr">xlink:href</span>=<span class="string">&quot;http://www.waylau.com/parts/00347&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Part</span> <span class="attr">id</span>=<span class="string">&quot;00348&quot;</span> <span class="attr">xlink:href</span>=<span class="string">&quot;http://www.waylau.com/parts/00348&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p:Parts</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要特定部分的详细信息,发送一个HTTP get 命令:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span> <span class="variable constant_">GET</span> <span class="comment">//www.waylau.com/parts/00345</span></span><br></pre></td></tr></table></figure>

<p>这将返回一个特定的信息部分:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p:Part</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.waylau.com&quot;</span>   </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Part-ID</span>&gt;</span>00345<span class="tag">&lt;/<span class="name">Part-ID</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Widget-A<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Description</span>&gt;</span>This part is used within the frap assembly<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Specification</span> <span class="attr">xlink:href</span>=<span class="string">&quot;http://www.waylau.com/parts/00345/specification&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">UnitCost</span> <span class="attr">currency</span>=<span class="string">&quot;USD&quot;</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">UnitCost</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Quantity</span>&gt;</span>10<span class="tag">&lt;/<span class="name">Quantity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p:Part</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，上面例子简化了 partid 作为 URL 的参数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span> <span class="variable constant_">GET</span> <span class="comment">//www.waylau.com/parts?partid=00345</span></span><br></pre></td></tr></table></figure>

<p>REST 不是 RPC，但也有类似的请求-响应模式。制定透明度请求、封送数据、解析响应这些不属于 REST。REST 应用非常广泛，如 Yahoo! Search API、Ruby on Rails、Twiter 和 Open Zing Services 等。</p>
<h3 id="Google-Protocol-Buffers-封送处理"><a href="#Google-Protocol-Buffers-封送处理" class="headerlink" title="Google Protocol Buffers:封送处理"></a>Google Protocol Buffers:封送处理</h3><p>有些时候，不仅仅是为了 RPC 和 Web Services 的需要，程序员只是想简化对网络上的数据的封送编组和解封的操作。Google Protocol Buffers 就是为序列化结构化数据提供了一种有效的机制，使它容易对网络上的数据进行编码和解码。Protocol Buffers 是一个紧凑的二进制格式比 XML 更简单、体积更小、速度更快。他们是独立于语言的，只定义数据类型。每个消息是对数据名称、类型和值的结构化集合。消息结构定义在一个高级别的格式，类似于许多接口定义语言。然后文件可以根据你选择的语言来编译转换成与该语言相应的格式。Protocol Buffers 在 Google 中广泛使用。目前已经有超过48000种不同的消息类型定义。Protocol Buffers 可以被运用在类 RPC 消息传递以及持久性存储(将数据转换成标准的串行形式写入到一个文件中）。下面是一个定义 Protocol Buffers 的例子:</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">message <span class="keyword">Person</span> &#123;</span><br><span class="line">  required string <span class="literal">name</span> = <span class="number">1</span>;</span><br><span class="line">  required int32 <span class="built_in">id</span> = <span class="number">2</span>;</span><br><span class="line">  optional string email = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">message</span> <span class="keyword">PhoneNumber</span> &#123;</span><br><span class="line">    required string number = <span class="number">1</span>;</span><br><span class="line">    optional PhoneType <span class="built_in">type</span> = <span class="number">2</span> [<span class="keyword">default</span> = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">repeated</span> <span class="keyword">PhoneNumber</span> <span class="keyword">phone</span> = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这只定义了数据结构，而不是功能。使用这个结构的例子是:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Person person;</span><br><span class="line">person.set_name(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">person.set_id(<span class="number">1234</span>);</span><br><span class="line">person.set_email(<span class="string">&quot;jdoe@example.com&quot;</span>);</span><br><span class="line"><span class="function">fstream <span class="title">output</span>(<span class="params"><span class="string">&quot;myfile&quot;</span>, ios::<span class="keyword">out</span> | ios::binary</span>)</span>;</span><br><span class="line">person.SerializeToOstream(&amp;output);</span><br></pre></td></tr></table></figure>

<p>即使与紧凑的 XML 版本相比，Protocol Buffers 在时间和空间方面，解析将更加有效。下面是两者的对比.</p>
<p>这个是 XML 格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>jdoe@example.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个没有编译的 Protocol Buffers 格式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">person &#123;</span><br><span class="line">   name: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">   email: <span class="string">&quot;jdoe@example.com&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Protocol Buffers 产生的二进制消息大约是28字节长，解析耗时大概需要100-200ns。相比之下,XML 版本需要69个字节长(是 Protocol Buffers 的 2.5倍),耗时是5000-10000ns(是 Protocol Buffers 的 50倍)。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于 ECMAScript 的一个子集。JSON 采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python 等）。这些特性使 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成。JSON 不是一个诸如 Google Protocol Buffers 的二进制格式，因此适合使用基于 HTTP的消息传递。JSON 是可以作为 XML 替代品，在远程过程调用中，很多语言都支持 JSON-RPC。记住，这只是一个消息传递格式，JSON 并没有试图提供 RPC 库来支持服务发现、绑定、托管和垃圾收集。</p>
<h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><ul>
<li><a href="https://www.cs.virginia.edu/~zaher/classes/CS656/birrel.pdf">http://www.cs.virginia.edu/~zaher&#x2F;classes&#x2F;CS656&#x2F;birrel.pdf</a></li>
<li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/03-rpc.html">https://www.cs.rutgers.edu/~pxk/417/notes/03-rpc.html</a></li>
<li><a href="http://queue.acm.org/detail.cfm?id=1142044">The Rise and Fall of CORBA - ACM Queue</a></li>
<li><a href="https://en.wikipedia.org/wiki/Web_Services_Description_Language">https://en.wikipedia.org/wiki/Web_Services_Description_Language</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/ms973864.aspx">An Introduction to Microsoft .NET Remoting Framework | Microsoft Docs</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/bb985129.aspx">The Programmable Web: Web Services Provides Building Blocks for the Microsoft .NET Framework | Microsoft Docs</a></li>
</ul>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux快速入门</title>
    <url>/2022/05/25/Linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程是根据B站Up主狂神说记得笔记，有需要查看视频的小伙伴可以去看看狂神的视频，真的非常好！</p>
<p>狂神说Linux视频地址：<a href="https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p>
<hr>
<h1 id="服务器相关知识"><a href="#服务器相关知识" class="headerlink" title="服务器相关知识"></a>服务器相关知识</h1><h2 id="为什么程序员都需要一个自己的服务器？"><a href="#为什么程序员都需要一个自己的服务器？" class="headerlink" title="为什么程序员都需要一个自己的服务器？"></a>为什么程序员都需要一个自己的服务器？</h2><ol>
<li>作为一个程序员，必须要学会发布自己的网站和项目!</li>
<li>练习Linux操作</li>
<li>把自己的远程仓库、远程数据库、远程tomcat等搭建在服务器上</li>
<li>练习Linux进行任意的环境部署操作! 大部人都是Window下开发，不熟悉Linux</li>
</ol>
<h2 id="如何购买服务器？"><a href="#如何购买服务器？" class="headerlink" title="如何购买服务器？"></a>如何购买服务器？</h2><p>新手可以先去阿里云领一个免费的服务器先用着</p>
<p>阿里云新人服务器领取地址：<br><a href="https://imgtu.com/i/jFDbm6"><img src="https://s1.ax1x.com/2022/06/25/jFDbm6.jpg" alt="jFDbm6.jpg"></a><br>学生的话后期可以购买学生机，阿里云只有未满24周岁都可以享受学生机优惠</p>
<p>优惠地址：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p>
<p>购买服务器时系统选择CentOS 推荐版本7.X，因为8.0之后改了好多命令，云盘的话选择40G就够用了，如下图所示：<br><a href="https://imgtu.com/i/jFDzpd"><img src="https://s1.ax1x.com/2022/06/25/jFDzpd.jpg" alt="jFDzpd.jpg"></a></p>
<h2 id="买完服务器之后该干什么？"><a href="#买完服务器之后该干什么？" class="headerlink" title="买完服务器之后该干什么？"></a>买完服务器之后该干什么？</h2><p>首先服务器就是一个远程的Linux</p>
<ol>
<li>在阿里云购买服务器需要开通安全组设置去进行端口的映射，比如8080或者3306<br><a href="https://imgtu.com/i/jFcwxH"><img src="https://s1.ax1x.com/2022/06/25/jFcwxH.jpg" alt="jFcwxH.jpg"></a></li>
<li>获取服务器的公网ip地址，修改实例名称和密码，记住第一次修改需要重启，修改后就可以使用Xshell进行远程连接了</li>
</ol>
<p><a href="https://imgtu.com/i/jmFkJe"><img src="https://s1.ax1x.com/2022/06/28/jmFkJe.jpg" alt="jmFkJe.jpg"></a></p>
<h2 id="连接到服务器之后，我们就需要搭建环境了"><a href="#连接到服务器之后，我们就需要搭建环境了" class="headerlink" title="连接到服务器之后，我们就需要搭建环境了"></a>连接到服务器之后，我们就需要搭建环境了</h2><p>搭建环境有两种方式：</p>
<p>1、傻瓜式(使用宝塔面板)</p>
<p>安装网站：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p>
<p>切记安装前记得先在安全组中开发如下端口：</p>
<p><a href="https://imgtu.com/i/jmFPIO"><img src="https://s1.ax1x.com/2022/06/28/jmFPIO.jpg" alt="jmFPIO.jpg"></a></p>
<p>安装命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</span><br></pre></td></tr></table></figure>

<p>下载完毕之后，就可以得到一个地址：宝塔的管理面板</p>
<ul>
<li>url：</li>
<li>username：</li>
<li>password：</li>
</ul>
<p><a href="https://imgtu.com/i/jmF9Z6"><img src="https://s1.ax1x.com/2022/06/28/jmF9Z6.jpg" alt="jmF9Z6.jpg"></a></p>
<p><a href="https://imgtu.com/i/jmFCdK"><img src="https://s1.ax1x.com/2022/06/28/jmFCdK.jpg" alt="jmFCdK.jpg"></a></p>
<h2 id="自定义安装服务器环境"><a href="#自定义安装服务器环境" class="headerlink" title="自定义安装服务器环境"></a>自定义安装服务器环境</h2><p><a href="https://imgtu.com/i/jmFARH"><img src="https://s1.ax1x.com/2022/06/28/jmFARH.jpg" alt="jmFARH.jpg"></a></p>
<blockquote>
<p>一键部署应用</p>
</blockquote>
<p><a href="https://imgtu.com/i/jmFEzd"><img src="https://s1.ax1x.com/2022/06/28/jmFEzd.jpg" alt="jmFEzd.jpg"></a></p>
<blockquote>
<p>端口开启</p>
</blockquote>
<p><a href="https://imgtu.com/i/jmFZQA"><img src="https://s1.ax1x.com/2022/06/28/jmFZQA.jpg" alt="jmFZQA.jpg"></a></p>
<blockquote>
<p>放入网站进行访问</p>
</blockquote>
<p>比如TomCat就直接放到webapps目录下</p>
<p>特殊的网站：开源项目，就安装自己的操作来</p>
<p>注意：上传文件尽量使用XFTP</p>
<blockquote>
<p>SpringBoot项目怎么部署？</p>
</blockquote>
<p>打成war包或者jar包</p>
<ul>
<li>war包直接丢到Tomcat即可</li>
<li>jar包直接用java-jar执行即可访问</li>
</ul>
<p>注意：网站如果访问失败，一定是防火墙问题，这个时候去检查Linux服务器和阿里云安全组面板</p>
<p>2、命令式(原生)</p>
<h1 id="Linux入门概述"><a href="#Linux入门概述" class="headerlink" title="Linux入门概述"></a>Linux入门概述</h1><h2 id="我们为什么要学习Linux"><a href="#我们为什么要学习Linux" class="headerlink" title="我们为什么要学习Linux?"></a>我们为什么要学习Linux?</h2><blockquote>
<p>linux诞生了这么多年，以前还喊着如何能取代windows系统，现在这个口号已经小多了，任何事物发展都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即使他们自己不用亲戚朋友还是要用，没有办法的事情。</p>
<p>用习惯了windows操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着linux就没有用武之地了。在服务器端，在开发领域linux倒是越来越受欢迎，很多程序员都觉得不懂点linux都觉得不好意思，linux在开源社区的地位依然岿然不动。</p>
<p>尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！</p>
</blockquote>
<h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><blockquote>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p>
<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
</blockquote>
<h2 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h2><blockquote>
<p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包</p>
</blockquote>
<p>Kali linux：做安全渗透测试使用的</p>
<p><a href="https://imgtu.com/i/juu9oj"><img src="https://s1.ax1x.com/2022/06/30/juu9oj.png" alt="juu9oj.png"></a></p>
<p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p>
<p><a href="https://imgtu.com/i/juupwQ"><img src="https://s1.ax1x.com/2022/06/30/juupwQ.png" alt="juupwQ.png"></a></p>
<p>有条件使用Redhat的人可以考虑考一个红帽子工程师，可以让你在面试的时候更突出一点</p>
<blockquote>
<p>Linux应用领域</p>
</blockquote>
<p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p>
<p>目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p>
<ul>
<li>巴西联邦政府由于支持 Linux 而世界闻名。</li>
<li>有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</li>
<li>印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</li>
<li>中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</li>
<li>在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</li>
<li>葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。</li>
<li>法国和德国同样开始逐步采用 Linux。</li>
</ul>
<blockquote>
<p>Linux vs Windows</p>
</blockquote>
<p><a href="https://imgtu.com/i/juuPFs"><img src="https://s1.ax1x.com/2022/06/30/juuPFs.png" alt="juuPFs.png"></a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也可以直接买一台学习用用！</p>
<blockquote>
<p>安装CentOS（虚拟机安装，耗资源）</p>
</blockquote>
<p>这里推荐使用VMware Workstation 对新手会比较友好一点，安装完后需要激活码，这里就不教破解方法了，自行百度即可</p>
<p>VMware Workstation官网：<a href="https://www.vmware.com/cn/products/workstation-pro.html">https://www.vmware.com/cn/products/workstation-pro.html</a></p>
<p>下载激活好后进行如下操作：</p>
<p>可以通过镜像进行安装！官方网址：<a href="https://www.centos.org/download/">https://www.centos.org/download/</a></p>
<p><a href="https://blog.csdn.net/SDAU_LGX/article/details/120669344?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165647175016782246484602%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165647175016782246484602&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-120669344-null-null.142%5Ev25%5Epc_rank_34,157%5Ev15%5Enew_3&utm_term=centos7%E9%95%9C%E5%83%8F&spm=1018.2226.3001.4187">安装教程</a></p>
<blockquote>
<p>购买云服务器（推荐）</p>
</blockquote>
<p>云服务器就是一个远程电脑，服务器一般不会关机</p>
<p>虚拟机安装后占用空间，也会有些卡顿，我们作为程序员其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作；</p>
<p>1、阿里云购买服务器：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p>
<p>2、购买完毕后，获取服务器的ip地址，重置服务器密码，就可以远程登录了</p>
<p>3、下载 xShell（远程连接使用）和Xftp 工具（文件上传使用）</p>
<p>这里我给大家提供了我的免费下载地址：</p>
<p>链接：<a href="https://pan.baidu.com/s/19yBxIyCP69tHzm8Y2NogNw">https://pan.baidu.com/s/19yBxIyCP69tHzm8Y2NogNw</a><br>提取码：p73z </p>
<p>连接成功效果如下：</p>
<p><a href="https://imgtu.com/i/juuSeg"><img src="https://s1.ax1x.com/2022/06/30/juuSeg.png" alt="juuSeg.png"></a></p>
<p>这里就是我们的Linux操作系统了!以后的操作都在这里操作，项目也在这里进行发布!</p>
<p><strong>注意事项：</strong></p>
<p>如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！</p>
<h1 id="走近Linux系统"><a href="#走近Linux系统" class="headerlink" title="走近Linux系统"></a>走近Linux系统</h1><blockquote>
<p>开机登录</p>
</blockquote>
<p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”<strong>守护进程</strong>“（daemon）。</p>
<p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p>
<p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>命令行登录</li>
<li>ssh登录</li>
<li>图形界面登录</li>
</ul>
<p>最高权限账户为 root，可以操作一切！</p>
<blockquote>
<p>关机</p>
</blockquote>
<p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p>
<p>关机指令为：shutdown ；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sync</span> <span class="comment"># 将数据由内存同步到硬盘中。</span></span><br><span class="line"></span><br><span class="line">shutdown <span class="comment"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span></span><br><span class="line"></span><br><span class="line">shutdown –h 10 <span class="comment"># 这个命令告诉大家，计算机将在10分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h now <span class="comment"># 立马关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 <span class="comment"># 系统会在今天20:25关机</span></span><br><span class="line"></span><br><span class="line">shutdown –h +10 <span class="comment"># 十分钟后关机</span></span><br><span class="line"></span><br><span class="line">shutdown –r now <span class="comment"># 系统立马重启</span></span><br><span class="line"></span><br><span class="line">shutdown –r +10 <span class="comment"># 系统十分钟后重启</span></span><br><span class="line"></span><br><span class="line">reboot <span class="comment"># 就是重启，等同于 shutdown –r now</span></span><br><span class="line"></span><br><span class="line">halt <span class="comment"># 关闭系统，等同于shutdown –h now 和 poweroff</span></span><br></pre></td></tr></table></figure>

<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p>
<blockquote>
<p>系统目录结构</p>
</blockquote>
<p>1、在Linux中一切皆文件<br>2、根目录&#x2F;，所有的文件都挂载在这个节点下</p>
<p>登录系统后，在当前命令窗口下输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /</span><br></pre></td></tr></table></figure>

<p>你会看到如下图所示：</p>
<p><a href="https://imgtu.com/i/junxOS"><img src="https://s1.ax1x.com/2022/06/30/junxOS.png" alt="junxOS.png"></a></p>
<p>树状目录结构：（Linux的一切资源都挂载在这个 &#x2F; 根节点下）</p>
<p><a href="https://imgtu.com/i/juuiYn"><img src="https://s1.ax1x.com/2022/06/30/juuiYn.png" alt="juuiYn.png"></a></p>
<p><strong>以下是对这些目录的解释：</strong></p>
<ul>
<li><strong>&#x2F;bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>&#x2F;boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。（切记不要动他）</li>
<li><strong>&#x2F;dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li>
<li><strong>&#x2F;etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。（<strong>重点</strong>）</li>
<li><strong>&#x2F;home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。（<strong>重点</strong>）</li>
<li><strong>&#x2F;lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。（切记不要动他）</li>
<li><strong>&#x2F;lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放突然关机的一些文件）</li>
<li><strong>&#x2F;media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><strong>&#x2F;mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。（我们后面会把一些本地文件挂载在这个目录下）</li>
<li><strong>&#x2F;opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。(<strong>非常重要</strong>)</li>
<li><strong>&#x2F;proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。（不用管）</li>
<li><strong>&#x2F;root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。（<strong>重点</strong>）</li>
<li><strong>&#x2F;sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>&#x2F;srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>&#x2F;sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li>
<li><strong>&#x2F;tmp</strong>：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，比如安装包。（<strong>常用</strong>）</li>
<li><strong>&#x2F;usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。（<strong>重点</strong>）</li>
<li><strong>&#x2F;usr&#x2F;bin：</strong> 系统用户使用的应用程序。</li>
<li><strong>&#x2F;usr&#x2F;sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>&#x2F;usr&#x2F;src：</strong> 内核源代码默认的放置目录。</li>
<li><strong>&#x2F;var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li>
<li><strong>&#x2F;run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li>
<li><strong>&#x2F;www:<strong>存放服务器网站相关的资源，环境，网站的项目，这个是只有服务器才有的（</strong>重点</strong>）</li>
</ul>
<p><a href="https://imgtu.com/i/juuFWq"><img src="https://s1.ax1x.com/2022/06/30/juuFWq.png" alt="juuFWq.png"></a></p>
<h1 id="常用的基本命令（重点）"><a href="#常用的基本命令（重点）" class="headerlink" title="常用的基本命令（重点）"></a>常用的基本命令（重点）</h1><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p><strong>绝对路径：</strong></p>
<p>路径的写法，由根目录 &#x2F; 写起，例如：&#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p>
<p><strong>相对路径：</strong></p>
<p>路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成：cd ..&#x2F;man 这就是相对路径的写法啦！</p>
<ul>
<li>cd :切换目录命令!</li>
<li>.&#x2F; :当前目录</li>
<li>cd .. :返回上一级目录</li>
</ul>
<h3 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h3><p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls: 列出目录</li>
<li>cd：切换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cp: 复制文件或目录</li>
<li>rm: 移除文件或目录</li>
<li>mv: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<h4 id="ls-（列出目录）"><a href="#ls-（列出目录）" class="headerlink" title="ls （列出目录）"></a>ls （列出目录）</h4><p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls [-aAdfFhilnrRSt] 目录名称</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>注意：所有的Linux命令都可以进行组合使用!</p>
<p>比如：将目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls -al ~</span></span><br></pre></td></tr></table></figure>

<h4 id="cd-（切换目录）"><a href="#cd-（切换目录）" class="headerlink" title="cd （切换目录）"></a>cd （切换目录）</h4><p>cd+目录名（绝对路径都是以&#x2F;开头，相对路径，对于当前目录该如何寻找..&#x2F; ..&#x2F;）</p>
<p><a href="https://imgtu.com/i/juuAS0"><img src="https://s1.ax1x.com/2022/06/30/juuAS0.png" alt="juuAS0.png"></a></p>
<p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到用户目录下</span></span><br><span class="line">[root@apathy /]<span class="comment"># cd home  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mkdir 命令创建 apathystudy 目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir apathystudy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 kuangstudy 目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># cd apathystudy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到上一级</span></span><br><span class="line">[root@apathy apathystudy]<span class="comment"># cd ..</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到根目录</span></span><br><span class="line">[root@apathy apathystudy]<span class="comment"># cd /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line">[root@apathy apathystudy]<span class="comment"># cd ~</span></span><br></pre></td></tr></table></figure>

<p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p>
<h4 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd ( 显示目前所在的目录 )"></a>pwd ( 显示目前所在的目录 )</h4><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy apathystudy]<span class="comment">#pwd [-P]</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单纯显示出目前的工作目录</span></span><br><span class="line">[root@apathy ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是链接，要显示真实地址，可以使用 -P参数</span></span><br><span class="line">[root@apathy /]<span class="comment"># cd bin</span></span><br><span class="line">[root@apathy bin]<span class="comment"># pwd -P</span></span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>

<h4 id="mkdir-（创建新目录）"><a href="#mkdir-（创建新目录）" class="headerlink" title="mkdir （创建新目录）"></a>mkdir （创建新目录）</h4><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [-mp] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入我们用户目录下</span></span><br><span class="line">[root@apathy /]<span class="comment"># cd /home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 test 文件夹</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多层级目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir test1/test2/test3/test4</span></span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘test1/test2/test3/test4’:</span><br><span class="line">No such file or directory  <span class="comment"># &lt;== 没办法直接创建此目录啊！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir -p test1/test2/test3/test4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建权限为 rwx--x--x 的目录。</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir -m 711 test2</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls -l</span></span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 <span class="built_in">test</span></span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br></pre></td></tr></table></figure>

<h4 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir ( 删除空的目录 )"></a>rmdir ( 删除空的目录 )</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> [-p] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 看看有多少目录存在？</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls -l</span></span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 <span class="built_in">test</span></span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可直接删除掉，没问题</span></span><br><span class="line">[root@apathy home]<span class="comment"># rmdir test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为尚有内容，所以无法删除！</span></span><br><span class="line">[root@apathy home]<span class="comment"># rmdir test1</span></span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove ‘test1’: Directory not empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span></span><br><span class="line">[root@apathy home]<span class="comment"># rmdir -p test1/test2/test3/test4</span></span><br></pre></td></tr></table></figure>

<p>注意：rmdir仅能删除空的目录，如果下面存在文件，需要先删除文件，也可以使用递归删除多个目录-p参数即可</p>
<h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp ( 复制文件或目录 )"></a>cp ( 复制文件或目录 )</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># cp [-adfilprsu] 来源档(source) 目标档(destination)</span></span><br><span class="line">[root@www ~]<span class="comment"># cp [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当于 -pdr 的意思，至于 pdr 请参考下列说明；(常用)</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li><strong>-r：</strong>递归持续复制，用于目录的复制行为；(常用)</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li>
<li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找一个有文件的目录，我这里找到 root目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># cd /root</span></span><br><span class="line">[root@apathy ~]<span class="comment"># ls</span></span><br><span class="line">install.sh</span><br><span class="line">[root@apathy ~]<span class="comment"># cd /home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 root目录下的install.sh 到 home目录下</span></span><br><span class="line">[root@apathy home]<span class="comment"># cp /root/install.sh /home</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次复制，加上-i参数，增加覆盖询问？</span></span><br><span class="line">[root@apathy home]<span class="comment"># cp -i /root/install.sh /home</span></span><br><span class="line"><span class="built_in">cp</span>: overwrite ‘/home/install.sh’? y <span class="comment"># n不覆盖，y为覆盖</span></span><br></pre></td></tr></table></figure>

<h4 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm ( 移除文件或目录 )"></a>rm ( 移除文件或目录 )</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> [-fir] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息，相当于强制删除；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /<span class="comment">#系统中所有的文件就被删除了，删库跑路就是这么操作的!</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span></span><br><span class="line">[root@apathy home]<span class="comment"># rm -i install.sh</span></span><br><span class="line"><span class="built_in">rm</span>: remove regular file ‘install.sh’? y</span><br><span class="line"><span class="comment"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尽量不要在服务器上使用 rm -rf /</span></span><br></pre></td></tr></table></figure>

<h4 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv  ( 移动文件与目录，或修改名称 )"></a>mv  ( 移动文件与目录，或修改名称 )</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># mv [-fiu] source destination</span></span><br><span class="line">[root@www ~]<span class="comment"># mv [options] source1 source2 source3 .... directory</span></span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制一个文件到当前目录</span></span><br><span class="line">[root@apathy home]<span class="comment"># cp /root/install.sh /home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个文件夹 test</span></span><br><span class="line">[root@apathy home]<span class="comment"># mkdir test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将复制过来的文件移动到我们创建的目录，并查看</span></span><br><span class="line">[root@apathy home]<span class="comment"># mv install.sh test</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">[root@apathy home]<span class="comment"># cd test</span></span><br><span class="line">[root@apathy <span class="built_in">test</span>]<span class="comment"># ls</span></span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件夹重命名，然后再次查看！</span></span><br><span class="line">[root@apathy <span class="built_in">test</span>]<span class="comment"># cd ..</span></span><br><span class="line">[root@apathy home]<span class="comment"># mv test mvtest</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line">mvtest</span><br></pre></td></tr></table></figure>

<h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><h4 id="看懂文件属性"><a href="#看懂文件属性" class="headerlink" title="看懂文件属性"></a>看懂文件属性</h4><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<p><a href="https://imgtu.com/i/jGNug1"><img src="https://s1.ax1x.com/2022/07/04/jGNug1.png" alt="jGNug1.png"></a></p>
<p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>当为[ <strong>d</strong> ]则是目录；（<strong>常用</strong>）</li>
<li>当为[ <strong>-</strong> ]则是文件；（<strong>常用</strong>）</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；（<strong>常用</strong>）</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p>
<p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p>
<p><a href="https://imgtu.com/i/jGNQu6"><img src="https://s1.ax1x.com/2022/07/04/jGNQu6.png" alt="jGNQu6.png"></a></p>
<p>从左至右用0-9这些数字来表示。</p>
<p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p>
<h4 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h4><p><strong>1、chgrp：更改文件属组</strong>（尽量不要修改）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong>（尽量不要修改）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> [–R] 属主名 文件名</span><br><span class="line"><span class="built_in">chown</span> [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>

<p><strong>3、chmod：更改文件9个属性</strong>（常用，必须掌握）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<p>Linux文件属性有两种设置方法，一种是数字（常用的），一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner&#x2F;group&#x2F;others三种身份各有自己的read&#x2F;write&#x2F;execute权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br><span class="line"></span><br><span class="line">可读可写不可执行   rw-   6</span><br><span class="line"></span><br><span class="line">可读可写可执行     rwx   7</span><br><span class="line"></span><br><span class="line">chomd 777文件赋予所有用户可读可写可执行</span><br></pre></td></tr></table></figure>

<p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 770 filename</span><br></pre></td></tr></table></figure>

<p>可以自己下去多进行测试！</p>
<h2 id="文件内容查看（必须掌握）"><a href="#文件内容查看（必须掌握）" class="headerlink" title="文件内容查看（必须掌握）"></a>文件内容查看（必须掌握）</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
</ul>
<p><a href="https://imgtu.com/i/jGNn3R"><img src="https://s1.ax1x.com/2022/07/04/jGNn3R.png" alt="jGNn3R.png"></a></p>
<ul>
<li>nl  显示的时候，顺道输出行号！  看代码的时候，希望显示行号!（常用）</li>
</ul>
<p><a href="https://imgtu.com/i/jGNZ4J"><img src="https://s1.ax1x.com/2022/07/04/jGNZ4J.png" alt="jGNZ4J.png"></a></p>
<ul>
<li>more 一页一页的显示文件内容，带余下内容的（空格代表翻页，enter代表向下看一行，:f行号)</li>
</ul>
<p><a href="https://imgtu.com/i/jGNKjx"><img src="https://s1.ax1x.com/2022/07/04/jGNKjx.png" alt="jGNKjx.png"></a></p>
<ul>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！(空格下翻页，上下键代表翻动页面!退出命令为：q，查找字符串：&#x2F;要查询的字符向下查询，向上查询使用?要查询的字符串，n继续搜寻下一个，向上寻找使用N）</li>
<li>head 只看头几行  通过-n参数来控制显示几行!</li>
<li><a href="https://imgtu.com/i/jGNlDK"><img src="https://s1.ax1x.com/2022/07/04/jGNlDK.png" alt="jGNlDK.png"></a></li>
<li>tail 只看尾巴几行  通过-n参数来控制显示几行!</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<p>网络配置目录:cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts     系统版本必须是CentOS7</p>
<p><a href="https://imgtu.com/i/jGNmC9"><img src="https://s1.ax1x.com/2022/07/04/jGNmC9.png" alt="jGNmC9.png"></a></p>
<p>ifconfig命令查看网络配置!</p>
<h4 id="cat-由第一行开始显示文件内容"><a href="#cat-由第一行开始显示文件内容" class="headerlink" title="cat 由第一行开始显示文件内容"></a>cat 由第一行开始显示文件内容</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> [-AbEnTv]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span></span><br><span class="line">[root@apathy ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<h4 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h4><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy ~]<span class="comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure>



<h4 id="nl-显示行号"><a href="#nl-显示行号" class="headerlink" title="nl  显示行号"></a>nl  显示行号</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> [-bnw] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy ~]<span class="comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">1DEVICE=eth0</span><br><span class="line">2BOOTPROTO=dhcp</span><br><span class="line">3ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<h4 id="more-一页一页翻动"><a href="#more-一页一页翻动" class="headerlink" title="more  一页一页翻动"></a>more  一页一页翻动</h4><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter   ：代表向下翻『一行』；</li>
<li>&#x2F;字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f    ：立刻显示出档名以及目前显示的行数；</li>
<li>q    ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%) <span class="comment"># 重点在这一行喔！你的光标也会在这里等待你的命令</span></span><br></pre></td></tr></table></figure>



<h4 id="less-一页一页翻动，以下实例输出-x2F-etc-x2F-man-config文件的内容："><a href="#less-一页一页翻动，以下实例输出-x2F-etc-x2F-man-config文件的内容：" class="headerlink" title="less  一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容："></a>less  一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</h4><p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串  ：向下搜寻『字串』的功能；</li>
<li>?字串  ：向上搜寻『字串』的功能；</li>
<li>n   ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N   ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q   ：离开 less 这个程序；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># more /etc/csh.login</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">:   <span class="comment"># 这里可以等待你输入命令！</span></span><br></pre></td></tr></table></figure>



<h4 id="head-取出文件前面几行"><a href="#head-取出文件前面几行" class="headerlink" title="head  取出文件前面几行"></a>head  取出文件前面几行</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># head -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure>



<h4 id="tail-取出文件后面几行"><a href="#tail-取出文件后面几行" class="headerlink" title="tail  取出文件后面几行"></a>tail  取出文件后面几行</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy etc]<span class="comment"># tail -n 20 /etc/csh.login</span></span><br></pre></td></tr></table></figure>



<h4 id="拓展：Linux-链接概念"><a href="#拓展：Linux-链接概念" class="headerlink" title="拓展：Linux 链接概念"></a>拓展：Linux 链接概念</h4><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p>
<p>Linux的链接分为两种∶硬链接、软链接!</p>
<p><strong>硬链接∶</strong>A–B，假设B是A的硬链接，那么他们两个指向了同一个文件!允许一个文件拥有多个路径，用户可以通过这种<br>硬链接到一些重要文件上，防止误删!<br><strong>软链接︰</strong>类似Window下的快捷方式，删除的源文件，快捷方式也访问不了!</p>
<p>创建连接In命令!</p>
<p>touch命令创建文件!</p>
<p>echo输入字符串,也可以输入到文件中!</p>
<p><strong>硬连接</strong></p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><strong>软连接</strong></p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>测试：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy /]<span class="comment"># cd /home</span></span><br><span class="line">[root@apathy home]<span class="comment"># touch f1 # 创建一个测试文件f1</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls</span></span><br><span class="line">f1</span><br><span class="line">[root@apathy home]<span class="comment"># ln f1 f2     # 创建f1的一个硬连接文件f2</span></span><br><span class="line">[root@apathy home]<span class="comment"># ln -s f1 f3   # 创建f1的一个符号连接文件f3</span></span><br><span class="line">[root@apathy home]<span class="comment"># ls -li       # -i参数显示文件的inode节点信息</span></span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure>

<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span></span><br><span class="line">[root@apathy home]<span class="comment"># echo &quot;I am f1 file&quot; &gt;&gt;f1</span></span><br><span class="line">[root@apathy home]<span class="comment"># cat f1</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># cat f3</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># rm -f f1</span></span><br><span class="line">[root@apathy home]<span class="comment"># cat f2</span></span><br><span class="line">I am f1 file</span><br><span class="line">[root@apathy home]<span class="comment"># cat f3</span></span><br><span class="line"><span class="built_in">cat</span>: f3: No such file or directory</span><br></pre></td></tr></table></figure>

<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>删除符号连接f3,对f1,f2无影响；</li>
<li>删除硬连接f2，对f1,f3也无影响；</li>
<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h2 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h2><h3 id="什么是Vim编辑器"><a href="#什么是Vim编辑器" class="headerlink" title="什么是Vim编辑器"></a>什么是Vim编辑器</h3><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。尤其是Linux中，必须要会使用Vim（<strong>查看内容，编辑内容，保存内容</strong>!)</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p>
<p>vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>vim 键盘图：</p>
<p><a href="https://imgtu.com/i/jGN22n"><img src="https://s1.ax1x.com/2022/07/04/jGN22n.png" alt="jGN22n.png"></a></p>
<h3 id="三种使用模式"><a href="#三种使用模式" class="headerlink" title="三种使用模式"></a>三种使用模式</h3><p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p>
<p><strong>命令模式：</strong></p>
<p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p><a href="https://imgtu.com/i/jGNrVS"><img src="https://s1.ax1x.com/2022/07/04/jGNrVS.png" alt="jGNrVS.png"></a></p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。如果是编辑模式，需要先退出编辑模式!按ESC</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<p><strong>输入模式：</strong></p>
<p>在命令模式下按下i就进入了输入模式：</p>
<p><a href="https://imgtu.com/i/jGNsUg"><img src="https://s1.ax1x.com/2022/07/04/jGNsUg.png" alt="jGNsUg.png"></a></p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li>
<li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li>
<li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<p><strong>底线命令模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。光标就移动到了最底下，就可以在这里输入一些底线命令了!</p>
<p><a href="https://imgtu.com/i/jGN0Df"><img src="https://s1.ax1x.com/2022/07/04/jGN0Df.png" alt="jGN0Df.png"></a></p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p><a href="https://imgtu.com/i/jGNBb8"><img src="https://s1.ax1x.com/2022/07/04/jGNBb8.png" alt="jGNBb8.png"></a></p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><a href="https://imgtu.com/i/jGNg8s"><img src="https://s1.ax1x.com/2022/07/04/jGNg8s.png" alt="jGNg8s.png"></a></p>
<h3 id="完整演示说明"><a href="#完整演示说明" class="headerlink" title="完整演示说明"></a>完整演示说明</h3><p>新建或者编辑文件，按i进入编辑模式，编写内容，编写完成后退出编辑模式，esc，退出之后进入底线命令模式︰ wq<br>保存退出!</p>
<p>如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy home]<span class="comment"># vim apathystudy.txt</span></span><br></pre></td></tr></table></figure>

<p>然后就会进入文件</p>
<p><a href="https://imgtu.com/i/jGNy5Q"><img src="https://s1.ax1x.com/2022/07/04/jGNy5Q.png" alt="jGNy5Q.png"></a></p>
<p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><a href="https://imgtu.com/i/jGNcCj"><img src="https://s1.ax1x.com/2022/07/04/jGNcCj.png" alt="jGNcCj.png"></a></p>
<p><strong>按下 ESC 按钮回到一般模式</strong></p>
<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<p>在一般模式中按下 <strong>:wq</strong> 储存后离开 vim！</p>
<p><a href="https://imgtu.com/i/jGNRvq"><img src="https://s1.ax1x.com/2022/07/04/jGNRvq.png" alt="jGNRvq.png"></a></p>
<p>OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。</p>
<h3 id="Vim-按键说明"><a href="#Vim-按键说明" class="headerlink" title="Vim 按键说明"></a>Vim 按键说明</h3><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p>
<table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left"><strong>n(数字)&lt; space&gt;</strong></td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>
</tr>
<tr>
<td align="left"><strong>n&lt; Enter&gt;</strong></td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！(常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">删除、复制与粘贴</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left"><strong>u</strong></td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
</tbody></table>
<p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>i, I</strong></td>
<td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left"><strong>[Esc]</strong></td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
<tr>
<td align="left">Insert</td>
<td>切换光标的状态</td>
</tr>
</tbody></table>
<p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left"><strong>:wq</strong></td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中看 &#x2F;home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left"><strong>:set nu</strong>     设置行号，代码中经常会使用</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p>因为你一般在公司，用的都不是root账号</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<h3 id="用户账号的管理"><a href="#用户账号的管理" class="headerlink" title="用户账号的管理"></a>用户账号的管理</h3><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<p>要明白一个属主和属组的区别</p>
<h4 id="添加账号-useradd"><a href="#添加账号-useradd" class="headerlink" title="添加账号 useradd"></a>添加账号 useradd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>选项 :</p>
</li>
<li><ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li><strong>-m　使用者目录如不存在则自动建立。</strong>（常用）</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li><p>用户名 :</p>
<ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令创建了一个用户gods，其中-m选项用来为登录名gods产生一个主目录 /home/gods</span></span><br><span class="line">[root@apathy home]<span class="comment"># useradd -m gods</span></span><br></pre></td></tr></table></figure>

<p>理解一下本质:Linux中一切皆文件，这里的添加用户说白了就是往某一个文件中写入用户的信息了!&#x2F;etc&#x2F;passwd</p>
<p>增加用户账号就是在&#x2F;etc&#x2F;passwd文件中为新用户增加一条记录，同时更新其他系统文件如&#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p>
<h4 id="删除帐号-userdel"><a href="#删除帐号-userdel" class="headerlink" title="删除帐号  userdel"></a>删除帐号  userdel</h4><p>如果一个用户的账号不再使用，可以从系统中删除。</p>
<p>删除用户账号就是要将&#x2F;etc&#x2F;passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apathy home]<span class="comment"># userdel -r gods</span></span><br></pre></td></tr></table></figure>

<p>此命令删除用户gods在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录。</p>
<h4 id="修改帐号-usermod"><a href="#修改帐号-usermod" class="headerlink" title="修改帐号  usermod"></a>修改帐号  usermod</h4><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># usermod -s /bin/ksh -d /home/z –g developer gods</span></span><br></pre></td></tr></table></figure>

<p>此命令将用户apathy的登录Shell修改为ksh，主目录改为&#x2F;home&#x2F;z，用户组改为developer。</p>
<h4 id="Linux下如何切换用户"><a href="#Linux下如何切换用户" class="headerlink" title="Linux下如何切换用户"></a>Linux下如何切换用户</h4><p><a href="https://imgtu.com/i/jGNfK0"><img src="https://s1.ax1x.com/2022/07/04/jGNfK0.png" alt="jGNfK0.png"></a></p>
<p>1.切换用户的命令为：su username 【username是你的用户名哦】</p>
<p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p>
<p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p>
<p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p>
<p>$表示普通用户</p>
<p>#表示超级用户，也就是root用户</p>
<p><a href="https://imgtu.com/i/jGNhrV"><img src="https://s1.ax1x.com/2022/07/04/jGNhrV.png" alt="jGNhrV.png"></a></p>
<p>如何修改主机名？</p>
<p><a href="https://imgtu.com/i/jGN4bT"><img src="https://s1.ax1x.com/2022/07/04/jGN4bT.png" alt="jGN4bT.png"></a></p>
<h4 id="用户密码的管理"><a href="#用户密码的管理" class="headerlink" title="用户密码的管理"></a>用户密码的管理</h4><ul>
<li>我们一般通过root创建用户的时候!要配置密码!</li>
<li>Linux上输入密码是不会显示的，你正常输入就可以了，并不是系统的问题!</li>
<li>在公司中，你们一般拿不到公司服务器的root权限，都是一些分配的账号!</li>
</ul>
<p>用户管理的一项重要内容是用户密码的管理。用户账号刚创建时没有密码，但是被系统锁定，无法使用，必须为其指定密码后才可以使用，即使是指定空密码。</p>
<p>指定和修改用户密码的Shell命令是passwd。超级用户可以为自己和其他用户指定密码，普通用户只能用它修改自己的密码。</p>
<p>命令的格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">Old password:******</span><br><span class="line">New password:*******   <span class="comment">#密码不能过于简单</span></span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd kuangshen</span></span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd -d kuangshen   </span></span><br></pre></td></tr></table></figure>

<p>此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd -l kuangshen   锁定之后用户就不能登录了</span></span><br></pre></td></tr></table></figure>



<h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><h3 id="用户组账号管理"><a href="#用户组账号管理" class="headerlink" title="用户组账号管理"></a>用户组账号管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（开发，测试，运维，root）。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。<strong>组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新</strong>。</p>
<h4 id="增加一个新的用户组使用groupadd命令"><a href="#增加一个新的用户组使用groupadd命令" class="headerlink" title="增加一个新的用户组使用groupadd命令"></a>增加一个新的用户组使用groupadd命令</h4><p>创建完用户组后可以得到一个组的id，这个id是可以指定的!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>实例1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd group1</span></span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<p>实例2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd -g 101 group2</span></span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<h4 id="如果要删除一个已有的用户组，使用groupdel命令"><a href="#如果要删除一个已有的用户组，使用groupdel命令" class="headerlink" title="如果要删除一个已有的用户组，使用groupdel命令"></a>如果要删除一个已有的用户组，使用groupdel命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupdel group1</span></span><br></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<h4 id="修改用户组的属性使用groupmod命令"><a href="#修改用户组的属性使用groupmod命令" class="headerlink" title="修改用户组的属性使用groupmod命令"></a>修改用户组的属性使用groupmod命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令将组group2的组标识号修改为102。</span></span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将组group2的标识号改为10000，组名修改为group3。</span></span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>

<p><a href="https://imgtu.com/i/jGNIVU"><img src="https://s1.ax1x.com/2022/07/04/jGNIVU.png" alt="jGNIVU.png"></a></p>
<h4 id="切换组"><a href="#切换组" class="headerlink" title="切换组"></a>切换组</h4><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p>
<h2 id="扩展：文件的查看"><a href="#扩展：文件的查看" class="headerlink" title="扩展：文件的查看"></a>扩展：文件的查看</h2><h3 id="x2F-etc-x2F-passwd"><a href="#x2F-etc-x2F-passwd" class="headerlink" title="&#x2F;etc&#x2F;passwd"></a>&#x2F;etc&#x2F;passwd</h3><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p><strong>&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p>
<p>Linux系统中的每个用户都在&#x2F;etc&#x2F;passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ <span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:/:</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，&#x2F;etc&#x2F;passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户名:口令(登录密码，我们不可见):用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<p>1）”用户名”是代表用户账号的字符串。</p>
<p>通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。</p>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。</p>
<p>它对应着&#x2F;etc&#x2F;group文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。</p>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。</p>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">伪 用 户 含 义</span><br><span class="line">bin 拥有可执行的用户命令文件</span><br><span class="line">sys 拥有系统文件</span><br><span class="line">adm 拥有帐户文件</span><br><span class="line">uucp UUCP使用</span><br><span class="line">lp lp或lpd子系统使用</span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<h3 id="x2F-etc-x2F-shadow"><a href="#x2F-etc-x2F-shadow" class="headerlink" title="&#x2F;etc&#x2F;shadow"></a>&#x2F;etc&#x2F;shadow</h3><p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于&#x2F;etc&#x2F;passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、&#x2F;etc&#x2F;shadow中的记录行与&#x2F;etc&#x2F;passwd中的一一对应，它由pwconv命令根据&#x2F;etc&#x2F;passwd中的数据自动产生</strong></p>
<p>它的文件格式与&#x2F;etc&#x2F;passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<h3 id="x2F-etc-x2F-group"><a href="#x2F-etc-x2F-group" class="headerlink" title="&#x2F;etc&#x2F;group"></a>&#x2F;etc&#x2F;group</h3><p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。</p>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li><p>“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。</p>
</li>
<li><p>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</p>
</li>
<li><p>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</p>
</li>
<li><p>“组内用户列表”是属于这个组的所有用户的列表&#x2F;b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p>
</li>
</ol>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：列出文件系统的整体磁盘使用量</li>
<li>du：检查磁盘空间使用量</li>
</ul>
<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p><a href="https://imgtu.com/i/jGNT54"><img src="https://s1.ax1x.com/2022/07/04/jGNT54.png" alt="jGNT54.png"></a></p>
<p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将系统内所有的文件系统列出来！</span></span><br><span class="line"><span class="comment"># 在 Linux 底下如果 df 没有加任何选项</span></span><br><span class="line"><span class="comment"># 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks   Used Available Use% Mounted on</span><br><span class="line">devtmpfs          889100       0    889100   0% /dev</span><br><span class="line">tmpfs             899460     704    898756   1% /dev/shm</span><br><span class="line">tmpfs             899460     496    898964   1% /run</span><br><span class="line">tmpfs             899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       41152812 6586736  32662368  17% /</span><br><span class="line">tmpfs             179896       0    179896   0% /run/user/0</span><br><span class="line"><span class="comment"># 将容量结果以易读的容量格式显示出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">devtmpfs       869M     0 869M   0% /dev</span><br><span class="line">tmpfs           879M 708K 878M   1% /dev/shm</span><br><span class="line">tmpfs           879M 496K 878M   1% /run</span><br><span class="line">tmpfs           879M     0 879M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br><span class="line">tmpfs           176M     0 176M   0% /run/user/0</span><br><span class="line"><span class="comment"># 将系统内的所有特殊文件格式及名称都列出来</span></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -aT</span></span><br><span class="line">Filesystem     Type       1K-blocks   Used Available Use% Mounted on</span><br><span class="line">sysfs         sysfs               0       0         0    - /sys</span><br><span class="line">proc           proc                0       0         0    - /proc</span><br><span class="line">devtmpfs       devtmpfs       889100       0    889100   0% /dev</span><br><span class="line">securityfs     securityfs          0       0         0    - /sys/kernel/security</span><br><span class="line">tmpfs         tmpfs          899460     708    898752   1% /dev/shm</span><br><span class="line">devpts         devpts              0       0         0    - /dev/pts</span><br><span class="line">tmpfs         tmpfs          899460     496    898964   1% /run</span><br><span class="line">tmpfs         tmpfs          899460       0    899460   0% /sys/fs/cgroup</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/systemd</span><br><span class="line">pstore         pstore              0       0         0    - /sys/fs/pstore</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/freezer</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpuset</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/hugetlb</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/blkio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/net_cls,net_prio</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/memory</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/pids</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/devices</span><br><span class="line">cgroup         cgroup              0       0         0    - /sys/fs/cgroup/perf_event</span><br><span class="line">configfs       configfs            0       0         0    - /sys/kernel/config</span><br><span class="line">/dev/vda1     ext4         41152812 6586748  32662356  17% /</span><br><span class="line">systemd-1      -                   -       -         -    - /proc/sys/fs/binfmt_misc</span><br><span class="line">mqueue         mqueue              0       0         0    - /dev/mqueue</span><br><span class="line">debugfs       debugfs             0       0         0    - /sys/kernel/debug</span><br><span class="line">hugetlbfs     hugetlbfs           0       0         0    - /dev/hugepages</span><br><span class="line">tmpfs         tmpfs          179896       0    179896   0% /run/user/0</span><br><span class="line">binfmt_misc   binfmt_misc         0       0         0    - /proc/sys/fs/binfmt_misc</span><br><span class="line"><span class="comment"># 将 /etc 底下的可用的磁盘容量以易读的容量格式显示</span></span><br><span class="line"></span><br><span class="line">[root@kuangshen /]<span class="comment"># df -h /etc</span></span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1       40G  6.3G   32G  17% /</span><br></pre></td></tr></table></figure>



<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p><a href="https://imgtu.com/i/jGNoaF"><img src="https://s1.ax1x.com/2022/07/04/jGNoaF.png" alt="jGNoaF.png"></a></p>
<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:</span></span><br><span class="line"><span class="comment"># 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du</span></span><br><span class="line">16./redis</span><br><span class="line">8./www/.oracle_jre_usage  <span class="comment"># 包括隐藏文件的目录</span></span><br><span class="line">24./www</span><br><span class="line">48.                        <span class="comment"># 这个目录(.)所占用的总量</span></span><br><span class="line"><span class="comment"># 将文件的容量也列出来</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -a</span></span><br><span class="line">4./redis/.bash_profile</span><br><span class="line">4./redis/.bash_logout    </span><br><span class="line">....中间省略....</span><br><span class="line">4./kuangstudy.txt <span class="comment"># 有文件的列表了</span></span><br><span class="line">48.</span><br><span class="line"><span class="comment"># 检查根目录底下每个目录所占用的容量</span></span><br><span class="line">[root@kuangshen home]<span class="comment"># du -sm /*</span></span><br><span class="line">0/bin</span><br><span class="line">146/boot</span><br><span class="line">.....中间省略....</span><br><span class="line">0/proc</span><br><span class="line">.....中间省略....</span><br><span class="line">1/tmp</span><br><span class="line">3026/usr  <span class="comment"># 系统初期最大就是他了啦！</span></span><br><span class="line">513/var</span><br><span class="line">2666/www</span><br></pre></td></tr></table></figure>

<p>通配符 * 来代表每个目录。</p>
<p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p>
<h3 id="磁盘挂载与卸除"><a href="#磁盘挂载与卸除" class="headerlink" title="磁盘挂载与卸除"></a>磁盘挂载与卸除</h3><p><a href="https://imgtu.com/i/jGNHPJ"><img src="https://s1.ax1x.com/2022/07/04/jGNHPJ.png" alt="jGNHPJ.png"></a></p>
<p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”</p>
<p>Linux 的磁盘挂载使用mount命令，卸载使用umount命令。</p>
<p>磁盘挂载语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！</span></span><br><span class="line">[root@www ~]<span class="comment"># mkdir /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># mount /dev/hdc6 /mnt/hdc6</span></span><br><span class="line">[root@www ~]<span class="comment"># df</span></span><br><span class="line">Filesystem           1K-blocks     Used Available Use% Mounted on</span><br><span class="line">/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6</span><br></pre></td></tr></table></figure>

<p>磁盘卸载命令 umount 语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li>
<li>-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。</li>
</ul>
<p>卸载&#x2F;dev&#x2F;hdc6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># umount /dev/hdc6</span></span><br></pre></td></tr></table></figure>

<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>对于我们开发人员来说，其实Linux更多偏向于使用即可</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、在Linux中，每一个程序都是有自己的一个进程，每一个进程都有一个id号</p>
<p>2、每一个进程呢，都会有一个父进程</p>
<p>3、进程可以有两种存在方式:前台!后台运行</p>
<p>4、一般的话服务都是后台运行的，基本的程序都是前台运行的</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><strong>ps（常用）</strong> 查看当前系统中正在执行的各种进程的信息</p>
<p>ps-xx:</p>
<ul>
<li>-a 显示当前终端运行的所有的进程信息（单独使用时是查看当前的进程）</li>
<li>-u 以用户的信息显示进程</li>
<li>-x 显示后台运行进程的参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps -aux 查看所有的进程</span></span><br><span class="line">ps -aux | grep mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># |  在Linux中这个(|)叫做管道符     A|B：将A命令的一个结果作为输出去操作B命令</span></span><br><span class="line"><span class="comment"># grep 查找文件中符合条件的字符串</span></span><br></pre></td></tr></table></figure>

<p>对于我们来说，这里目前只需要记住一个命令即可：ps -xx|grep 进程名字  过滤进程信息</p>
<p><strong>ps -ef：可以查看到父进程的信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep mysql <span class="comment">#查看父进程我们一般可以通过目录树结构来查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程树</span></span><br><span class="line">pstree -pu</span><br><span class="line">	-p  显示父<span class="built_in">id</span></span><br><span class="line">	-u  显示用户组</span><br></pre></td></tr></table></figure>

<p><a href="https://imgtu.com/i/jGNq2R"><img src="https://s1.ax1x.com/2022/07/04/jGNq2R.png" alt="jGNq2R.png"></a></p>
<p>结束进程:杀掉进程，等价于window结束任务</p>
<p>kill -9进程的id</p>
<p>我们平时写的一个Java代码死循环了，可以选择结束进程，杀进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 进程的<span class="built_in">id</span></span><br><span class="line"><span class="comment"># 表示强制结束该进程</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>Linux中一切皆文件：**(文件∶读写执行(查看，创建，删除，移动，复制，编辑），权限（用户、用户组)。系统︰（磁盘，进程）)**</p>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>安装软件一般有三种方式:</p>
<ul>
<li>rpm ( Jdk:在线发布一个SringBoot项目)</li>
<li>解压缩( tomcat，启动并通过外网访问，发布网站)</li>
<li>yum在线安装(docker:直接安装运行跑起来docker就可以)</li>
</ul>
<h2 id="jdk安装（rpm安装）"><a href="#jdk安装（rpm安装）" class="headerlink" title="jdk安装（rpm安装）"></a>jdk安装（rpm安装）</h2><p>1、rpm下载地址<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>2、如果有安装openjdk 则卸载</p>
<p><a href="https://imgtu.com/i/jGNbG9"><img src="https://s1.ax1x.com/2022/07/04/jGNbG9.png" alt="jGNbG9.png"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_121&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># rpm -qa|grep jdk</span></span><br><span class="line">jdk1.8.0_121-1.8.0_121-fcs.x86_64</span><br><span class="line"><span class="comment"># 卸载 -e --nodeps 强制删除</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64</span></span><br><span class="line">[root@kuangshen ~]<span class="comment"># java -version</span></span><br><span class="line">-bash: /usr/bin/java: No such file or directory  <span class="comment"># OK</span></span><br></pre></td></tr></table></figure>

<p>3、安装JDK并配置环境变量</p>
<p><a href="https://imgtu.com/i/jGNLx1"><img src="https://s1.ax1x.com/2022/07/04/jGNLx1.png" alt="jGNLx1.png"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装java rpm</span></span><br><span class="line">[root@apathy apathy]<span class="comment"># rpm -ivh jdk-8u221-linux-x64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完成后配置环境变量 文件：/etc/profile</span></span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_333-amd64</span><br><span class="line">CLASSPATH=$JAVA_HOME$/lib:$JAVA_HOME$/jre/lib</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH CLASSPATH JAVA_HOME</span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让新增的环境变量生效！</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 java -version</span></span><br><span class="line">[root@apathy java]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_221&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_221-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</span><br></pre></td></tr></table></figure>

<p><strong>注意：在Linux中配置环境变量不应该使用%，应该用$,分隔符也不是分号;,而是英文的冒号:</strong></p>
<p><strong>配置环境变量前先看下有没有环境变量，因为阿里云使用rpm安装jdk可能会自动帮你配好</strong></p>
<h2 id="Tomcat安装（解压缩安装）"><a href="#Tomcat安装（解压缩安装）" class="headerlink" title="Tomcat安装（解压缩安装）"></a>Tomcat安装（解压缩安装）</h2><p>1、安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！</p>
<p>2、将文件移动到&#x2F;usr&#x2F;tomcat&#x2F;下，并解压！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kuangshen kuangshen]<span class="comment"># mv apache-tomcat-9.0.22.tar.gz /usr</span></span><br><span class="line">[root@kuangshen kuangshen]<span class="comment"># cd /usr</span></span><br><span class="line">[root@kuangshen usr]<span class="comment"># ls</span></span><br><span class="line">apache-tomcat-9.0.22.tar.gz</span><br><span class="line">[root@kuangshen usr]<span class="comment"># tar -zxvf apache-tomcat-9.0.22.tar.gz   # 解压</span></span><br></pre></td></tr></table></figure>

<p>3、运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行：startup.sh --&gt;启动tomcat</span></span><br><span class="line"><span class="comment"># 执行：shutdown.sh --&gt;关闭tomcat</span></span><br><span class="line">./startup.sh</span><br><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure>

<p>4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看firewall服务状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启、重启、关闭、firewalld.service服务</span></span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all    <span class="comment"># 查看全部信息</span></span><br><span class="line">firewall-cmd --list-ports  <span class="comment"># 只看端口信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启端口</span></span><br><span class="line">开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone <span class="comment">#作用域</span></span><br><span class="line">--add-port=80/tcp  <span class="comment">#添加端口，格式为：端口/通讯协议</span></span><br><span class="line">--permanent   <span class="comment">#永久生效，没有此参数重启后失效</span></span><br></pre></td></tr></table></figure>

<h2 id="安装Docker（yum安装）"><a href="#安装Docker（yum安装）" class="headerlink" title="安装Docker（yum安装）"></a>安装Docker（yum安装）</h2><blockquote>
<p>基于 CentOS 7 安装</p>
</blockquote>
<ol>
<li><p>官网安装参考手册：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
</li>
<li><p>确定你是CentOS7及以上版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192 Desktop]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.2.1511 (Core)</span><br></pre></td></tr></table></figure>
</li>
<li><p>yum安装gcc相关（需要确保 虚拟机可以上外网 ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载旧版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br><span class="line"><span class="comment"># 官网版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">          docker-client \</span><br><span class="line">          docker-client-latest \</span><br><span class="line">          docker-common \</span><br><span class="line">          docker-latest \</span><br><span class="line">          docker-latest-logrotate \</span><br><span class="line">          docker-logrotate \</span><br><span class="line">          docker-engine</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装需要的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置stable镜像仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">## 报错</span></span><br><span class="line">[Errno 14] curl<span class="comment">#35 - TCP connection reset by peer</span></span><br><span class="line">[Errno 12] curl<span class="comment">#35 - Timeout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确推荐使用国内的</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新yum软件包索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Docker CE</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="宝塔面板安装"><a href="#宝塔面板安装" class="headerlink" title="宝塔面板安装"></a>宝塔面板安装</h2><p><a href="https://www.bilibili.com/video/av91821322">https://www.bilibili.com/video/av91821322</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBootSecurity</title>
    <url>/2022/05/02/SpringBootSecurity/</url>
    <content><![CDATA[<h1 id="SpringBoot安全框架："><a href="#SpringBoot安全框架：" class="headerlink" title="SpringBoot安全框架："></a>SpringBoot安全框架：</h1><h2 id="HttpBasic认证模式："><a href="#HttpBasic认证模式：" class="headerlink" title="HttpBasic认证模式："></a>HttpBasic认证模式：</h2><p>这是种防君子不防小人的认证，也是最简单的一个认证模式</p>
<p>编写配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line">        http.httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//所有的请求</span></span><br><span class="line">                .authorizeHttpRequests()</span><br><span class="line">                <span class="comment">//匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编写好配置文件后，启动会给出一个密码：</strong></p>
<p>我们使用该密码进行登录</p>
<p>Using generated security password: 8e0f5586-f414-454b-bd96-ffc82e919a6a</p>
<p><strong>我们自己指定用户名，密码修改配置文件application：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="comment">#配置httpBasic认证的用户名，密码</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin123</span></span><br></pre></td></tr></table></figure>



<p>启动后就不好给我们密码了，但这个密码是可以获取到的，如图：</p>
<p><img src="https://s2.loli.net/2022/03/09/Zvx8aDjWt9eLOY1.png" alt="image-20220302192907115"></p>
<p><strong>我们可以使用工具Postman获取到账户密码：</strong></p>
<p>​								登录：</p>
<p><img src="https://s2.loli.net/2022/03/09/Peuw2ZW7bDNgGcx.png" alt="image-20220303084206675"></p>
<p><strong>可以看到有给Authorization  这个是我们的账号密码使用ase64加密后的结果我们可以复制加密后的密码去解码就可以获取到账号密码了：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/zHSoTNCL1tjQf4U.png" alt="image-20220303084235403"></p>
<p><strong>解码结果：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/STXbo9kga8Ri5FH.png" alt="image-20220303091317694"></p>
<h2 id="passwrodEncoder加密"><a href="#passwrodEncoder加密" class="headerlink" title="passwrodEncoder加密"></a>passwrodEncoder加密</h2><p>passwrodEncoder加密是不可逆的</p>
<p><strong>passwrodEncoder接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line">    String <span class="title function_">encode</span><span class="params">(CharSequence rawPassword)</span>;   <span class="comment">//用于加密密码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span>;  <span class="comment">//验证输入的密码是否与加密的密码一致</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;   <span class="comment">//密码是否需要被更新，有需要可以重新该方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>推荐使用的实现类BCryptPasswordEncoder：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="comment">//密码加密</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(<span class="string">&quot;123hzr&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;一次加密:&quot;</span>+encode);</span><br><span class="line">    <span class="comment">//密码校验对比</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> bCryptPasswordEncoder.matches(<span class="string">&quot;123&quot;</span>, encode);</span><br><span class="line">    System.out.println(<span class="string">&quot;密码是否正确&quot;</span>+matches);</span><br><span class="line">    <span class="comment">//密码校验对比</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches1</span> <span class="operator">=</span> bCryptPasswordEncoder.matches(<span class="string">&quot;123hzr&quot;</span>, encode);</span><br><span class="line">    System.out.println(<span class="string">&quot;密码是否正确&quot;</span>+matches1);</span><br><span class="line">    <span class="comment">//同样密码加密，结果和第一加密码不一样，所以说passwrodEncoder加密是不可逆的</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">encode2</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(<span class="string">&quot;123hzr&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;二次加密:&quot;</span>+encode2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一次加密:$2a$10$6zuzvMqFVq89TerHtThXder6n2VqOMyJF6hpAn8ZBYjA7FaGOPzOy</span><br><span class="line">密码是否正确false</span><br><span class="line">密码是否正确true</span><br><span class="line">二次加密:$2a$10$rAznej1Fv0VGqXkXo7tKiu4c0nBwEYzVykbPfhGE9YSi25xpmTL7G</span><br></pre></td></tr></table></figure>



<p><strong>加密值解释：</strong></p>
<p>$2a  &#x2F;&#x2F;表示 BCrypt 算法版本</p>
<p>$10    &#x2F;&#x2F;表示算法强度</p>
<p>$rAznej1Fv0VGqXkXo7tK   &#x2F;&#x2F;随机生成的盐值</p>
<p>iu4c0nBwEYzVykbPfhGE9YSi25xpmTL7G  &#x2F;&#x2F;hash值</p>
<h2 id="formLogin登录认证"><a href="#formLogin登录认证" class="headerlink" title="formLogin登录认证"></a>formLogin登录认证</h2><h3 id="同样先编写配置类："><a href="#同样先编写配置类：" class="headerlink" title="同样先编写配置类："></a>同样先编写配置类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/&quot;</span>)   <span class="comment">//登录成功跳转的路径</span></span><br><span class="line">                .failureForwardUrl(<span class="string">&quot;/logins&quot;</span>)  <span class="comment">//登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>,<span class="string">&quot;/&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                auth  <span class="comment">//授权</span></span><br><span class="line">                .inMemoryAuthentication()  <span class="comment">//将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)  <span class="comment">//用户名</span></span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))  <span class="comment">//密码</span></span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)  <span class="comment">//设置使用该用户名登录赋予的角色，</span></span><br><span class="line">            .and()</span><br><span class="line">                 .withUser(<span class="string">&quot;admin&quot;</span>) <span class="comment">//用户名</span></span><br><span class="line">                 .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                   <span class="comment">//第一种授权方式</span></span><br><span class="line">                 .roles(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//设置使用该账号登录赋予的角色</span></span><br><span class="line">                   <span class="comment">//第二种授权方式</span></span><br><span class="line">                 <span class="comment">//.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //为当前用户赋予角色</span></span><br><span class="line">            .and()</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*加密方式</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="controller类："><a href="#controller类：" class="headerlink" title="controller类："></a>controller类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">indexController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/logins&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;log&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/business1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">business1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;business1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/business2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">business2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;business2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="自定义登录验证处理："><a href="#自定义登录验证处理：" class="headerlink" title="自定义登录验证处理："></a><strong>自定义登录验证处理：</strong></h2><p>这里我们需要了解一下</p>
<p><img src="https://s2.loli.net/2022/03/09/DqCRLYV6WyMAa9Q.png" alt="image-20220304105306887"></p>
<p>这两类，第一个是登录成功后的处理方式，第二给是登录失败的处理方式，我们需要重新它</p>
<p><strong>AuthenticationFailureHandler  登录失败重写：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录失败后进行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationFailureHandler</span></span><br><span class="line">	<span class="comment">//SimpleUrlAuthenticationFailureHandle 是AuthenticationFailureHandler的一个实现类</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这个一定要使用el表达式，否则这个方法都不会进  ；这个是配置文件中自定义的参数，值为JSON</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.loginType&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loginType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录失败后进行操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception  异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//判断要返回的类型</span></span><br><span class="line">        <span class="keyword">if</span> (loginType.equalsIgnoreCase(<span class="string">&quot;JSON&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//告诉浏览器，以json返回</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//要返回的数据  这里的JsonResult只是单纯的一个返回json信息格式的类</span></span><br><span class="line">            response.getWriter().write(objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;().InputError()));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//登录失败后进行的页面跳转，父类已经为我们实现了</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.onAuthenticationFailure(request, response, exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p> <strong>AuthenticationSuccessHandler 登录成功重新:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置登录成功后需要的操作</span></span><br><span class="line"><span class="comment"> * 实现AuthenticationSuccessHandler登录成功进行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationSuccessHandler</span></span><br><span class="line">    <span class="comment">//SavedRequestAwareAuthenticationSuccessHandler 继承该类，该类实现了AuthenticationSuccessHandler登录成功进行的操作</span></span><br><span class="line">    <span class="comment">//这个类中有帮我们实现一些有用的方法，比如说记住用户上一次的操作，登录后跳转的页面就是用户上一次未能进入的页面，而不是首页</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这个一定要使用el表达式，否则这个方法都不会进  ；这个是配置文件中自定义的参数，值为JSON</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.loginType&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loginType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是登录成功后执行的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//判断要返回的类型</span></span><br><span class="line">        <span class="keyword">if</span> (loginType.equalsIgnoreCase(<span class="string">&quot;JSON&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//告诉浏览器，以json返回</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//要返回的数据</span></span><br><span class="line">            response.getWriter().write(objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">JsonResult</span>().success()));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//会帮助我们跳转到上一次请求的页面 ,这个方法也就是我们重新的这个方法</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.onAuthenticationSuccess(request,response,authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>Security配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>,<span class="string">&quot;/&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                auth  <span class="comment">//授权</span></span><br><span class="line">                .inMemoryAuthentication()  <span class="comment">//将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)  <span class="comment">//用户名</span></span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))  <span class="comment">//密码</span></span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)  <span class="comment">//设置使用该用户名登录赋予的角色，</span></span><br><span class="line">            .and()</span><br><span class="line">                 .withUser(<span class="string">&quot;admin&quot;</span>) <span class="comment">//用户名</span></span><br><span class="line">                 .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                   <span class="comment">//第一种授权方式</span></span><br><span class="line">                 .roles(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//设置使用该账号登录赋予的角色</span></span><br><span class="line">                   <span class="comment">//第二种授权方式</span></span><br><span class="line">                 <span class="comment">//.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //为当前用户赋予角色</span></span><br><span class="line">            .and()</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>由于这里返回的是Json数据，注意，那么login就需要使用Ajax的方式请求数据：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username=$(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> password=$(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;user&quot;</span>: username,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;password&quot;</span>: password</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span> (json.<span class="property">state</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(json.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/logins&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="session会话的安全管理："><a href="#session会话的安全管理：" class="headerlink" title="session会话的安全管理："></a>session会话的安全管理：</h2><p><img src="https://s2.loli.net/2022/03/09/yDC5PVItQqJhvg2.png" alt="image-20220304121119473"></p>
<p><img src="https://s2.loli.net/2022/03/09/HZw4NyRuXetcvqo.png" alt="image-20220304121220680"></p>
<p>添加以上配置示例：</p>
<p><img src="https://s2.loli.net/2022/03/09/VdxHK6JY45FvpBl.png" alt="image-20220304121253830"></p>
<p><strong>session的安全保护：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/MEb92jfIm6XRuiA.png" alt="image-20220304121414386"></p>
<p><strong>cookie的安全：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/c874Wyzg2Rf93JD.png" alt="image-20220304121440993"></p>
<h2 id="同账号多登录踢下线："><a href="#同账号多登录踢下线：" class="headerlink" title="同账号多登录踢下线："></a>同账号多登录踢下线：</h2><p><strong>踢下线处理类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置当session被踢下线之后的操作，如：跳转页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomExpiredSessionStrategy</span></span><br><span class="line">    <span class="comment">//需要实现该接口</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">SessionInformationExpiredStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页面跳转的处理类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedirectStrategy</span> <span class="variable">redirectStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultRedirectStrategy</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于将对象转换为json格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当发现session踢下线就会调用该方法处理，前提需要再配置类中使用该类处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event  这个类中可以获取到requesty 与 respoense</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onExpiredSessionDetected</span><span class="params">(SessionInformationExpiredEvent event)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两种方式，前后端分离，JSON格式，与直接跳转页面的的方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式二，json格式</span></span><br><span class="line">            <span class="comment">//这里使用map也行，对象也行，就是返回的信息</span></span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            map.put(<span class="string">&quot;stat&quot;</span>,<span class="string">&quot;200&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;请重新进行登录&quot;</span>+event.getSessionInformation().getLastRequest());  <span class="comment">//后面的登录时间</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> objectMapper.writeValueAsString(map);</span><br><span class="line">            event.getResponse().setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            event.getResponse().getWriter().write(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            //方式一，直接跳转  这个方法是重定向到指定的页面</span></span><br><span class="line"><span class="comment">//            redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),&quot;/logins&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>在securty配置类中配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>,<span class="string">&quot;/&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated()</span><br><span class="line">                </span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                auth  <span class="comment">//授权</span></span><br><span class="line">                .inMemoryAuthentication()  <span class="comment">//将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)  <span class="comment">//用户名</span></span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))  <span class="comment">//密码</span></span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)  <span class="comment">//设置使用该用户名登录赋予的角色，</span></span><br><span class="line">            .and()</span><br><span class="line">                 .withUser(<span class="string">&quot;admin&quot;</span>) <span class="comment">//用户名</span></span><br><span class="line">                 .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                   <span class="comment">//第一种授权方式</span></span><br><span class="line">                 .roles(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//设置使用该账号登录赋予的角色</span></span><br><span class="line">                   <span class="comment">//第二种授权方式</span></span><br><span class="line">                 <span class="comment">//.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //为当前用户赋予角色</span></span><br><span class="line">            .and()</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="RBAC权限管理控制模型"><a href="#RBAC权限管理控制模型" class="headerlink" title="RBAC权限管理控制模型"></a><strong>RBAC权限管理控制模型</strong></h2><p><img src="https://s2.loli.net/2022/03/09/tsqKGbhigTXQwOS.png" alt="image-20220307195430369"></p>
<p><img src="https://s2.loli.net/2022/03/09/eFplaSkOnAr2TCc.png" alt="image-20220307195418619"></p>
<h2 id="动态加载用户角色权限数据："><a href="#动态加载用户角色权限数据：" class="headerlink" title="动态加载用户角色权限数据："></a>动态加载用户角色权限数据：</h2><p>首先我们需要实现两个类，一个是UserDetails，还有个是UserDetailsService</p>
<p>UserDetails ：这个接口为的是存放用户详细信息，</p>
<p>UserDetailsService：为加载用户的信息填写到UserDetails 中并返回给Security使用</p>
<h3 id="UserDetails："><a href="#UserDetails：" class="headerlink" title="UserDetails："></a><strong>UserDetails：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于获取用户详细信息，</span></span><br><span class="line"><span class="comment"> * 需要使用UserDetailsService为当前类绑定信息；</span></span><br><span class="line"><span class="comment"> * 还需要手动创建set方法赋值，已经创建对应的属性存值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetails</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities;  <span class="comment">//用户的权限集合</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthorities</span><span class="params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountNonExpired</span><span class="params">(<span class="type">boolean</span> accountNonExpired)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNonExpired = accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountNonLocked</span><span class="params">(<span class="type">boolean</span> accountNonLocked)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNonLocked = accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCredentialsNonExpired</span><span class="params">(<span class="type">boolean</span> credentialsNonExpired)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.credentialsNonExpired = credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> accountNonExpired; <span class="comment">//账号是否没过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> accountNonLocked; <span class="comment">//账号是否没被锁定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> credentialsNonExpired;  <span class="comment">//用户凭证是否没过期    or 密码是否过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;  <span class="comment">//账户是否可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户的权限集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号是否没过期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  这里由于我数据库没加这个字段就默认为true了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号是否没被锁定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  这里由于我数据库没加这个字段就默认为true了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码是否没过期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  这里由于我数据库没加这个字段就默认为true了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户是否可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyUserDetails</span> <span class="variable">that</span> <span class="operator">=</span> (MyUserDetails) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">accountNonExpired</span> <span class="operator">=</span>= that.accountNonExpired &amp;&amp; accountNonLocked == that.accountNonLocked &amp;&amp; credentialsNonExpired 			== that.credentialsNonExpired &amp;&amp; enabled == that.enabled &amp;&amp; Objects.equals(authorities, that.authorities) &amp;&amp; 				   Objects.equals(password, that.password) &amp;&amp; Objects.equals(username, that.username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(authorities, password, username, accountNonExpired, accountNonLocked, credentialsNonExpired, 				enabled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="UserDetailsService："><a href="#UserDetailsService：" class="headerlink" title="UserDetailsService："></a>UserDetailsService：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于加载UserDetails中的详细信息</span></span><br><span class="line"><span class="comment"> * 为替换掉security配置类中的静态授权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里三个查询其实可以放一起的，毕竟都是查询用户权限的</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleMapper roleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  使用传入的唯一标识（username） 查询用户信息，并组装成为UserDetails类返回，返回后security就会拿到哪些数据并进行验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  动态添加security认证，鉴权，授权相关的基础信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username  用户输入的账户，也就是security配置类中的 .usernameParameter(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">MyUserDetails</span> <span class="variable">myUserDetails</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyUserDetails</span>();</span><br><span class="line">      <span class="comment">//获取用户基本信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.UserFiend(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        myUserDetails.setPassword(user.getPassword());</span><br><span class="line">        myUserDetails.setUsername(user.getUsername());</span><br><span class="line">        myUserDetails.setEnabled(user.isEnabled());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查询用户角色,赋予用户角色，我们需要在角色前加上 ROLE_</span></span><br><span class="line">        List&lt;String&gt; list = roleMapper.listByUserId(user.getId());</span><br><span class="line">        <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> roleMapper.fiendByUserId(user.getId());</span><br><span class="line">        <span class="comment">//在每个元素前加上ROLE_，获取角色</span></span><br><span class="line">        list=list.stream().map(rc-&gt; <span class="string">&quot;ROLE_&quot;</span> +rc).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据角色获取解释对应的权限，这个是只获取要权限的页面</span></span><br><span class="line">        List&lt;String&gt; list1 = menuMapper.listByRoleId(role.getId());</span><br><span class="line">        <span class="comment">//将角色与要权限的页面绑定</span></span><br><span class="line">        list1.addAll(list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//这一步就如同为角色赋予权限</span></span><br><span class="line">        myUserDetails.setAuthorities(</span><br><span class="line">                <span class="comment">//由于List不能直接赋值给Authorities 所有使用AuthorityUtils.commaSeparatedStringToAuthorityList()来解决</span></span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(</span><br><span class="line">                        String.join(<span class="string">&quot;,&quot;</span>,list1)  <span class="comment">//将授权页面与角色用逗号分开</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回当前用户的登录授权信息，交给iSecurity</span></span><br><span class="line">        <span class="keyword">return</span> myUserDetails;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修改Security配置类："><a href="#修改Security配置类：" class="headerlink" title="修改Security配置类："></a>修改Security配置类：</h3><p>注意：这里由于一些我也不知道的问题，这里的同账户登录多人不会被踢下线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//____________________静态授权________________________</span></span><br><span class="line"><span class="comment">//                auth  //授权</span></span><br><span class="line"><span class="comment">//                .inMemoryAuthentication()  //将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line"><span class="comment">//                .withUser(&quot;user&quot;)  //用户名</span></span><br><span class="line"><span class="comment">//                .password(passwordEncoder().encode(&quot;123456&quot;))  //密码</span></span><br><span class="line"><span class="comment">//                .roles(&quot;user&quot;)  //设置使用该用户名登录赋予的角色，</span></span><br><span class="line"><span class="comment">//            .and()</span></span><br><span class="line"><span class="comment">//                 .withUser(&quot;admin&quot;) //用户名</span></span><br><span class="line"><span class="comment">//                 .password(passwordEncoder().encode(&quot;123456&quot;))</span></span><br><span class="line"><span class="comment">//                   //第一种授权方式</span></span><br><span class="line"><span class="comment">//                 .roles(&quot;admin&quot;)  //设置使用该账号登录赋予的角色</span></span><br><span class="line"><span class="comment">//                   //第二种授权方式</span></span><br><span class="line"><span class="comment">//                 //.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="动态鉴权规则："><a href="#动态鉴权规则：" class="headerlink" title="动态鉴权规则："></a><strong>动态鉴权规则：</strong></h2><p>用于代替静态的鉴权规则</p>
<h5 id="自定义鉴权规则："><a href="#自定义鉴权规则：" class="headerlink" title="自定义鉴权规则："></a>自定义鉴权规则：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态判断用户是否用于访问页面的权限，类名可以随便取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;MyRBACService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRBACService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于验证当前用户，是否能访问当前请求的资格与权限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication  通过认证的用户主体详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有权限返回true ，没权限返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span>&#123;</span><br><span class="line">        <span class="comment">//获取主体信息UserDetails</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> authentication.getPrincipal();</span><br><span class="line">        <span class="comment">//判断principal是否是UserDetails</span></span><br><span class="line">        <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> (UserDetails) principal;</span><br><span class="line">            <span class="comment">//将获取到的这一次请求的资源路径转换为SimpleGrantedAuthority类型，</span></span><br><span class="line">            <span class="comment">// 因为UserDetails中Authorities存放用户权限的类型是SimpleGrantedAuthority类型</span></span><br><span class="line">            <span class="type">SimpleGrantedAuthority</span> <span class="variable">simpleGrantedAuthority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(request.getRequestURI());</span><br><span class="line">            <span class="comment">//判断当前用户的权限中是发拥有可以访问这个资源路径的权限</span></span><br><span class="line">            <span class="comment">// contains这个方法是用于判断当前集合是否有相同的</span></span><br><span class="line">            <span class="keyword">return</span> userDetails.getAuthorities().contains(simpleGrantedAuthority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="Security配置类："><a href="#Security配置类：" class="headerlink" title="Security配置类："></a>Security配置类：</h5><p>这里使用动态鉴权规则后就不能使用静态授权，因为静态授权只是当前授权了角色，但角色的权限是没有配置的，我们可以看到动态鉴权是直接对当前当前用户角色可以访问的权限进行对比的，静态的只有单纯的角色，但角色是什么权限都没有的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                <span class="comment">//____________________静态鉴权____________________________________</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/business1&quot;,&quot;/business2&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasAnyAuthority(&quot;ROLE_user&quot;,&quot;ROLE_admin&quot;)//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;,&quot;/user&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasRole(&quot;admin&quot;)//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"><span class="comment">//                //选择的匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated()</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                    <span class="comment">//anyRequest  所有的请求</span></span><br><span class="line">                    <span class="comment">//access   访问权限</span></span><br><span class="line">                    /里面使用SpEL权限表达式</span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//____________________静态授权________________________</span></span><br><span class="line"><span class="comment">//                auth  //授权</span></span><br><span class="line"><span class="comment">//                .inMemoryAuthentication()  //将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line"><span class="comment">//                .withUser(&quot;user&quot;)  //用户名</span></span><br><span class="line"><span class="comment">//                .password(passwordEncoder().encode(&quot;123456&quot;))  //密码</span></span><br><span class="line"><span class="comment">//                .roles(&quot;user&quot;)  //设置使用该用户名登录赋予的角色，</span></span><br><span class="line"><span class="comment">//            .and()</span></span><br><span class="line"><span class="comment">//                 .withUser(&quot;admin&quot;) //用户名</span></span><br><span class="line"><span class="comment">//                 .password(passwordEncoder().encode(&quot;123456&quot;))</span></span><br><span class="line"><span class="comment">//                   //第一种授权方式</span></span><br><span class="line"><span class="comment">//                 .roles(&quot;admin&quot;)  //设置使用该账号登录赋予的角色</span></span><br><span class="line"><span class="comment">//                   //第二种授权方式</span></span><br><span class="line"><span class="comment">//                 //.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //</span></span><br><span class="line"><span class="comment">//                    .and().passwordEncoder(passwordEncoder()); //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="方法增强注解："><a href="#方法增强注解：" class="headerlink" title="方法增强注解："></a>方法增强注解：</h5><p><img src="https://s2.loli.net/2022/03/09/wSlBCNefJyq2sxP.png" alt="image-20220308200231990"></p>
<p><strong>@PreAuthorize(“SPEL”):  方法执行前判断用户调用权限</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/37T2DwRsaM96zSh.png" alt="image-20220308200604674"></p>
<p><strong>@PreFilter(“SPEL”):方法执行前过滤参数</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/QNLUZrw7TIMDj5P.png" alt="image-20220308200655277"></p>
<p><strong>@PostAuthorize(“SPEL”):方法执行后判断</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/IYaygrwcXiAqV7v.png" alt="image-20220308200824019"></p>
<p><strong>@PostFilter（”SPEL“） ： 方法执行完后过滤返回值</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/Hw7KEVztY8FCk52.png" alt="image-20220308200910568"></p>
<p><strong>在Security配置类中开启这个是个注解的使用：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/iwQUNd5Rg3phnHk.png" alt="image-20220308200954913"></p>
<h2 id="记住我功能："><a href="#记住我功能：" class="headerlink" title="记住我功能："></a>记住我功能：</h2><p>这个配置使用十分的简单</p>
<p><img src="https://s2.loli.net/2022/03/21/I4d1MPALWe8Qumq.png" alt="image-20220309223842857"></p>
<h5 id="Security配置类"><a href="#Security配置类" class="headerlink" title="Security配置类:"></a>Security配置类:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        http.rememberMe()<span class="comment">//开启记住我功能  ，前端也需要有记住我字段</span></span><br><span class="line">                .rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">                .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">                .tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h5 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">     记住我<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username=$(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> password=$(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> remember=$(<span class="string">&quot;#remember-me&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;checked&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(remember)</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;user&quot;</span>: username,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;password&quot;</span>: password,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;remember-me&quot;</span>:remember</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span> (json.<span class="property">state</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(json.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/logins&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>勾选记住我登录后会出现remember -me这个cookie</p>
<p><img src="https://s2.loli.net/2022/03/21/TPBXH6aGkDcMyuN.png" alt="image-20220309224317467"></p>
<p>其实它是有两层加密，最外层它是使用Base64加密的：</p>
<p>​						解码</p>
<p><img src="https://s2.loli.net/2022/03/21/tgj25RVxHfU8cXq.png" alt="image-20220309224554252"></p>
<p>密码还使用MD5加密:</p>
<p>TokenBasedRememberMeServices类源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">makeTokenSignature</span><span class="params">(<span class="type">long</span> tokenExpiryTime, String username, String password)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> username + <span class="string">&quot;:&quot;</span> + tokenExpiryTime + <span class="string">&quot;:&quot;</span> + password + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getKey();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Hex.encode(digest.digest(data.getBytes())));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No MD5 algorithm available!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这图进行解释</p>
<p><img src="https://s2.loli.net/2022/03/21/P15bc6jrSX9aMuU.png" alt="image-20220309224722249"></p>
<h5 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h5><p><img src="https://s2.loli.net/2022/03/21/GaHOPL49KkQlRyg.png" alt="image-20220309224647471"></p>
<h2 id="记住我功能将验证数据保存到数据库："><a href="#记住我功能将验证数据保存到数据库：" class="headerlink" title="记住我功能将验证数据保存到数据库："></a>记住我功能将验证数据保存到数据库：</h2><p>我们没使用数据库存储令牌校验，当我们关闭程序时，记住我功能则会失效，客户端有session也没有用，在内存中令牌校验的数据被清空了，</p>
<p>为了防止重启程序而导致记住我失效，我们将信息存储到数据库中，</p>
<p>注意：这个存储的不是你的session，你在浏览器删除session那么同样需要重新输入密码，存储到数据库中的是类似令牌校验的信息</p>
<p><strong>先创建数据库：</strong></p>
<p>这个表是固定的，不能修改，在提供的类中，有个方法也可以创建，我们这就手动创建了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `persistent_logins`(</span><br><span class="line">`username` varchar (64) NOT NULL,</span><br><span class="line">`series` varchar (64) NOT NULL,</span><br><span class="line">`token` varchar(64) NOT NULL,</span><br><span class="line">`last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (series)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>





<p>在Security配置类中注入一个数据源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure>



<p>再编辑一个bean 指定存储到数据库的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTokenRepositoryImpl 这个类是将数据保存到数据操作的类，里面有很多sql语句的，可以自己去看看</span></span><br><span class="line"><span class="comment"> * 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span></span><br><span class="line"><span class="comment"> * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span></span><br><span class="line"><span class="comment"> * 设置记住我存储到的数据源是哪个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PersistentTokenRepository <span class="title function_">tokenRepository</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然在告诉security指定使用这个bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">.rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">.tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line">.tokenRepository(tokenRepository())  <span class="comment">//指定rememberMe存储到数据库规则方法</span></span><br></pre></td></tr></table></figure>





<p>完整配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        http.rememberMe()<span class="comment">//开启记住我功能  ，前端也需要有记住我字段</span></span><br><span class="line">                .rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">                .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">                .tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line">                .tokenRepository(tokenRepository())  <span class="comment">//指定rememberMe存储到数据库规则方法</span></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span></span><br><span class="line"><span class="comment">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span></span><br><span class="line"><span class="comment">     * 设置记住我存储到的数据源是哪个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersistentTokenRepository <span class="title function_">tokenRepository</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SPEL表达式：</p>
<p><img src="https://s2.loli.net/2022/03/21/nBC3wzYPX4Gocq9.png" alt="image-20220317231517131"></p>
<h2 id="退出登录："><a href="#退出登录：" class="headerlink" title="退出登录："></a>退出登录：</h2><h5 id="最简单的实现"><a href="#最简单的实现" class="headerlink" title="最简单的实现"></a><strong>最简单的实现</strong></h5><p>后端配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.logout()//开启退出登录</span><br></pre></td></tr></table></figure>



<p>前端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt;</span><br></pre></td></tr></table></figure>





<h5 id="Logout的默认行为"><a href="#Logout的默认行为" class="headerlink" title="Logout的默认行为"></a>Logout的默认行为</h5><p>1，当前session失效，即: logout的核心需求，session失效就是访问权限的回收</p>
<p>2，删除当前用户的remember-me“记住我”功能信息，数据库中的也会删除</p>
<p>3，clear清除当前的SecurityContext ，可以看做清除了也会的主体信息等</p>
<p>4，重定向到登录页面，loginPage配置项指定的页面</p>
<h5 id="个性化配置-1"><a href="#个性化配置-1" class="headerlink" title="个性化配置"></a>个性化配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">//退出后跳转的页面  默认退出到login页面</span></span><br><span class="line">.deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>) <span class="comment">//退出后要删除的cookie 参数是cookie名称</span></span><br><span class="line">.logoutUrl(<span class="string">&quot;/logout&quot;</span>)  <span class="comment">//退出请求路径，也就是页面上退出登录的路径，别忘了前端页面也要改  默认logout</span></span><br></pre></td></tr></table></figure>





<h5 id="LogoutSuccessHandler-实现个性化规程功能"><a href="#LogoutSuccessHandler-实现个性化规程功能" class="headerlink" title="LogoutSuccessHandler:实现个性化规程功能"></a>LogoutSuccessHandler:实现个性化规程功能</h5><p>注意，不要与logoutSuccessUrl以前使用，否则会失效</p>
<p><strong>自定义类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义退出后需要进行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行重新方法失效个性化退出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication  主体信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;附加逻辑代码..........&quot;</span>);</span><br><span class="line"></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Security配置类:</strong>	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//退出登录自定义策略</span><br><span class="line">@Autowired</span><br><span class="line">private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        //开启formLogin登录认证</span><br><span class="line">        http.</span><br><span class="line">                logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br></pre></td></tr></table></figure>



<p><strong>完整Security配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出登录自定义策略</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        http.</span><br><span class="line">                logout()<span class="comment">//开启退出登录</span></span><br><span class="line"><span class="comment">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span></span><br><span class="line">                .deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>) <span class="comment">//指定退出后要删除的cookie</span></span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)  <span class="comment">//退出请求路径，也就是页面上退出登录访问的地址  默认logout</span></span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) <span class="comment">//使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()<span class="comment">//开启记住我功能  ，前端也需要有记住我字段</span></span><br><span class="line">                .rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">                .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">                .tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line">                .tokenRepository(tokenRepository())  <span class="comment">//指定rememberMe存储到数据库规则方法</span></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                <span class="comment">//____________________静态鉴权____________________________________</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/business1&quot;,&quot;/business2&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasAnyAuthority(&quot;ROLE_user&quot;,&quot;ROLE_admin&quot;)//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;,&quot;/user&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasRole(&quot;admin&quot;)//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"><span class="comment">//                //选择的匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated()</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//____________________静态授权________________________</span></span><br><span class="line"><span class="comment">//                auth  //授权</span></span><br><span class="line"><span class="comment">//                .inMemoryAuthentication()  //将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line"><span class="comment">//                .withUser(&quot;user&quot;)  //用户名</span></span><br><span class="line"><span class="comment">//                .password(passwordEncoder().encode(&quot;123456&quot;))  //密码</span></span><br><span class="line"><span class="comment">//                .roles(&quot;user&quot;)  //设置使用该用户名登录赋予的角色，</span></span><br><span class="line"><span class="comment">//            .and()</span></span><br><span class="line"><span class="comment">//                 .withUser(&quot;admin&quot;) //用户名</span></span><br><span class="line"><span class="comment">//                 .password(passwordEncoder().encode(&quot;123456&quot;))</span></span><br><span class="line"><span class="comment">//                   //第一种授权方式</span></span><br><span class="line"><span class="comment">//                 .roles(&quot;admin&quot;)  //设置使用该账号登录赋予的角色</span></span><br><span class="line"><span class="comment">//                   //第二种授权方式</span></span><br><span class="line"><span class="comment">//                 //.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //</span></span><br><span class="line"><span class="comment">//                    .and().passwordEncoder(passwordEncoder()); //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span></span><br><span class="line"><span class="comment">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span></span><br><span class="line"><span class="comment">     * 设置记住我存储到的数据源是哪个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersistentTokenRepository <span class="title function_">tokenRepository</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="Session方式实现图片验证码"><a href="#Session方式实现图片验证码" class="headerlink" title="Session方式实现图片验证码:"></a>Session方式实现图片验证码:</h2><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p>我们需要先导入工具类库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   验证码工具类库  这是Google提供的一个类库   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://s2.loli.net/2022/03/21/UtEnrpe3u1wLfqc.png" alt="image-20220312105200767"></p>
<p>如何我们需要这个类库配置一下参数，</p>
<p>有两种方式，第一种是使用application.properties 这种方式直接配置，第二种就是自己直接手动配置</p>
<h5 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a><strong>第一种方式：</strong></h5><p>直接将配置文件写入</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">kaptcha.border</span>=<span class="string">no</span></span><br><span class="line"><span class="attr">kaptcha.border.color</span>=<span class="string">105,179,90</span></span><br><span class="line"><span class="attr">kaptcha.image.width</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">kaptcha.image.height</span>=<span class="string">45</span></span><br><span class="line"><span class="attr">kaptcha.session.key</span>=<span class="string">code</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.color</span>=<span class="string">blue</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.size</span>=<span class="string">35</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.names</span>=<span class="string">宋体,楷体,微软雅黑</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.char.length</span>=<span class="string">4</span></span><br></pre></td></tr></table></figure>



<h5 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a><strong>第二种方式：</strong></h5><p>先创建一个properties的普通文件再将这些导入：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">kaptcha.border</span>=<span class="string">no</span></span><br><span class="line"><span class="attr">kaptcha.border.color</span>=<span class="string">105,179,90</span></span><br><span class="line"><span class="attr">kaptcha.image.width</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">kaptcha.image.height</span>=<span class="string">45</span></span><br><span class="line"><span class="attr">kaptcha.session.key</span>=<span class="string">code</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.color</span>=<span class="string">blue</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.size</span>=<span class="string">35</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.names</span>=<span class="string">宋体,楷体,微软雅黑</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.char.length</span>=<span class="string">4</span></span><br></pre></td></tr></table></figure>



<h5 id="再创建一个配置类："><a href="#再创建一个配置类：" class="headerlink" title="再创建一个配置类："></a><strong>再创建一个配置类：</strong></h5><p>这个是使用的第二种方式，所以我们这个需要使用@PropertySource()去导入一下我们的properties文件，如何使用2Value注入下 </p>
<p>其实两种方式都一样，只是一个需要使用@PropertySource() 去导入，一个可以直接使用@Value注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:kaptcha.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KaptChaConf</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.border&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String border;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.border.color&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String borderColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.font.color&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fontColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.image.width&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String imageWidth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.image.height&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String imageHeight;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.session.key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sessionKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.char.length&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String charLength;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.font.names&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fontNames;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.font.size&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fontSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;captchaProducer&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultKaptcha <span class="title function_">getKaptCha</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//拥有创建谜底和谜面的方法, createImage(String text)创建谜面图片，createText()创建谜底文字</span></span><br><span class="line">        <span class="type">DefaultKaptcha</span> <span class="variable">defaultKaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultKaptcha</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border&quot;</span>,border);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border.color&quot;</span>,borderColor);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>,imageWidth);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>,imageHeight);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.session.key&quot;</span>,sessionKey);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.color&quot;</span>,fontColor);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.size&quot;</span>,fontSize);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.names&quot;</span>,fontNames);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>,charLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置Kaptcha的配置 ,</span></span><br><span class="line">        defaultKaptcha.setConfig(<span class="keyword">new</span> <span class="title class_">Config</span>(properties));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="实现图片验证码加载："><a href="#实现图片验证码加载：" class="headerlink" title="实现图片验证码加载："></a>实现图片验证码加载：</h3><h5 id="存储谜底与验证码过期时间类"><a href="#存储谜底与验证码过期时间类" class="headerlink" title="存储谜底与验证码过期时间类"></a>存储谜底与验证码过期时间类</h5><p>由于图片验证码有过期时间，我们需要先创建一个类了存储我们图片验证码的谜底与过期数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储谜底与验证码过期时间</span></span><br><span class="line"><span class="comment"> * 用于实现验证码过期，所有创建此类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaImageVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String captchaCode; <span class="comment">//验证码谜底</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;  <span class="comment">//验证码过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> captchaCode  谜底</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireAfterSeconds  过期秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CaptchaImageVo</span><span class="params">(String captchaCode,<span class="type">int</span> expireAfterSeconds)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.captchaCode=captchaCode;</span><br><span class="line">        <span class="comment">//当前时间加上指定的秒数</span></span><br><span class="line">        <span class="built_in">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断验证码是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpired</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断当前时间是否大于过期时间，大于则失效</span></span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().isAfter(expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取captchaCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCoed</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> captchaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="验证码图片Controller："><a href="#验证码图片Controller：" class="headerlink" title="验证码图片Controller："></a>验证码图片Controller：</h5><p>我们需要将验证码图片输出到页面，所以我们需要一个controller用来输出，图片我们需要使用流来输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/kaptcha&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kaptcha</span><span class="params">(HttpSession session, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setDateHeader(<span class="string">&quot;Expires&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-store, no-cache, must-revalidate&quot;</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;post-check=0, pre-check=0&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">//获取谜底</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> defaultKaptcha.createText();</span><br><span class="line">        <span class="comment">//将谜底与过期时间放到session中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;captcha_key&quot;</span>,<span class="keyword">new</span> <span class="title class_">CaptchaImageVo</span>(text,<span class="number">2</span>*<span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个方式使用我们不用自己去关闭流，它自动关闭，这是jdk7的语法</span></span><br><span class="line">        <span class="keyword">try</span>(ServletOutputStream out=response.getOutputStream())&#123;</span><br><span class="line">            <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> defaultKaptcha.createImage(text);</span><br><span class="line">            <span class="comment">//将图片以Io输出， 参数： 图片的字节 ， 图片格式 ，输入流</span></span><br><span class="line">            ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,out);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每当缓冲区数据进入满载状态时，会对数据进行一次写出。</span></span><br><span class="line">            <span class="comment">// 假如最后一次的数据量没有达到让缓冲区进入满载状态，这时候不主动调用flush()方法缓冲区数据将会丢失</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="前端接收："><a href="#前端接收：" class="headerlink" title="前端接收："></a>前端接收：</h5><p>千万记着鉴权那开放访问权限</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    验证码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captchaCoed&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captchaCoed&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/kaptcha&quot;</span> <span class="attr">id</span>=<span class="string">&quot;kaptcha&quot;</span> <span class="attr">width</span>=<span class="string">&quot;110px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;40px&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">     记住我<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//用于点击刷新验证码图片</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#kaptcha&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#kaptcha&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;/kaptcha?&quot;</span>+<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">100</span>))</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username=$(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> password=$(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> remember=$(<span class="string">&quot;#remember-me&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;checked&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(remember)</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;user&quot;</span>: username,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;password&quot;</span>: password,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;remember-me&quot;</span>:remember</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span> (json.<span class="property">state</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(json.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/logins&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="图片验证码验证："><a href="#图片验证码验证：" class="headerlink" title="图片验证码验证："></a>图片验证码验证：</h3><p><img src="https://s2.loli.net/2022/03/21/v839L1PAlIVgajO.png" alt="image-20220313101138743"></p>
<p>如图所示，我们需要创建一个验证码过滤器，并且在usernamepasswordAuthentionFilter之前执行</p>
<h5 id="在这其中要我们需要修改下原来的登录错误处理类："><a href="#在这其中要我们需要修改下原来的登录错误处理类：" class="headerlink" title="在这其中要我们需要修改下原来的登录错误处理类："></a><strong>在这其中要我们需要修改下原来的登录错误处理类：</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 登录失败后进行的操作</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class MyAuthenticationFailureHandler</span><br><span class="line">    extends SimpleUrlAuthenticationFailureHandler &#123;</span><br><span class="line"></span><br><span class="line">    //注意这个一定要使用el表达式，否则这个方法都不会进</span><br><span class="line">    @Value(&quot;$&#123;spring.security.loginType&#125;&quot;)</span><br><span class="line">    private String loginType;</span><br><span class="line"></span><br><span class="line">    //用于将对象转换为json格式</span><br><span class="line">    private static ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录失败后进行操作</span><br><span class="line">     * @param request 请求</span><br><span class="line">     * @param response 响应</span><br><span class="line">     * @param exception  异常</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        //错误信息</span><br><span class="line">        String errorMsg=&quot;登录失败,用户名或密码错误&quot;;</span><br><span class="line"></span><br><span class="line">        //判断异常是否是SessionAuthenticationException类型，这个类型是验证码校验那抛出的异常</span><br><span class="line">        if (exception instanceof SessionAuthenticationException)&#123;</span><br><span class="line">            //将错误信息赋给错误信息返回出去</span><br><span class="line">            errorMsg=exception.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断要返回的类型</span><br><span class="line">        if (loginType.equalsIgnoreCase(&quot;JSON&quot;))&#123;</span><br><span class="line">            //告诉浏览器，以json返回</span><br><span class="line">            response.setContentType(&quot;application/json;charset=UTF-8&quot;);</span><br><span class="line">            //要返回的数据</span><br><span class="line">            response.getWriter().write(objectMapper.writeValueAsString(new JsonResult&lt;&gt;().InputError(errorMsg)));</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //登录失败后进行的页面跳转，父类已经为我们实现了</span><br><span class="line">            response.setContentType(&quot;application/html;charset=UTF-8&quot;);</span><br><span class="line">            super.onAuthenticationFailure(request, response, exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="并且我们定义一个常量类，为了跟方便记住重复参数信息："><a href="#并且我们定义一个常量类，为了跟方便记住重复参数信息：" class="headerlink" title="并且我们定义一个常量类，为了跟方便记住重复参数信息："></a><strong>并且我们定义一个常量类，为了跟方便记住重复参数信息：</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CaptchaConstant &#123;</span><br><span class="line">    public static final String CAPTCHA_SESSION_KEY=&quot;captcha_key&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建过滤器："><a href="#创建过滤器：" class="headerlink" title="创建过滤器："></a>创建过滤器：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义过滤器 ，在登录身份校验前先进行检查，验证码是否正确</span><br><span class="line"> * 也可以使用Filter</span><br><span class="line"> * OncePerRequestFilter是Filter的实现类</span><br><span class="line"> * OncePerRequestFilter 每次登录都拦截一次，</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CaptchaCodeFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是我们自定义登录失败的处理方式</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain filterChain)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //判断当前请求是否是向/login发送请求，并且是以post请求提交的</span><br><span class="line">        if (&quot;/login&quot;.equals(request.getRequestURI())</span><br><span class="line">                &amp;&amp; &quot;post&quot;.equalsIgnoreCase(request.getMethod()))&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //验证码校验操作</span><br><span class="line">                captchaVerify(request);</span><br><span class="line">            &#125;catch (AuthenticationException e)&#123;</span><br><span class="line">                //SessionAuthenticationException这个异常是继承了AuthenticationException的</span><br><span class="line">                //我们自定义异常时同样也需继承AuthenticationException</span><br><span class="line">                //我们将错误处理交给登录实现处理类进行操作</span><br><span class="line">                myAuthenticationFailureHandler.onAuthenticationFailure(request,response,e);</span><br><span class="line">                //由于这里已经是发生了异常的，我们就不能让程序再进行往下走了</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果验证成功后不是登录操作就进行放行</span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证码验证操作</span><br><span class="line">     * 里面的异常是可以自定义的，不一定就要用系统提供的</span><br><span class="line">     */</span><br><span class="line">    private void captchaVerify(HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">        //获取session，session中有用户的谜底与验证码过期时间</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">        //获取用户输入的验证码</span><br><span class="line">        String captchaCoed = request.getParameter(&quot;captchaCoed&quot;);</span><br><span class="line">        System.out.println(captchaCoed);</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否为空</span><br><span class="line">        if (captchaCoed.trim().isEmpty())&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取我们存入session中的CaptchaImageVo，也就是谜底与过期时间类</span><br><span class="line">        CaptchaImageVo captchaImageVo = (CaptchaImageVo)session.getAttribute(CaptchaConstant.CAPTCHA_SESSION_KEY);</span><br><span class="line">        System.out.println(captchaImageVo.getCoed());</span><br><span class="line">        //判断session中使用有谜底</span><br><span class="line">        if (Objects.isNull(captchaImageVo))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断验证码是否过期</span><br><span class="line">        if (captchaImageVo.isExpired())&#123;</span><br><span class="line">            //移出以前的CaptchaImageVo</span><br><span class="line">            session.removeAttribute(CaptchaConstant.CAPTCHA_SESSION_KEY);</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否与谜底一致，getCoed()这个方法就是单纯的获取captchaImageVo中的coed</span><br><span class="line">        if (!captchaCoed.trim().equalsIgnoreCase(captchaImageVo.getCoed()))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Security配置类：-1"><a href="#Security配置类：-1" class="headerlink" title="Security配置类："></a>Security配置类：</h5><p>在配置中配置在UsernamePasswordAuthenticationFilter之前插入我们创建的过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将我们自定义的这两个类使用IOC容器装配</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  //登录成功处理</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;  //登录失败处理</span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    //验证码过滤器</span><br><span class="line">    @Autowired</span><br><span class="line">    private CaptchaCodeFilter captchaCodeFilter;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //开启formLogin登录认证</span><br><span class="line">        http.</span><br><span class="line">                //将验证码过滤器放置在UsernamePasswordAuthenticationFilter过滤器之前执行，AOP思想</span><br><span class="line">                addFilterBefore(captchaCodeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .formLogin()//开启formLogin登录认证</span><br><span class="line">                .loginPage(&quot;/logins&quot;)    //用于选择登录页面，没认证时跳转的页面</span><br><span class="line">                .loginProcessingUrl(&quot;/login&quot;)   //选择需要认证的请求，也就是登录表单的提交地址</span><br><span class="line">                .usernameParameter(&quot;user&quot;)   //选择登录请求的哪个参数是用户名</span><br><span class="line">                .passwordParameter(&quot;password&quot;)   //选择登录请求的哪个参数是密码</span><br><span class="line">                //使用自定义的登录失败成功处理方法</span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  //登录成功</span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  //登录失败</span><br><span class="line"></span><br><span class="line">                //这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span><br><span class="line">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span><br><span class="line">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/logins&quot;,&quot;/login&quot;,&quot;/&quot;,&quot;/kaptcha&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                //______________________________动态图鉴权_____________________________________________</span><br><span class="line">                    //所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .maximumSessions(1)//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span><br><span class="line">                .maxSessionsPreventsLogin(false)//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span><br><span class="line">                .expiredSessionStrategy(new CustomExpiredSessionStrategy());  //session超时，被踢下线的自定义操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //________________ 动态授权，需要实现UserDetailsService____________________________</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="手机号验证码登录："><a href="#手机号验证码登录：" class="headerlink" title="手机号验证码登录："></a>手机号验证码登录：</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><img src="https://s2.loli.net/2022/03/21/7jINUlQWAoY1edS.png" alt="image-20220316233213777"></p>
<p><strong>使用到的常量：</strong>public static final String PHONE_SESSION_KEY &#x3D; “phoneCaptcha”;</p>
<p>这是我们实现短信验证码登录需要实现发：SMS 在我这用Phone代替</p>
<p>我们需要先创建一个为我们提供发送的验证码的Controller，这个很好理解吧，点击获取验证码，如何发送短信验证码至手机号短信</p>
<h3 id="controller："><a href="#controller：" class="headerlink" title="controller："></a>controller：</h3><p>创建验证码并发送给用户手机号，还有放入session以便登录验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">public class phoneController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    //创建手机验证码</span><br><span class="line">    @GetMapping(&quot;/smscode&quot;)</span><br><span class="line">    public JsonResult sms(String phone , HttpSession session)&#123;</span><br><span class="line"></span><br><span class="line">        //判断当前号码用户是否存在</span><br><span class="line">        try &#123;</span><br><span class="line">            UserDetails userDetails = myUserDetailsService.loadUserByUsername(phone);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            return new JsonResult().InputError(&quot;当前号码还未注册&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个验证码信息类，存放验证码（验证码使用随机生成），过期时间，电话号码，</span><br><span class="line">        int captcha = new Random().nextInt(9999);  //随机生成验证码</span><br><span class="line">        PhoneCaptchaVo phoneCaptchaVo = new PhoneCaptchaVo(String.valueOf(captcha),60,phone);</span><br><span class="line"></span><br><span class="line">        ///TODO 调用短信服务提供商的接口发送短信</span><br><span class="line">        log.info(phoneCaptchaVo.getCode()+&quot;  &gt;&gt; 验证码已发送至 &quot;  +phone );</span><br><span class="line"></span><br><span class="line">        session.setAttribute(&quot;phoneCaptcha&quot;,phoneCaptchaVo);</span><br><span class="line"></span><br><span class="line">        return new JsonResult().success(&quot;验证码已发送&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们可以看到有给PhoneCaptchaVo 其实就和图片验证码一样，需要的类封装我们的验证基本信息，再放入session</p>
<h3 id="PhoneCaptchaVo"><a href="#PhoneCaptchaVo" class="headerlink" title="PhoneCaptchaVo :"></a>PhoneCaptchaVo :</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PhoneCaptchaVo &#123;</span><br><span class="line"></span><br><span class="line">    private String captchaCode; //验证码谜底</span><br><span class="line">    private LocalDateTime expireTime;  //验证码过期时间</span><br><span class="line">    private String phone;  //电话号码</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于初始化</span><br><span class="line">     * @param captchaCode  谜底</span><br><span class="line">     * @param expireAfterSeconds  过期秒数</span><br><span class="line">     */</span><br><span class="line">    public PhoneCaptchaVo(String captchaCode,int expireAfterSeconds,String phone)&#123;</span><br><span class="line">        this.captchaCode=captchaCode;</span><br><span class="line">        //当前时间加上指定的秒数</span><br><span class="line">        this.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);</span><br><span class="line">        this.phone=phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断验证码是否过期</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean isExpired()&#123;</span><br><span class="line">        //判断当前时间是否大于过期时间，大于则失效</span><br><span class="line">        return LocalDateTime.now().isAfter(expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取captchaCode</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getCode()&#123;</span><br><span class="line">        return captchaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回电话号码</span><br><span class="line">    public String getPhone()&#123;</span><br><span class="line">        return phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这样我们的第一步就完成了，以创建并发送验证码，</p>
<h3 id="使用过滤器进行谜底验证："><a href="#使用过滤器进行谜底验证：" class="headerlink" title="使用过滤器进行谜底验证："></a>使用过滤器进行谜底验证：</h3><p>当我们登录时我们需要进行登录信息的确认，还有谜底对比</p>
<p>这样我们就完成了基本的验证，但这样我们是无法使用的，因为的短信登录请求&#x2F;PhoneLogin是无法向&#x2F;login一样被识别的</p>
<p>我们还需要创建PhoneAuthenticationFilter ，就像UsernamePasswordAuthenticationFilter一样，如果给login请求就进行登录的一系列操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 短信验证码登录验证的过滤器，与我们图片验证码的过滤器可以说是一模一样</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class PhoneCodeValidateFilter  extends OncePerRequestFilter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 这是我们自定义登录失败的处理方式</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain filterChain)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //判断当前请求是否是向/login发送请求，并且是以post请求提交的</span><br><span class="line">        if (&quot;/PhoneLogin&quot;.equals(request.getRequestURI())</span><br><span class="line">                &amp;&amp; &quot;post&quot;.equalsIgnoreCase(request.getMethod()))&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //验证码校验操作</span><br><span class="line">                captchaVerify(request);</span><br><span class="line">            &#125;catch (AuthenticationException e)&#123;</span><br><span class="line">                //SessionAuthenticationException这个异常是继承了AuthenticationException的</span><br><span class="line">                //我们自定义异常时同样也需继承AuthenticationException</span><br><span class="line">                //我们将错误处理交给登录实现处理类进行操作</span><br><span class="line">                myAuthenticationFailureHandler.onAuthenticationFailure(request,response,e);</span><br><span class="line">                //由于这里已经是发生了异常的，我们就不能让程序再进行往下走了</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果验证成功后不是登录操作就进行放行</span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证码验证操作</span><br><span class="line">     * 里面的异常是可以自定义的，不一定就要用系统提供的</span><br><span class="line">     */</span><br><span class="line">    private void captchaVerify(HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">        //获取session，session中有用户的谜底与验证码过期时间</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">        //获取用户输入的验证码</span><br><span class="line">            String phone = request.getParameter(&quot;phone&quot;); //输入的手机号码</span><br><span class="line">            String phoneCode = request.getParameter(&quot;phoneCode&quot;); //输入的验证码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //判断用户输入的手机号是否为空</span><br><span class="line">        if (phone.trim().isEmpty())&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;手机号不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否为空</span><br><span class="line">        if (phoneCode.trim().isEmpty())&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取我们存入session中的CaptchaImageVo，也就是谜底与过期时间类</span><br><span class="line">        PhoneCaptchaVo phoneCaptchaVo = (PhoneCaptchaVo) session.getAttribute(CaptchaConstant.PHONE_SESSION_KEY);</span><br><span class="line"></span><br><span class="line">        //判断session中使用有谜底</span><br><span class="line">        if (Objects.isNull(phoneCaptchaVo))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断验证码是否过期</span><br><span class="line">        if (phoneCaptchaVo.isExpired())&#123;</span><br><span class="line">            //移出以前的CaptchaImageVo</span><br><span class="line">            session.removeAttribute(CaptchaConstant.PHONE_SESSION_KEY);</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否与谜底一致</span><br><span class="line">        if (!phoneCode.trim().equalsIgnoreCase(phoneCaptchaVo.getCode()))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否与谜底一致</span><br><span class="line">        if (!phone.trim().equalsIgnoreCase(phoneCaptchaVo.getPhone()))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;手机号不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //验证完后删除验证码，不管成功还是失败</span><br><span class="line">        session.removeAttribute(CaptchaConstant.PHONE_SESSION_KEY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="短信鉴定登录过滤器："><a href="#短信鉴定登录过滤器：" class="headerlink" title="短信鉴定登录过滤器："></a>短信鉴定登录过滤器：</h3><p><img src="https://s2.loli.net/2022/03/21/XhP7JmLgucOi5sI.png" alt="image-20220316234227700"></p>
<p>如果所示，我们需要自定义我们的短信登录日志过滤器，当我们短信登录进来时绕过用户名密码登录过滤器。而是走我们自定义的过滤器</p>
<h4 id="实现图中第一个步骤"><a href="#实现图中第一个步骤" class="headerlink" title="实现图中第一个步骤:"></a>实现图中第一个步骤:</h4><p>创建自定义鉴定过滤器</p>
<h5 id="PhoneAuthenticationFilter："><a href="#PhoneAuthenticationFilter：" class="headerlink" title="PhoneAuthenticationFilter："></a>PhoneAuthenticationFilter：</h5><p>这个类就是图中的SmsCodeAuthenticationFilter</p>
<p>这个我们可以模仿UsernamePasswordAuthenticationFilter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由于我们需要为手机号登录，</span><br><span class="line"> * 我们可以仿照UsernamePasswordAuthenticationFilter用户名密码登录创建一个手机号登录过滤器交给Security</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class PhoneAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;</span><br><span class="line"></span><br><span class="line">    public static final String SPRING_SECURITY_FORM_PHONE_KEY = &quot;phone&quot;;</span><br><span class="line">    private static final AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = new AntPathRequestMatcher(&quot;/PhoneLogin&quot;, &quot;POST&quot;);</span><br><span class="line">    private String phoneParameter = &quot;phone&quot;;</span><br><span class="line">    private boolean postOnly = true;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationFilter() &#123;</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationFilter(AuthenticationManager authenticationManager) &#123;</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER, authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;</span><br><span class="line">        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;</span><br><span class="line">            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String phone = this.obtainPhone(request);</span><br><span class="line">            phone = phone != null ? phone : &quot;&quot;;</span><br><span class="line"></span><br><span class="line">            //我们需要自己创建一个PhoneAuthenticationToken，可以模仿UserNameAuthenticationToken</span><br><span class="line">            PhoneAuthenticationToken authRequest = new PhoneAuthenticationToken(phone);</span><br><span class="line">            this.setDetails(request, authRequest);</span><br><span class="line">            return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected String obtainPhone(HttpServletRequest request) &#123;</span><br><span class="line">        return request.getParameter(this.phoneParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void setDetails(HttpServletRequest request, PhoneAuthenticationToken authRequest) &#123;</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPhoneParameter(String usernameParameter) &#123;</span><br><span class="line">        Assert.hasText(usernameParameter, &quot;Phone parameter must not be empty or null&quot;);</span><br><span class="line">        this.phoneParameter = usernameParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPostOnly(boolean postOnly) &#123;</span><br><span class="line">        this.postOnly = postOnly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String getUsernameParameter() &#123;</span><br><span class="line">        return this.phoneParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>再改写这个PhoneAuthenticationFilter类时我们发现UsernamePasswordAuthenticationToken令牌不是我们需要的，所以我们同样要改写，去自定义一个</p>
<p><strong>解下UsernamePasswordAuthenticationToken：</strong></p>
<p>通过类名可以的看出来，用户名密码方式进行认证。就是我们见的最多的认证方式通过用户名密码进行登录。咱们话不多说看看具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line">    <span class="comment">// 序列化id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">530L</span>;</span><br><span class="line">    <span class="comment">// 一般指的是用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">    <span class="comment">// 一般指的是密码</span></span><br><span class="line">    <span class="keyword">private</span> Object credentials;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// principal  一般指的是用户名</span></span><br><span class="line">    <span class="comment">// credentials  一般指的是密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化父类构造 权限集合为空</span></span><br><span class="line">        <span class="built_in">super</span>((Collection)<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="comment">// 设置是否已认证 默认为false</span></span><br><span class="line">        <span class="built_in">this</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">     <span class="comment">// principal  一般指的是用户名</span></span><br><span class="line">    <span class="comment">// credentials  一般指的是密码</span></span><br><span class="line">    <span class="comment">// authorities 权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">       <span class="comment">// // 初始化父类构造 权限集合</span></span><br><span class="line">        <span class="built_in">super</span>(authorities);</span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="comment">// 设置父类方法表示已经认证</span></span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取密码</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取用户名</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置是否已认证 默认为false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="comment">// 如果为true</span></span><br><span class="line">        <span class="comment">// 抛出非法参数异常</span></span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 设置父类是否已认证</span></span><br><span class="line">            <span class="built_in">super</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 擦除凭证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eraseCredentials</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.eraseCredentials();</span><br><span class="line">        <span class="comment">// 将密码设置为空</span></span><br><span class="line">        <span class="built_in">this</span>.credentials = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="PhoneAuthenticationToken："><a href="#PhoneAuthenticationToken：" class="headerlink" title="PhoneAuthenticationToken："></a>PhoneAuthenticationToken：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PhoneAuthenticationToken  extends AbstractAuthenticationToken &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 560L;</span><br><span class="line">    //存放认证信息，认证之前放的是手机号码，认证之后存放UserDetails</span><br><span class="line">    private final Object principal;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationToken(Object principal) &#123;</span><br><span class="line">        super((Collection)null);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        this.setAuthenticated(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationToken(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123;</span><br><span class="line">        super(authorities);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        super.setAuthenticated(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //由于我们手机号登录不需要密码，这个是获取密码的，我们没有密码就返回null，</span><br><span class="line">    //接口中要求实现</span><br><span class="line">    public Object getCredentials() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getPrincipal() &#123;</span><br><span class="line">        return this.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123;</span><br><span class="line">        Assert.isTrue(!isAuthenticated, &quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;);</span><br><span class="line">        super.setAuthenticated(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eraseCredentials() &#123;</span><br><span class="line">        super.eraseCredentials();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="然后再实现图中第二个步骤："><a href="#然后再实现图中第二个步骤：" class="headerlink" title="然后再实现图中第二个步骤："></a>然后再实现图中第二个步骤：</h4><h5 id="实现鉴定提供者"><a href="#实现鉴定提供者" class="headerlink" title="实现鉴定提供者"></a>实现鉴定提供者</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *创建一个电话号码的鉴定提供者，</span><br><span class="line"> */</span><br><span class="line">public class PhoneAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line">//这个其实我认为是多余的可以去掉，因为这个我们再使用过滤器进行谜底验证时就已经验证过电话号码的正确性</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    public void setUserDetailsService(UserDetailsService userDetailsService)&#123;</span><br><span class="line">        this.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected  UserDetailsService getUserDetailsService()&#123;</span><br><span class="line">        return userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 具体认证流程</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        //获取存放的Token</span><br><span class="line">        PhoneAuthenticationToken phoneAuthenticationToken = (PhoneAuthenticationToken) authentication;</span><br><span class="line">        //phoneAuthenticationToken中的Principal，初始存储的电话号码</span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername((String) phoneAuthenticationToken.getPrincipal());</span><br><span class="line"></span><br><span class="line">        //判断使用当前号码是否能获取到用户信息，一般都不会出问题，以为我们在获取验证码时就验证了</span><br><span class="line">        // 也就是PhoneCodeValidateFilter过滤器中验证码了</span><br><span class="line">        if (userDetails == null)&#123;</span><br><span class="line">            throw new InternalAuthenticationServiceException(&quot;无法根据手机号获取用户信息&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //我们在这创建一个Token这次他的Principal就变成了userDetails,</span><br><span class="line">        PhoneAuthenticationToken authenticationToken = new PhoneAuthenticationToken(userDetails,userDetails.getAuthorities());</span><br><span class="line">        //由于我们直接创建的details是没有值的，所以我们要将原来的details赋为我们的details</span><br><span class="line">        authenticationToken.setDetails(phoneAuthenticationToken.getDetails());</span><br><span class="line">        return authenticationToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *    supports函数用来指明该Provider是否适用于该类型的认证，如果不合适，则寻找另一个Provider进行验证处理。</span><br><span class="line">     *    就好比，判断当前Provider是否适用于电话号码的认证，不适合，则寻找另一个Provider进行验证处理。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">        //判断当前Provider是否适用于authentication认证</span><br><span class="line">        return PhoneAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>把这个都完成后，再把他们配置到Security配置类中，但是，这个如果配置的话会显得很多，所以我们可以先创建一个电话号码验证单独的配置类，然后再将它放入到核心Security配置类中，</p>
<h5 id="单独配置类"><a href="#单独配置类" class="headerlink" title="单独配置类"></a>单独配置类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由于要配置电话号码登录配置的话，需要配置很多，</span><br><span class="line"> * 所以我们交配置整合好后在去Security配置类中配置</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class PhoneSecurityConfig extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    //登录信息校验过滤器，也就是过滤登录信息是否正常</span><br><span class="line">    @Autowired</span><br><span class="line">    private PhoneCodeValidateFilter phoneCodeValidateFilter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        //创建一个电话号码登录过滤器，也就是如UsernamePasswordAuthenticationFilter一样的</span><br><span class="line">        PhoneAuthenticationFilter phoneAuthenticationFilter = new PhoneAuthenticationFilter();</span><br><span class="line"></span><br><span class="line">        phoneAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));</span><br><span class="line">        phoneAuthenticationFilter.setAuthenticationSuccessHandler(myAuthenticationSuccessHandler);//登录成功处理方式</span><br><span class="line">        phoneAuthenticationFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler);//登录失败处理方式</span><br><span class="line"></span><br><span class="line">        //创建一个我们自定义鉴定提供者，他会自己去匹配当前信息能使用鉴定提供者</span><br><span class="line">        PhoneAuthenticationProvider phoneAuthenticationProvider = new PhoneAuthenticationProvider();</span><br><span class="line">        //其实这个都可以不用，如果不要也就删除PhoneAuthenticationProvider中他对应的操作</span><br><span class="line">        phoneAuthenticationProvider.setUserDetailsService(myUserDetailsService);</span><br><span class="line"></span><br><span class="line">        http.addFilterBefore(phoneCodeValidateFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http.authenticationProvider(phoneAuthenticationProvider)</span><br><span class="line">                .addFilterAfter(phoneAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Securty配置类："><a href="#Securty配置类：" class="headerlink" title="Securty配置类："></a>Securty配置类：</h5><p>在配置类中加入.apply(phoneSecurityConfig)&#x2F;&#x2F;添加我们的手机号码登录配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将我们自定义的这两个类使用IOC容器装配</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  //登录成功处理</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;  //登录失败处理</span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    //验证码过滤器</span><br><span class="line">    @Autowired</span><br><span class="line">    private CaptchaCodeFilter captchaCodeFilter;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PhoneSecurityConfig phoneSecurityConfig;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //开启formLogin登录认证</span><br><span class="line">        http</span><br><span class="line">                //将验证码过滤器放置在UsernamePasswordAuthenticationFilter过滤器之前执行，AOP思想</span><br><span class="line">                .addFilterBefore(captchaCodeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .formLogin()//开启formLogin登录认证</span><br><span class="line">                .loginPage(&quot;/logins&quot;)    //用于选择登录页面，没认证时跳转的页面</span><br><span class="line">                .loginProcessingUrl(&quot;/login&quot;)   //选择需要认证的请求，也就是登录表单的提交地址</span><br><span class="line">                .usernameParameter(&quot;user&quot;)   //选择登录请求的哪个参数是用户名</span><br><span class="line">                .passwordParameter(&quot;password&quot;)   //选择登录请求的哪个参数是密码</span><br><span class="line">                //使用自定义的登录失败成功处理方法</span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  //登录成功</span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  //登录失败</span><br><span class="line"></span><br><span class="line">                //这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span><br><span class="line">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span><br><span class="line">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span><br><span class="line">             .and()</span><br><span class="line">                .apply(phoneSecurityConfig)//添加我们的手机号码登录配置类</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/logins&quot;,&quot;/login&quot;,&quot;/&quot;,&quot;/kaptcha&quot;,&quot;/smscode&quot;,&quot;/PhoneLogin&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //______________________________动态图鉴权_____________________________________________</span><br><span class="line">                    //所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问，</span><br><span class="line">                    // 也就是验证用户能访问哪些页面</span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .maximumSessions(1)//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span><br><span class="line">                .maxSessionsPreventsLogin(false)//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span><br><span class="line">                .expiredSessionStrategy(new CustomExpiredSessionStrategy());  //session超时，被踢下线的自定义操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //________________ 动态授权，需要实现UserDetailsService____________________________</span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><img src="https://s2.loli.net/2022/03/21/4zJVputoWcDh5P3.png" alt="image-20220317000050986"></p>
<h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    账号：&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;user&quot;&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;</span><br><span class="line">    验证码:&lt;input type=&quot;text&quot; id=&quot;captchaCoed&quot; name=&quot;captchaCoed&quot;&gt;&lt;img src=&quot;/kaptcha&quot; id=&quot;kaptcha&quot; width=&quot;110px&quot; height=&quot;40px&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;login()&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">     记住我&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; id=&quot;remember-me&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;手机验证码&lt;/h1&gt;</span><br><span class="line">&lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    手机号：&lt;input type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot;&gt;&lt;br&gt;</span><br><span class="line">    验证码:&lt;input type=&quot;text&quot; id=&quot;phoneCode&quot; name=&quot;phoneCode&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;submitPhone&quot;  onclick=&quot;getPhone()&quot; value=&quot;获取验证码&quot;  &gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;PhoneLogin()&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        //用于点击刷新验证码图片</span><br><span class="line">        $(&quot;#kaptcha&quot;).click(function () &#123;</span><br><span class="line">            $(&quot;#kaptcha&quot;).attr(&quot;src&quot;,&quot;/kaptcha?&quot;+Math.floor(Math.random()*100))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    function login() &#123;</span><br><span class="line">        let username=$(&quot;#username&quot;).val();</span><br><span class="line">        let password=$(&quot;#password&quot;).val();</span><br><span class="line">        let remember=$(&quot;#remember-me&quot;).prop(&quot;checked&quot;);</span><br><span class="line">        let captchaCoed=$(&quot;#captchaCoed&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            url: &quot;/login&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                &quot;user&quot;: username,</span><br><span class="line">                &quot;password&quot;: password,</span><br><span class="line">                &quot;remember-me&quot;:remember,</span><br><span class="line">                &quot;captchaCoed&quot;:captchaCoed</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (json) &#123;</span><br><span class="line">              if (json.state == 200)&#123;</span><br><span class="line">                  console.log(json)</span><br><span class="line">                  location.href=&quot;/&quot;;</span><br><span class="line">              &#125;else &#123;</span><br><span class="line">                  alert(json.message)</span><br><span class="line">                  console.log(json)</span><br><span class="line">                  location.href=&quot;/logins&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function getPhone() &#123;</span><br><span class="line">        let phone = $(&quot;#phone&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;GET&quot;,</span><br><span class="line">            url: &quot;/smscode&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                &quot;phone&quot;: phone,</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (json) &#123;</span><br><span class="line">                if (json.state == 200) &#123;</span><br><span class="line">                    console.log(json)</span><br><span class="line">                    alert(&quot;验证码已发送&quot;)</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    alert(json.message)</span><br><span class="line">                    console.log(json)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    function PhoneLogin() &#123;</span><br><span class="line">        let phone = $(&quot;#phone&quot;).val();</span><br><span class="line">        let phoneCode = $(&quot;#phoneCode&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            url: &quot;/PhoneLogin&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                &quot;phone&quot;: phone,</span><br><span class="line">                &quot;phoneCode&quot;:phoneCode</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (json) &#123;</span><br><span class="line">                if (json.state == 200) &#123;</span><br><span class="line">                    console.log(json)</span><br><span class="line">                    location.href=&quot;/&quot;;</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    alert(json.message)</span><br><span class="line">                    console.log(json)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>





<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="jwt介绍："><a href="#jwt介绍：" class="headerlink" title="jwt介绍："></a>jwt介绍：</h3><p><img src="https://s2.loli.net/2022/03/21/kKPDMLRAVIpHrvX.png" alt="image-20220317231621407"></p>
<p><img src="https://s2.loli.net/2022/03/21/W1stHFYOvjKd6Uk.png" alt="image-20220317231629433"></p>
<p><img src="https://s2.loli.net/2022/03/21/P2Ik1z493SyCuFO.png" alt="image-20220317231635981"></p>
<p><img src="https://s2.loli.net/2022/03/21/X3od2kYmL4vnl7B.png" alt="image-20220317231642172"></p>
<h3 id="创建JWT工具类："><a href="#创建JWT工具类：" class="headerlink" title="创建JWT工具类："></a>创建JWT工具类：</h3><p>我需要先创建一jwt工具类，这样可以在我们需要给地方使用更方便</p>
<p>注意：获取用户名之类的方法都会去判断jwt令牌是否过期，过期后是获取不到用户名的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JWT的工具类</span><br><span class="line"> * 三个属性需要在配置文件中定义</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(prefix = &quot;jwt&quot;) //设置application中配置的开头节点</span><br><span class="line">@Component</span><br><span class="line">public class JwtTokenUtil &#123;</span><br><span class="line"></span><br><span class="line">//  这三个属性需要在application配置文件中定义</span><br><span class="line">    //JWT的密钥</span><br><span class="line">    @Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">    private String secret;</span><br><span class="line">    //JWT的过期时间</span><br><span class="line">    @Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span><br><span class="line">    private Long expiration;</span><br><span class="line">    //在http对象头中携带jwt的key的名称</span><br><span class="line">    @Value(&quot;$&#123;jwt.header&#125;&quot;)</span><br><span class="line">    private String header;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成JWT token令牌</span><br><span class="line">     *</span><br><span class="line">     * @param userDetails 用户信息</span><br><span class="line">     * @return JWT token令牌</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(UserDetails userDetails)&#123;</span><br><span class="line">        //存放用户不敏感信息，等要放入jwt令牌中</span><br><span class="line">        Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;(2);</span><br><span class="line">        claims.put(&quot;sub&quot;,userDetails.getUsername()); //将用户名放入claims</span><br><span class="line">        claims.put(&quot;created&quot;,new Date()); //将令牌创建时间放入claims</span><br><span class="line"></span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从claims中获取用户不敏感信息生成令牌</span><br><span class="line">     *</span><br><span class="line">     * @param claims 用户不敏感信息</span><br><span class="line">     * @return 令牌</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(Map&lt;String,Object&gt; claims)&#123;</span><br><span class="line">           Date expirationDate = new Date(System.currentTimeMillis() + expiration); //获取当前数据，加上过期是长，生成过期时间</span><br><span class="line">        //返回生成的jwt令牌</span><br><span class="line">        return Jwts.builder()//</span><br><span class="line">                .setClaims(claims)  //加入用户名，与用户创建时间</span><br><span class="line">                .setExpiration(System.currentTimeMillis()+expirationDate*1000)//令牌过期时间</span><br><span class="line">                //进行jwt令牌的签约 参数1：设置使用声明方式签名（加密方式）,参数2：使用的密钥（等解签也需要这个密钥）</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512,secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从令牌中获取用户名</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return 该令牌用户名</span><br><span class="line">     */</span><br><span class="line">    public String getUsernameFromToken(String token)&#123;</span><br><span class="line">        String username;</span><br><span class="line">        try &#123;</span><br><span class="line">            //Claims jwt信息类（数据声明），获取jwt信息类</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject(); //在jwt信息类中获取用户名，这个方法是获取用户名的</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            username = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从令牌中获取jwt令牌信息</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return jwt令牌信息类（数据声明）</span><br><span class="line">     */</span><br><span class="line">    public Claims getClaimsFromToken(String token)&#123;</span><br><span class="line">        //jwt令牌信息类</span><br><span class="line">        Claims claims;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将jwt进行解析，获取jwt信息类</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)//解签的密钥</span><br><span class="line">                    .parseClaimsJws(token)//解签的令牌</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            claims = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断令牌是否过期</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return 是否过期</span><br><span class="line">     */</span><br><span class="line">    public Boolean isTokenExpired(String token)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            //获取jwt令牌过期时间，过期使用使用这个方法获取</span><br><span class="line">            Date expiration = claims.getExpiration();</span><br><span class="line">            //判断当前时间是否在过期时间之前，也就是判断是否过期</span><br><span class="line">            return expiration.before(new Date());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新令牌（令牌过期就表示登录过期，为了保证用户体验，在用户使用中要刷新令牌）</span><br><span class="line">     * @param token 原令牌</span><br><span class="line">     * @return 新令牌</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String token)&#123;</span><br><span class="line">        String refreshToken;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取jwt信息类</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            //修改jwt中的新的创建时间</span><br><span class="line">            claims.put(&quot;created&quot;,new Date());</span><br><span class="line">            //生成一个新的令牌，更新它的过期时间</span><br><span class="line">            refreshToken = generateToken(claims);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            refreshToken = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证令牌</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @param userDetails 用户详细信息</span><br><span class="line">     * @return 是否有效</span><br><span class="line">     */</span><br><span class="line">    public Boolean validateToken(String token,UserDetails userDetails)&#123;</span><br><span class="line">        //获取用户名</span><br><span class="line">        String username = getUsernameFromToken(token);</span><br><span class="line">        //判断当前jwt令牌用户名是否与登录用户的用户名相同，并且jwt令牌是否过期</span><br><span class="line">        return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>yml配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jwt:</span><br><span class="line">  secret: ahjkvhajkhkss2ajdfaj #密钥，签名（加密），解签（解密）都需要该密钥</span><br><span class="line">  expiration: 3600000  #过期时长 </span><br><span class="line">  header: JWTHeaderName  #jwt在http头部信息中的key</span><br></pre></td></tr></table></figure>



<h3 id="JWT实现登录："><a href="#JWT实现登录：" class="headerlink" title="JWT实现登录："></a>JWT实现登录：</h3><p>我们需要配置Controller实现请求，与Service业务层</p>
<p>这些做完我们就可以获取基本的jwt令牌了</p>
<h4 id="Controller："><a href="#Controller：" class="headerlink" title="Controller："></a>Controller：</h4><p>两个请求，一个获取令牌：也就是登录我们需要创建一个jwt令牌返回给客户端，一个刷新：刷新我们的jwt令牌返回回去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class JwtAuthController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtAuthService jwtAuthService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建jwt令牌</span><br><span class="line">     * 记得在SecurityConfig中开放访问权限</span><br><span class="line">     * @param map</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/authentication&quot;)</span><br><span class="line">    public JsonResult login(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line"></span><br><span class="line">        //获取用户名和密码</span><br><span class="line">        String username = map.get(&quot;username&quot;);</span><br><span class="line">        String password = map.get(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        //判断用户名与密码是否为空</span><br><span class="line">        if (username.isEmpty() || password.isEmpty())&#123;</span><br><span class="line">            return  new JsonResult().InputError(&quot;用户名或密码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //返回获取到的jwt令牌</span><br><span class="line">            return new JsonResult().success(jwtAuthService.login(username,password));</span><br><span class="line">        &#125;catch (UsernameNotFoundException e)&#123;</span><br><span class="line">            //如果没有获取到jwt令牌，返回错误信息</span><br><span class="line">            return new JsonResult().InputError(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新jwt令牌</span><br><span class="line">     * @param token  获取http对象头中的jwt令牌，我们以及设置jwt令牌的key为jwt.header</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/refreshToken&quot;)</span><br><span class="line">    public JsonResult refresh(@RequestHeader(&quot;$&#123;jwt.header&#125;&quot;) String token)&#123;</span><br><span class="line">        return new JsonResult().success(jwtAuthService.refreshToken(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Service："><a href="#Service：" class="headerlink" title="Service："></a>Service：</h4><p>业务操作，实际上还是业务层实现真实的操作，访问层只是做一些校验</p>
<p>注意：AuthenticationManager  这个bean在Security配置类中配置了，可以去看看，下面有完整的Security配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class JwtAuthService &#123;</span><br><span class="line"></span><br><span class="line">    //鉴定管理员 </span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证换取JWT令牌</span><br><span class="line">     * @param username</span><br><span class="line">     * @param password</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String login(String username,String password)&#123;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //创建一个用户名密码鉴定令牌</span><br><span class="line">            UsernamePasswordAuthenticationToken authenticationToken = new 				UsernamePasswordAuthenticationToken(username,password);</span><br><span class="line">            //进行认证，如果认证成功返回一个认证信息，如果没有成功就会抛出AuthenticationException异常</span><br><span class="line">            //这个方法中会去数据库中查询认证信息，具体还得网查询</span><br><span class="line">            Authentication authenticate = authenticationManager.authenticate(authenticationToken);</span><br><span class="line">            //将认证信息给Security</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;catch (AuthenticationException e)&#123;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户名或密码不正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //进行用户查询</span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">        //创建jwt令牌并返回</span><br><span class="line">        return jwtTokenUtil.generateToken(userDetails);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新jwt令牌</span><br><span class="line">     * @param oldToken 旧令牌</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String oldToken)&#123;</span><br><span class="line">        //判断当前令牌是否过期</span><br><span class="line">        if (!jwtTokenUtil.isTokenExpired(oldToken))&#123;</span><br><span class="line">            return jwtTokenUtil.refreshToken(oldToken);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，要把当前两个请求路径开放，并将session关闭</strong></p>
<h4 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h4><p>获取到的令牌是可以使用Base64解码的，但密钥是解码不了的</p>
<p><strong>获取令牌：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/kWeJDHTntcVMBfh.png" alt="image-20220320190553251"></p>
<p><strong>刷新令牌：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/etnRIfD1aZVPjTy.png" alt="image-20220320190242450"></p>
<p><strong>解码演示</strong>：</p>
<p>这个图就和介绍中jwt结构分析一样</p>
<p><img src="https://s2.loli.net/2022/03/21/lbj2MnBNmJ87Qoc.png" alt="image-20220320190758729"></p>
<h3 id="jwt用户授权"><a href="#jwt用户授权" class="headerlink" title="jwt用户授权"></a>jwt用户授权</h3><p>我们单纯的只有jwt令牌也没有用，我们需要为当前用户进行授权，那么我们就需要自己去创建一个过滤器放置在UsernamePasswordAuthenticationFilter之前进行授权</p>
<p>介绍下， UsernamePasswordAuthenticationToken authenticationToken<br>        &#x3D; new UsernamePasswordAuthenticationToken(userDetails,null,userDetails.getAuthorities());</p>
<p>这是个特殊的令牌，这个令牌是Security是可以获取到用户认证信息的，而这个令牌里的认证信息是我们放入的，然后将认证信息交给</p>
<p>SecurityContextHolder.getContext().setAuthentication(authenticationToken); </p>
<p>这个方法是将我们有角色认证信息的令牌交给Security这样就完成了角色的认证，就可以判断用户拥有哪些权限了，但每次访问时都会去重写查询（下面代码里可以看到）所以我们可以使用缓存将它存起来，这样就可以提高效率</p>
<h4 id="jwt身份授权鉴权过滤器"><a href="#jwt身份授权鉴权过滤器" class="headerlink" title="jwt身份授权鉴权过滤器"></a><strong>jwt身份授权鉴权过滤器</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加jwt过滤器，用于身份授权鉴权</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //获取http头部信息中的jwtToken</span><br><span class="line">        String jwtToken = request.getHeader(jwtTokenUtil.getHeader());</span><br><span class="line">        //判断是否有jwtToken</span><br><span class="line">        if (!StringUtils.isEmpty(jwtToken))&#123;</span><br><span class="line">            //获取jwt中的用户名,这里已经是判断jwt令牌的有效性，如果无效就获取不到username</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(jwtToken);</span><br><span class="line"></span><br><span class="line">            //判断jwtToken中用户名不为空并且Security中还没有认证信息</span><br><span class="line">            if (!username.isEmpty()</span><br><span class="line">                    &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null)&#123;</span><br><span class="line">                UserDetails userDetails = myUserDetailsService.loadUserByUsername(username);</span><br><span class="line">                //验证令牌正确性，</span><br><span class="line">                if (jwtTokenUtil.validateToken(jwtToken,userDetails))&#123;</span><br><span class="line">                    // 将jwt令牌转换为Security认识的令牌 参数1：用户信息 参数2：密码 参数3：用户的权限信息</span><br><span class="line">                    UsernamePasswordAuthenticationToken authenticationToken</span><br><span class="line">                            = new UsernamePasswordAuthenticationToken(userDetails,null,userDetails.getAuthorities());</span><br><span class="line">                    //把认证权限信息交给Security，如当UsernamePasswordAuthenticationFilter拦截时，发现已经认证过了就不会再次认证</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用aop的思想将它放在UsernamePasswordAuthenticationFilter之前，所以我们需要去配置</p>
<h4 id="Security配置类-1"><a href="#Security配置类-1" class="headerlink" title="Security配置类"></a>Security配置类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        http    //将jwtAuthenticationTokenFilter放置在UsernamePasswordAuthenticationFilter之前</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //令牌仓库默认是在内存中,我们指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/login&quot;,&quot;/authentication&quot;,&quot;/refreshToken&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);//不使用session，关闭session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception&#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于我们要使用到别的页面查询是否成功授权鉴权，我们需要一个额外的请求资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line"></span><br><span class="line">        return &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意我们数据库中记得给当前角色这个资源路径的访问资格</p>
<p><strong>现在开始测试：</strong></p>
<p><strong>这是有权限清空访问</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/vzRBIdb9X6WGD5m.png" alt="image-20220320193906937"></p>
<p><img src="https://s2.loli.net/2022/03/21/mjcJ6BY5k3OQ2Rn.png" alt="image-20220320193505218"></p>
<p><strong>无权限清空下访问：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/RBq4fEZdC6J9FIl.png" alt="image-20220320193746967"></p>
<p><img src="https://s2.loli.net/2022/03/21/uVZkJzhapcOG6rF.png" alt="image-20220320193640084"></p>
<h2 id="跨域访问："><a href="#跨域访问：" class="headerlink" title="跨域访问："></a>跨域访问：</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>为什么要跨域访问？跨域访问是什么？</p>
<p>跨域访问也就是A网站直接去访问B网站资源路径，这样的行为是不允许的</p>
<p><strong>如图：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/4arOfdijuIq8bQv.png" alt="image-20220321151443656"></p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法：</strong></h3><p><img src="https://s2.loli.net/2022/03/21/XlDL1EcG8rdZ5eb.png" alt="image-20220321152423979"></p>
<h4 id="其他解决方法："><a href="#其他解决方法：" class="headerlink" title="其他解决方法："></a>其他解决方法：</h4><p><img src="https://s2.loli.net/2022/03/21/KRpjq6LcIYf8ZGB.png" alt="image-20220321151622759"></p>
<p><img src="https://s2.loli.net/2022/03/21/aQwmgfGkiMPAVl7.png" alt="image-20220321151629992"></p>
<p><img src="https://s2.loli.net/2022/03/21/fWt3wZsPr1Tupka.png" alt="image-20220321151636299"></p>
<h4 id="SpringBoot解决方法："><a href="#SpringBoot解决方法：" class="headerlink" title="SpringBoot解决方法："></a>SpringBoot解决方法：</h4><p><img src="https://s2.loli.net/2022/03/21/Bnjf38uIDyarETp.png" alt="image-20220321151734457"></p>
<p><img src="https://s2.loli.net/2022/03/21/i6q8xQsg7tDBlIm.png" alt="image-20220321151753953"></p>
<p><img src="https://s2.loli.net/2022/03/21/hMqaYJnE4xoyX7Q.png" alt="image-20220321151800818"></p>
<p><img src="https://s2.loli.net/2022/03/21/GtvJUDmACzo1lrn.png" alt="image-20220321151806595"></p>
<h4 id="SpringBoot-Security解决方法："><a href="#SpringBoot-Security解决方法：" class="headerlink" title="SpringBoot-Security解决方法："></a>SpringBoot-Security解决方法：</h4><p>以上四种其实都可以使用在Security中解决，但是Security有它推荐的方法</p>
<p><strong>其实很简单：</strong></p>
<p>A网站中配置跨域访问权限：http .cors()&#x2F;&#x2F;开启跨域访问</p>
<p>实现bean：</p>
<p>​	注意是这个包下的import org.springframework.web.cors.CorsConfigurationSource;</p>
<pre><code>/**
 * 配置跨域请求CORS源
 * @return
 */
@Bean
public CorsConfigurationSource corsConfigurationSource()&#123;
    CorsConfiguration corsConfiguration = new CorsConfiguration();
    //允许哪些域访问
    corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://loaclhost:8080&quot;));
    //访问方式
    corsConfiguration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));
    //设置默认参数
    corsConfiguration.applyPermitDefaultValues();

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    //允许跨域访问哪些资源
    source.registerCorsConfiguration(&quot;/**&quot;,corsConfiguration);
    return source;
&#125;
</code></pre>
<p><strong>配置实例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        http .cors()//开启跨域访问</span><br><span class="line">                .and()</span><br><span class="line">                //将jwtAuthenticationTokenFilter放置在UsernamePasswordAuthenticationFilter之前</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //令牌仓库默认是在内存中,我们指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/login&quot;,&quot;/authentication&quot;,&quot;/refreshToken&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);//不使用session，关闭session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 识别jwt令牌需要的</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception&#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置跨域请求CORS源</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsConfigurationSource corsConfigurationSource()&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        //允许哪些域访问  一定要注意最后以/结尾 不让B网站访问就没有用</span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://loaclhost:8080/&quot;));</span><br><span class="line">        //访问方式</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));</span><br><span class="line">        //设置默认参数</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        //允许跨域访问哪些资源</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;,corsConfiguration);</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>这里是使用的Security推荐解决方法</p>
<p><strong>B网站向A网站跨域访问前端代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &quot;POST&quot;,</span><br><span class="line">    url: &quot;http://localhost:8081/hello&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &#x27;JWTHeaderName&#x27;:&#x27;eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NDc4NTMzNTEsInN1YiI6InVzZXIiLCJjcmVhdGVkIjoxNjQ3ODQ5NzUxODY3fQ.5EC4IhutkrR0er-TkLLHSLXaAZQ1gR48tTi3YOyjJzV-eE9Y0wziMoCRfUb0I4S9eeOr4mG3JloT7HQUTlwF_w&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function (json) &#123;</span><br><span class="line">        alert(&quot;跨域请求配置成功&quot;+json);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (e) &#123;</span><br><span class="line">        alert(&quot;跨域请求配置失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>A网站未配置B网站跨域访问权限下访问结果：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/TD8ZIjuQ7gvC94s.png" alt="image-20220321161337254"></p>
<p><strong>A网站配置B网站跨域访问权限下访问结果：</strong></p>
<p>​	配置了后就没有那个提示了</p>
<p><img src="https://s2.loli.net/2022/03/21/B15f4qExDU2nNFo.png" alt="image-20220321161205428"></p>
<h2 id="开启CSRF防御："><a href="#开启CSRF防御：" class="headerlink" title="开启CSRF防御："></a>开启CSRF防御：</h2><h3 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h3><p>什么是CSRF防御，那我们先得了解下CSRF攻击</p>
<p><a href="https://zhuanlan.zhihu.com/p/114750961">什么是CSRF攻击？如何防御CRSF攻击？ - 知乎 (zhihu.com)</a></p>
<h3 id="在Security中配置："><a href="#在Security中配置：" class="headerlink" title="在Security中配置："></a><strong>在Security中配置：</strong></h3><p>配置后访问资源http请求头中需要携带CSRF令牌才能访问，（GET请求除外，GET请求不需要携带CSRF就可以访问）</p>
<p>没访问资源一次就会发生一次新的CSRF令牌，一个令牌只能使用一次</p>
<p><img src="https://s2.loli.net/2022/03/21/kZmP971nS8AXgTJ.png" alt="image-20220321174052920"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http</span><br><span class="line">        .csrf()//开启CSRF防御（GET请求是不会被防御的）</span><br><span class="line">        //使用cookie存储CSRF令牌（每次防御页面都需要携带该令牌），里面的参数表示这个cookie是可以被js脚本获取到的，</span><br><span class="line">        .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) //</span><br><span class="line">        .ignoringAntMatchers(&quot;/authentication&quot;) //排除哪些请求不需要携带CSRF令牌就可以进行访问</span><br></pre></td></tr></table></figure>

<p><strong>完整配置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .csrf()//开启CSRF防御（GET请求是不会被防御的）</span><br><span class="line">                //使用cookie存储CSRF令牌（每次防御页面都需要携带该令牌），里面的参数表示这个cookie是可以被js脚本获取到的，</span><br><span class="line">                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) //</span><br><span class="line">                .ignoringAntMatchers(&quot;/authentication&quot;) //排除哪些请求不需要携带CSRF令牌就可以进行访问</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .cors()//开启跨域访问</span><br><span class="line">                .and()</span><br><span class="line">                //将jwtAuthenticationTokenFilter放置在UsernamePasswordAuthenticationFilter之前</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //令牌仓库默认是在内存中,我们指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/login&quot;,&quot;/authentication&quot;,&quot;/refreshToken&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);//不使用session，关闭session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 识别jwt令牌需要的</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception&#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置跨域请求CORS源</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsConfigurationSource corsConfigurationSource()&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        //允许哪些域访问</span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:8080&quot;));</span><br><span class="line">        //访问方式</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));</span><br><span class="line">        //设置默认参数</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        //允许跨域访问哪些资源</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;,corsConfiguration);</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/21/2QsiSmgb1pR6c8k.png" alt="image-20220321172831555"></p>
<h3 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a>使用测试</h3><p><strong>先使用我们登录的请求获取jwt令牌与CSRF令牌</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/zJYNqRbAeBVXd7G.png" alt="image-20220321171847532"></p>
<p><strong>进行访问&#x2F;hello：</strong></p>
<p>不携带CSRF令牌进行访问：</p>
<p><img src="https://s2.loli.net/2022/03/21/FqsVLNpkCJTfZd7.png" alt="image-20220321171956312"></p>
<p>携带CSRF令牌进行访问：</p>
<p><img src="https://s2.loli.net/2022/03/21/AFh2SfxW9YQv3gH.png" alt="image-20220321172017322"></p>
]]></content>
      <categories>
        <category>SpringBoot-Security</category>
      </categories>
      <tags>
        <tag>安全框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java经典面试题总结(含答案)</title>
    <url>/2022/05/28/Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E5%90%AB%E7%AD%94%E6%A1%88)/</url>
    <content><![CDATA[<p>前言：</p>
<p>本文为CSDN博主「哪 吒」的原创文章，本篇仅供学习使用，尊重原创</p>
<p>原文链接：<a href="https://blog.csdn.net/guorui_java/article/details/119299329">https://blog.csdn.net/guorui_java/article/details/119299329</a></p>
<hr>
<h3 id="1、JDK-和-JRE-有什么区别？"><a href="#1、JDK-和-JRE-有什么区别？" class="headerlink" title="1、JDK 和 JRE 有什么区别？"></a>1、JDK 和 JRE 有什么区别？</h3><p>JDK（Java Development Kit），Java开发工具包</p>
<p>JRE（Java Runtime Environment），Java运行环境</p>
<p>JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。</p>
<h3 id="2、-x3D-x3D-和-equals-的区别是什么？"><a href="#2、-x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="2、&#x3D;&#x3D; 和 equals 的区别是什么？"></a>2、&#x3D;&#x3D; 和 equals 的区别是什么？</h3><p>对于基本类型，&#x3D;&#x3D;比较的是值；<br>对于引用类型，&#x3D;&#x3D;比较的是地址；<br>equals不能用于基本类型的比较；<br>如果没有重写equals，equals就相当于&#x3D;&#x3D;；<br>如果重写了equals方法，equals比较的是对象的内容；</p>
<h3 id="3、final-在-java-中有什么作用？"><a href="#3、final-在-java-中有什么作用？" class="headerlink" title="3、final 在 java 中有什么作用？"></a>3、final 在 java 中有什么作用？</h3><h4 id="（1）用来修饰一个引用"><a href="#（1）用来修饰一个引用" class="headerlink" title="（1）用来修饰一个引用"></a>（1）用来修饰一个引用</h4><p> 如果引用为基本数据类型，则该引用为常量，该值无法修改；<br> 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。<br> 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。</p>
<h4 id="（2）用来修饰一个方法"><a href="#（2）用来修饰一个方法" class="headerlink" title="（2）用来修饰一个方法"></a>（2）用来修饰一个方法</h4><p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p>
<h4 id="（3）用来修饰类"><a href="#（3）用来修饰类" class="headerlink" title="（3）用来修饰类"></a>（3）用来修饰类</h4><p>当用final修改类时，该类成为最终类，无法被继承。</p>
<p>比如常用的String类就是最终类。</p>
<h3 id="4、java-中的-Math-round-1-5-等于多少？"><a href="#4、java-中的-Math-round-1-5-等于多少？" class="headerlink" title="4、java 中的 Math.round(-1.5) 等于多少？"></a>4、java 中的 Math.round(-1.5) 等于多少？</h3><p>Math提供了三个与取整有关的方法：ceil、floor、round</p>
<h4 id="（1）ceil：向上取整；"><a href="#（1）ceil：向上取整；" class="headerlink" title="（1）ceil：向上取整；"></a>（1）ceil：向上取整；</h4><p>Math.ceil(11.3) &#x3D; 12;</p>
<p>Math.ceil(-11.3) &#x3D; 11;</p>
<h4 id="（2）floor：向下取整；"><a href="#（2）floor：向下取整；" class="headerlink" title="（2）floor：向下取整；"></a>（2）floor：向下取整；</h4><p>Math.floor(11.3) &#x3D; 11;</p>
<p>Math.floor(-11.3) &#x3D; -12;</p>
<h4 id="（3）round：四舍五入；"><a href="#（3）round：四舍五入；" class="headerlink" title="（3）round：四舍五入；"></a>（3）round：四舍五入；</h4><p>加0.5然后向下取整。</p>
<p>Math.round(11.3) &#x3D; 11;</p>
<p>Math.round(11.8) &#x3D; 12;</p>
<p>Math.round(-11.3) &#x3D; -11;</p>
<p>Math.round(-11.8) &#x3D; -12;</p>
<h3 id="5、String-属于基础的数据类型吗？"><a href="#5、String-属于基础的数据类型吗？" class="headerlink" title="5、String 属于基础的数据类型吗？"></a>5、String 属于基础的数据类型吗？</h3><p>不属于。</p>
<p>八种基本数据类型：byte、short、char、int、long、double、float、boolean。</p>
<h3 id="6、String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？"><a href="#6、String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？" class="headerlink" title="6、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>6、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h3><p>String str&#x3D;”i”会将起分配到常量池中，常量池中没有重复的元素，如果常量池中存中i，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p>
<p>String str&#x3D;new String(“i”)会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p>
<h3 id="7、如何将字符串反转？"><a href="#7、如何将字符串反转？" class="headerlink" title="7、如何将字符串反转？"></a>7、如何将字符串反转？</h3><p>将对象封装到stringBuilder中，调用reverse方法反转。</p>
<h3 id="8、String-类的常用方法都有那些？"><a href="#8、String-类的常用方法都有那些？" class="headerlink" title="8、String 类的常用方法都有那些？"></a>8、String 类的常用方法都有那些？</h3><h4 id="（1）常见String类的获取功能"><a href="#（1）常见String类的获取功能" class="headerlink" title="（1）常见String类的获取功能"></a>（1）常见String类的获取功能</h4><p>length：获取字符串长度；<br>charAt(int index)：获取指定索引位置的字符；<br>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引；<br>substring(int start)：从指定位置开始截取字符串,默认到末尾；<br>substring(int start,int end)：从指定位置开始到指定位置结束截取字符串；</p>
<h4 id="（2）常见String类的判断功能"><a href="#（2）常见String类的判断功能" class="headerlink" title="（2）常见String类的判断功能"></a>（2）常见String类的判断功能</h4><p>equals(Object obj)： 比较字符串的内容是否相同,区分大小写；<br>contains(String str): 判断字符串中是否包含传递进来的字符串；<br>startsWith(String str): 判断字符串是否以传递进来的字符串开头；<br>endsWith(String str): 判断字符串是否以传递进来的字符串结尾；<br>isEmpty(): 判断字符串的内容是否为空串””；</p>
<h4 id="（3）常见String类的转换功能"><a href="#（3）常见String类的转换功能" class="headerlink" title="（3）常见String类的转换功能"></a>（3）常见String类的转换功能</h4><p>byte[] getBytes(): 把字符串转换为字节数组；<br>char[] toCharArray(): 把字符串转换为字符数组；<br>String valueOf(char[] chs): 把字符数组转成字符串。valueOf可以将任意类型转为字符串；<br>toLowerCase(): 把字符串转成小写；<br>toUpperCase(): 把字符串转成大写；<br>concat(String str): 把字符串拼接；</p>
<h4 id="（4）常见String类的其他常用功能"><a href="#（4）常见String类的其他常用功能" class="headerlink" title="（4）常见String类的其他常用功能"></a>（4）常见String类的其他常用功能</h4><p>replace(char old,char new) 将指定字符进行互换<br>replace(String old,String new) 将指定字符串进行互换<br>trim() 去除两端空格<br>int compareTo(String str) 会对照ASCII 码表 从第一个字母进行减法运算 返回的就是这个减法的结果，如果前面几个字母一样会根据两个字符串的长度进行减法运算返回的就是这个减法的结果，如果连个字符串一摸一样 返回的就是0。</p>
<h3 id="9、new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#9、new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="9、new String(“a”) + new String(“b”) 会创建几个对象？"></a>9、new String(“a”) + new String(“b”) 会创建几个对象？</h3><p>对象1：new StringBuilder()</p>
<p>对象2：new String(“a”)</p>
<p>对象3：常量池中的”a”</p>
<p>对象4：new String(“b”)</p>
<p>对象5：常量池中的”b”</p>
<p>深入剖析：StringBuilder中的toString()：</p>
<p>对象6：new String(“ab”)</p>
<p>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</p>
<p>附加题</p>
<p>String s1 &#x3D; new String(“1”) + new String(“1”);&#x2F;&#x2F;s1变量记录的地址为：new String<br>s1.intern();&#x2F;&#x2F;在字符串常量池中生成”11”。如何理解：jdk6：创建了一个新的对象”11”，也就有新的地址；jdk7：此时常量池中并没有创建”11”，而是创建了一个指向堆空间中new String(“11”)的地址；<br>String s2 &#x3D; “11”;<br>System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;jdk6:false;jdk7:true</p>
<h3 id="10、如何将字符串反转？"><a href="#10、如何将字符串反转？" class="headerlink" title="10、如何将字符串反转？"></a>10、如何将字符串反转？</h3><p>添加到StringBuilder中，然后调用reverse()。</p>
<h3 id="11、String-类的常用方法都有那些？"><a href="#11、String-类的常用方法都有那些？" class="headerlink" title="11、String 类的常用方法都有那些？"></a>11、String 类的常用方法都有那些？</h3><p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等等。</p>
<h3 id="12、普通类和抽象类有哪些区别？"><a href="#12、普通类和抽象类有哪些区别？" class="headerlink" title="12、普通类和抽象类有哪些区别？"></a>12、普通类和抽象类有哪些区别？</h3><p>抽象类不能被实例化；<br>抽象类可以有抽象方法，只需申明，无须实现；<br>有抽象方法的类一定是抽象类；<br>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；<br>抽象方法不能声明为静态、不能被static、final修饰。</p>
<h3 id="13、接口和抽象类有什么区别？"><a href="#13、接口和抽象类有什么区别？" class="headerlink" title="13、接口和抽象类有什么区别？"></a>13、接口和抽象类有什么区别？</h3><h4 id="（1）接口"><a href="#（1）接口" class="headerlink" title="（1）接口"></a>（1）接口</h4><p>接口使用interface修饰；<br>接口不能实例化；<br>类可以实现多个接口；</p>
<p>java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p>
<h4 id="（2）抽象类"><a href="#（2）抽象类" class="headerlink" title="（2）抽象类"></a>（2）抽象类</h4><p>抽象类使用abstract修饰；<br>抽象类不能被实例化；<br>抽象类只能单继承；<br>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；<br>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</p>
<h3 id="14、java-中-IO-流分为几种？"><a href="#14、java-中-IO-流分为几种？" class="headerlink" title="14、java 中 IO 流分为几种？"></a>14、java 中 IO 流分为几种？</h3><p>（1）按流划分，可以分为输入流和输出流；</p>
<p>（2）按单位划分，可以分为字节流和字符流；</p>
<p>字节流：inputStream、outputStream；</p>
<p>字符流：reader、writer；</p>
<h3 id="15、BIO、NIO、AIO-有什么区别？"><a href="#15、BIO、NIO、AIO-有什么区别？" class="headerlink" title="15、BIO、NIO、AIO 有什么区别？"></a>15、BIO、NIO、AIO 有什么区别？</h3><h4 id="（1）同步阻塞BIO"><a href="#（1）同步阻塞BIO" class="headerlink" title="（1）同步阻塞BIO"></a>（1）同步阻塞BIO</h4><p>一个连接一个线程。</p>
<p>JDK1.4之前，建立网络连接的时候采用BIO模式，先在启动服务端socket，然后启动客户端socket，对服务端通信，客户端发送请求后，先判断服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话会等待请求结束后才继续执行。</p>
<h4 id="（2）同步非阻塞NIO"><a href="#（2）同步非阻塞NIO" class="headerlink" title="（2）同步非阻塞NIO"></a>（2）同步非阻塞NIO</h4><p>NIO主要是想解决BIO的大并发问题，BIO是每一个请求分配一个线程，当请求过多时，每个线程占用一定的内存空间，服务器瘫痪了。</p>
<p>JDK1.4开始支持NIO，适用于连接数目多且连接比较短的架构，比如聊天服务器，并发局限于应用中。</p>
<p>一个请求一个线程。</p>
<h4 id="（3）异步非阻塞AIO"><a href="#（3）异步非阻塞AIO" class="headerlink" title="（3）异步非阻塞AIO"></a>（3）异步非阻塞AIO</h4><p>一个有效请求一个线程。</p>
<p>JDK1.7开始支持AIO，适用于连接数目多且连接比较长的结构，比如相册服务器，充分调用OS参与并发操作。</p>
<h3 id="16、Files的常用方法都有哪些？"><a href="#16、Files的常用方法都有哪些？" class="headerlink" title="16、Files的常用方法都有哪些？"></a>16、Files的常用方法都有哪些？</h3><p>exist<br>createFile<br>createDirectory<br>write<br>read<br>copy<br>size<br>delete<br>move</p>
<h3 id="17、什么是反射？"><a href="#17、什么是反射？" class="headerlink" title="17、什么是反射？"></a>17、什么是反射？</h3><p>所谓反射，是java在运行时进行自我观察的能力，通过class、constructor、field、method四个方法获取一个类的各个组成部分。</p>
<p>在Java运行时环境中，对任意一个类，可以知道类有哪些属性和方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于反射机制。</p>
<h3 id="18、什么是-java-序列化？什么情况下需要序列化？"><a href="#18、什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="18、什么是 java 序列化？什么情况下需要序列化？"></a>18、什么是 java 序列化？什么情况下需要序列化？</h3><p>序列化就是一种用来处理对象流的机制。将对象的内容流化，将流化后的对象传输于网络之间。</p>
<p>序列化是通过实现serializable接口，该接口没有需要实现的方法，implement Serializable只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObejct（Object object）方法就可以将参数的obj对象到磁盘，需要恢复的时候使用输入流。</p>
<p>序列化是将对象转换为容易传输的格式的过程。</p>
<p>例如，可以序列化一个对象，然后通过HTTP通过Internet在客户端和服务器之间传输该对象。在另一端，反序列化将从流中心构造成对象。</p>
<p>一般程序在运行时，产生对象，这些对象随着程序的停止而消失，但我们想将某些对象保存下来，这时，我们就可以通过序列化将对象保存在磁盘，需要使用的时候通过反序列化获取到。</p>
<p>对象序列化的最主要目的就是传递和保存对象，保存对象的完整性和可传递性。</p>
<p>譬如通过网络传输或者把一个对象保存成本地一个文件的时候，需要使用序列化。</p>
<h3 id="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"><a href="#19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？" class="headerlink" title="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"></a>19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</h3><h4 id="（1）什么要使用克隆？"><a href="#（1）什么要使用克隆？" class="headerlink" title="（1）什么要使用克隆？"></a>（1）什么要使用克隆？</h4><p>想对一个对象进行复制，又想保留原有的对象进行接下来的操作，这个时候就需要克隆了。</p>
<h4 id="（2）如何实现对象克隆？"><a href="#（2）如何实现对象克隆？" class="headerlink" title="（2）如何实现对象克隆？"></a>（2）如何实现对象克隆？</h4><p>实现Cloneable接口，重写clone方法；<br>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。<br>BeanUtils，apache和Spring都提供了bean工具，只是这都是浅克隆。</p>
<h4 id="（3）深拷贝和浅拷贝区别是什么？"><a href="#（3）深拷贝和浅拷贝区别是什么？" class="headerlink" title="（3）深拷贝和浅拷贝区别是什么？"></a>（3）深拷贝和浅拷贝区别是什么？</h4><p>浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；<br>深克隆：既克隆基本类型变量，又克隆引用类型变量；</p>
<h4 id="（4）代码实例"><a href="#（4）代码实例" class="headerlink" title="（4）代码实例"></a>（4）代码实例</h4><p><a href="https://imgtu.com/i/jkNEwQ"><img src="https://s1.ax1x.com/2022/06/25/jkNEwQ.png" alt="jkNEwQ.png"></a><br><a href="https://imgtu.com/i/jkNFOS"><img src="https://s1.ax1x.com/2022/06/25/jkNFOS.png" alt="jkNFOS.png"></a></p>
<h3 id="20、throw-和-throws-的区别？"><a href="#20、throw-和-throws-的区别？" class="headerlink" title="20、throw 和 throws 的区别？"></a>20、throw 和 throws 的区别？</h3><h4 id="（1）throw"><a href="#（1）throw" class="headerlink" title="（1）throw"></a>（1）throw</h4><p>作用在方法内，表示抛出具体异常，由方法体内的语句处理；<br>一定抛出了异常；</p>
<h4 id="（2）throws"><a href="#（2）throws" class="headerlink" title="（2）throws"></a>（2）throws</h4><p>作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；<br>可能出现异常，不一定会发生异常；</p>
<h3 id="21、final、finally、finalize-有什么区别？"><a href="#21、final、finally、finalize-有什么区别？" class="headerlink" title="21、final、finally、finalize 有什么区别？"></a>21、final、finally、finalize 有什么区别？</h3><p>final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</p>
<p>finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p>
<p>finalize方法用于垃圾回收。</p>
<p>一般情况下不需要我们实现finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现finalize方法，关闭这个链接。</p>
<p>但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p>
<h3 id="22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p><a href="https://imgtu.com/i/jkNAeg"><img src="https://s1.ax1x.com/2022/06/25/jkNAeg.png" alt="jkNAeg.png"></a></p>
<h3 id="23、常见的异常类有哪些？"><a href="#23、常见的异常类有哪些？" class="headerlink" title="23、常见的异常类有哪些？"></a>23、常见的异常类有哪些？</h3><p>NullPointerException：空指针异常；<br>SQLException：数据库相关的异常；<br>IndexOutOfBoundsException：数组下角标越界异常；<br>FileNotFoundException：打开文件失败时抛出；<br>IOException：当发生某种IO异常时抛出；<br>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；<br>NoSuchMethodException：无法找到某一方法时，抛出；<br>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；<br>NumberFormatException：当试图将字符串转换成数字时，失败了，抛出；<br>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 </p>
<h3 id="24、hashcode是什么？有什么作用？"><a href="#24、hashcode是什么？有什么作用？" class="headerlink" title="24、hashcode是什么？有什么作用？"></a>24、hashcode是什么？有什么作用？</h3><p>Java中Object有一个方法：</p>
<p>public native int hashcode();</p>
<h4 id="（1）hashcode-方法的作用"><a href="#（1）hashcode-方法的作用" class="headerlink" title="（1）hashcode()方法的作用"></a>（1）hashcode()方法的作用</h4><p>hashcode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。</p>
<p>当集合需要添加新的对象时，先调用这个对象的hashcode()方法，得到对应的hashcode值，实际上hashmap中会有一个table保存已经存进去的对象的hashcode值，如果table中没有改hashcode值，则直接存入，如果有，就调用equals方法与新元素进行比较，相同就不存了，不同就存入。</p>
<h4 id="（2）equals和hashcode的关系"><a href="#（2）equals和hashcode的关系" class="headerlink" title="（2）equals和hashcode的关系"></a>（2）equals和hashcode的关系</h4><p>如果equals为true，hashcode一定相等； </p>
<p>如果equals为false，hashcode不一定不相等；</p>
<p>如果hashcode值相等，equals不一定相等；</p>
<p>如果hashcode值不等，equals一定不等；</p>
<h4 id="（3）重写equals方法时，一定要重写hashcode方法"><a href="#（3）重写equals方法时，一定要重写hashcode方法" class="headerlink" title="（3）重写equals方法时，一定要重写hashcode方法"></a>（3）重写equals方法时，一定要重写hashcode方法</h4><h4 id="（4）百度百科"><a href="#（4）百度百科" class="headerlink" title="（4）百度百科"></a>（4）百度百科</h4><blockquote>
<p>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 </p>
<p>hashCode 的常规协定是：<br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。<br>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。<br>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） </p>
<p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</blockquote>
<h4 id="（5）小白解释"><a href="#（5）小白解释" class="headerlink" title="（5）小白解释"></a>（5）小白解释</h4><blockquote>
<p>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0  1  2  3  4  5  6  7<br>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用hashcode那就会使效率提高很多。<br>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</p>
<p>2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。<br>也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br>那么。重写了equals()，为什么还要重写hashCode()呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊。</p>
</blockquote>
<h3 id="25、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#25、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="25、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>25、java 中操作字符串都有哪些类？它们之间有什么区别？</h3><h4 id="（1）String"><a href="#（1）String" class="headerlink" title="（1）String"></a>（1）String</h4><p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p>
<h4 id="（2）StringBuilder"><a href="#（2）StringBuilder" class="headerlink" title="（2）StringBuilder"></a>（2）StringBuilder</h4><p>线程不安全，效率高，多用于单线程。</p>
<h4 id="（3）StringBuffer"><a href="#（3）StringBuffer" class="headerlink" title="（3）StringBuffer"></a>（3）StringBuffer</h4><p>线程安全，由于加锁的原因，效率不如StringBuilder，多用于多线程。</p>
<p>不频繁的字符串操作使用String，操作频繁的情况不建议使用String。</p>
<p>StringBuilder &gt; StringBuffer &gt; String。</p>
<h3 id="26、java-中都有哪些引用类型？"><a href="#26、java-中都有哪些引用类型？" class="headerlink" title="26、java 中都有哪些引用类型？"></a>26、java 中都有哪些引用类型？</h3><h4 id="（1）强引用"><a href="#（1）强引用" class="headerlink" title="（1）强引用"></a>（1）强引用</h4><p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象。如果想被回收，可以将对象置为null； </p>
<h4 id="（2）软引用（SoftReference）"><a href="#（2）软引用（SoftReference）" class="headerlink" title="（2）软引用（SoftReference）"></a>（2）软引用（SoftReference）</h4><p>在内存足够的时候，软引用不会被回收，只有在内存不足时，系统才会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会跑出内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(buff);</span><br></pre></td></tr></table></figure>
<p>####（3）弱引用（WeakReference）</p>
<p>进行垃圾回收时，弱引用就会被回收。</p>
<h4 id="（4）虚引用（PhantomReference）"><a href="#（4）虚引用（PhantomReference）" class="headerlink" title="（4）虚引用（PhantomReference）"></a>（4）虚引用（PhantomReference）</h4><h4 id="（5）引用队列（ReferenceQueue）"><a href="#（5）引用队列（ReferenceQueue）" class="headerlink" title="（5）引用队列（ReferenceQueue）"></a>（5）引用队列（ReferenceQueue）</h4><p>引用队列可以与软引用、弱引用、虚引用一起配合使用。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有引用，就会在回收对象之前，把这个引用加入到引用队列中。</p>
<p>程序可以通过判断引用队列中是否加入了引用，来判断被引用的对象是否将要被垃圾回收，这样可以在对象被回收之前采取一些必要的措施。</p>
<h3 id="27、在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#27、在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="27、在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>27、在 Java 中，为什么不允许从静态方法中访问非静态变量？</h3><p>静态变量属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问；<br>非静态变量属于类的对象，只有在类的对象产生时，才会分配内存，通过类的实例去访问；<br>静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，所以无法调用。</p>
<h3 id="28、说说Java-Bean的命名规范"><a href="#28、说说Java-Bean的命名规范" class="headerlink" title="28、说说Java Bean的命名规范"></a>28、说说Java Bean的命名规范</h3><p>JavaBean 类必须是一个公共类，并将其访问属性设置为 public<br>JavaBean 类必须有一个空的构造函数：类中必须有一个不带参数的公用构造器，此构造器也应该通过调用各个特性的设置方法来设置特性的缺省值。<br>一个javaBean类不应有公共实例变量，类变量都为private<br>持有值应该通过一组存取方法（getXxx 和 setXxx）来访问：对于每个特性，应该有一个带匹配公用 getter 和 setter 方法的专用实例变量。<br>属性为布尔类型，可以使用 isXxx() 方法代替 getXxx() 方法。</p>
<p>通常属性名是要和 包名、类名、方法名、字段名、常量名作出区别的:</p>
<p>首先:必须用英文，不要用汉语拼音</p>
<h4 id="（1）包-package"><a href="#（1）包-package" class="headerlink" title="（1）包(package)"></a>（1）包(package)</h4><p>用于将完成不同功能的类分门别类，放在不同的目录(包)下，包的命名规则：将公司域名反转作为包名。比如<a href="http://www.sohu.com/">www.sohu.com</a> 对于包名：每个字母都需要小写。比如：com.sohu.test;该包下的Test类的全名是：com.sohu.Test.Java 。</p>
<p>如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(default package)。</p>
<h4 id="（2）类"><a href="#（2）类" class="headerlink" title="（2）类"></a>（2）类</h4><p>首字母大写，如果一个类由多个单词构成，那么每个单词的首字母都大写，而且中间不使用任何的连接符。尽量使用英文。如ConnectionFactory</p>
<h4 id="（3）方法"><a href="#（3）方法" class="headerlink" title="（3）方法"></a>（3）方法</h4><p>首单词全部小写，如果一个方法由多个单词构成，那么从第二个单词开始首字母大写，不使用连接符。addPerson</p>
<h4 id="（4）字段"><a href="#（4）字段" class="headerlink" title="（4）字段"></a>（4）字段</h4><p>与方法相同。如ageOfPerson</p>
<h4 id="（5）常量"><a href="#（5）常量" class="headerlink" title="（5）常量"></a>（5）常量</h4><p>所有单词的字母都是大写，如果有多个单词，那么使用下划线链接即可。</p>
<p>如：public static final int AGE_OF_PERSON &#x3D; 20; &#x2F;&#x2F;通常加上static</p>
<h3 id="29、Java-Bean-属性命名规范问题分析"><a href="#29、Java-Bean-属性命名规范问题分析" class="headerlink" title="29、Java Bean 属性命名规范问题分析"></a>29、Java Bean 属性命名规范问题分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String busName;</span><br><span class="line">	<span class="keyword">private</span> String pCount;</span><br><span class="line">	<span class="keyword">private</span> Boolean isRunning;</span><br><span class="line">	<span class="comment">//正确的命名方式，驼峰式的</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getBusName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> busName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusName</span><span class="params">(String busName)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.busName = busName;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//这是什么？</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getpCount</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pCount;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setpCount</span><span class="params">(String pCount)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.pCount = pCount;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//这个也是不允许的</span></span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">getIsRunning</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isRunning;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIsRunning</span><span class="params">(Boolean isRunning)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.isRunning = isRunning;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>javabean属性命名尽量使用常规的驼峰式命名规则</li>
<li>属性名第一个单词尽量避免使用一个字母：如eBook， eMail。</li>
<li>boolean属性名避免使用 “is” 开头的名称</li>
<li>随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。</li>
</ol>
<h3 id="30、什么是-Java-的内存模型"><a href="#30、什么是-Java-的内存模型" class="headerlink" title="30、什么是 Java 的内存模型?"></a>30、什么是 Java 的内存模型?</h3><p>在了解什么是 Java 内存模型之前，先了解一下为什么要提出 Java 内存模型。</p>
<p>之前提到过并发编程有三大问题</p>
<p>CPU 缓存，在多核 CPU 的情况下，带来了可见性问题<br>操作系统对当前执行线程的切换，带来了原子性问题<br>译器指令重排优化，带来了有序性问题<br>为了解决并发编程的三大问题，提出了 JSR-133，新的 Java 内存模型，JDK 5 开始使用。</p>
<p>简单总结下</p>
<p>Java 内存模型是 JVM 的一种规范<br>定义了共享内存在多线程程序中读写操作行为的规范<br>屏蔽了各种硬件和操作系统的访问差异，保证了 Java 程序在各种平台下对内存的访问效果一致<br>解决并发问题采用的方式：限制处理器优化和使用内存屏障<br>增强了三个同步原语（synchronized、volatile、final）的内存语义<br>定义了 happens-before 规则</p>
<h3 id="31、在-Java-中，什么时候用重载，什么时候用重写？"><a href="#31、在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="31、在 Java 中，什么时候用重载，什么时候用重写？"></a>31、在 Java 中，什么时候用重载，什么时候用重写？</h3><p>（1）重载是多态的集中体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。</p>
<p>（2）重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。</p>
<p>（3）简单总结：</p>
<p>重载是多样性，重写是增强剂；<br>目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；<br>目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时，使用重写；</p>
<p>生活例子：</p>
<blockquote>
<p>你想吃一碗面，我给你提供了拉面，炒面，刀削面，担担面供你选择，这是重载；</p>
<p>你想吃一碗面，我不但给你端来了面，还给你加了青菜，加了鸡蛋，这个是重写；</p>
</blockquote>
<p>设计模式：</p>
<blockquote>
<p>cglib实现动态代理，核心原理用的就是方法的重写；</p>
</blockquote>
<p>详细解答：</p>
<blockquote>
<p>Java的重载(overload) 最重要的应用场景就是构造器的重载，构造器重载后，提供多种形参形式的构造器，可以应对不同的业务需求，加强程序的健壮性和可扩展性，比如我们最近学习的Spring源码中的ClassPathXmlApplicationContext，它的构造函数使用重载一共提供了10个构造函数，这样就为业务的选择提供了多选择性。在应用到方法中时，主要是为了增强方法的健壮性和可扩展性，比如我们在开发中常用的各种工具类，比如我目前工作中的短信工具类SMSUtil, 发短信的方法就会使用重载，针对不同业务场景下的不同形参，提供短信发送方法，这样提高了工具类的扩展性和健壮性。<br>总结：重载必须要修改方法(构造器)的形参列表，可以修改方法的返回值类型，也可以修改方法的异常信息即访问权限；使用范围是在同一个类中，目的是对方法(构造器)进行功能扩展，以应对多业务场景的不同使用需求。提高程序的健壮性和扩展性。<br> java的重写(override) 只要用于子类对父类方法的扩展或修改，但是在我们开发中，为了避免程序混乱，重写一般都是为了方法的扩展，比如在cglib方式实现的动态代理中，代理类就是继承了目标类，对目标类的方法进行重写，同时在方法前后进行切面织入。</p>
</blockquote>
<p>总结：方法重写时，参数列表，返回值得类型是一定不能修改的，异常可以减少或者删除，但是不能抛出新的异常或者更广的异常，方法的访问权限可以降低限制，但是不能做更严格的限制。</p>
<p>（4）在里氏替换原则中，子类对父类的方法尽量不要重写和重载。（我们可以采用final的手段强制来遵循）</p>
<h3 id="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#32、举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>32、举例说明什么情况下会更倾向于使用抽象类而不是接口？</h3><p>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。</p>
<p>接口通常被用来表示附属描述或行为如： Runnable 、 Clonable 、 Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable( 注：这里的意思是指如果把 Runnable 等实现为抽象类的情况 ) ，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</p>
<p>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p>
<h3 id="33、实例化对象有哪几种方式"><a href="#33、实例化对象有哪几种方式" class="headerlink" title="33、实例化对象有哪几种方式"></a>33、实例化对象有哪几种方式</h3><ul>
<li><p>new</p>
</li>
<li><p>clone()</p>
</li>
<li><p>通过反射机制创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用 Class.forName方法获取类，在调用类的newinstance（）方法</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;com.dao.User&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)cls.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将一个对象实例化后，进行序列化，再反序列化，也可以获得一个对象（远程通信的场景下使用）</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span> (<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"><span class="comment">//序列化对象</span></span><br><span class="line">out.writeObject(user1); </span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//反序列化对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) in.readObject();</span><br><span class="line">System.out.println(<span class="string">&quot;反序列化user：&quot;</span> + user2);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="34、byte类型127-1等于多少"><a href="#34、byte类型127-1等于多少" class="headerlink" title="34、byte类型127+1等于多少"></a>34、byte类型127+1等于多少</h3><p>byte的范围是-128~127。</p>
<p>字节长度为8位，最左边的是符号位，而127的二进制为01111111，所以执行+1操作时，01111111变为10000000。</p>
<p>大家知道，计算机中存储负数，存的是补码的兴衰。左边第一位为符号位。</p>
<p>那么负数的补码转换成十进制如下：</p>
<p>一个数如果为正，则它的原码、反码、补码相同；一个正数的补码，将其转化为十进制，可以直接转换。</p>
<p>已知一个负数的补码，将其转换为十进制数，步骤如下：</p>
<p>先对各位取反；<br>将其转换为十进制数；<br>加上负号，再减去1；<br>例如10000000，最高位是1，是负数，①对各位取反得01111111，转换为十进制就是127，加上负号得-127，再减去1得-128；</p>
<h3 id="35、Java-容器都有哪些？"><a href="#35、Java-容器都有哪些？" class="headerlink" title="35、Java 容器都有哪些？"></a>35、Java 容器都有哪些？</h3><p>（1）Collection</p>
<p>① set</p>
<p>HashSet、TreeSet</p>
<p>② list</p>
<p>ArrayList、LinkedList、Vector</p>
<p>（2）Map</p>
<p>HashMap、HashTable、TreeMap</p>
<h3 id="36、Collection-和-Collections-有什么区别？"><a href="#36、Collection-和-Collections-有什么区别？" class="headerlink" title="36、Collection 和 Collections 有什么区别？"></a>36、Collection 和 Collections 有什么区别？</h3><p>（1）Collection是最基本的集合接口，Collection派生了两个子接口list和set，分别定义了两种不同的存储方式。</p>
<p>（2）Collections是一个包装类，它包含各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等）。</p>
<p>此类不能实例化，就像一个工具类，服务于Collection框架。</p>
<h3 id="37、list与Set区别"><a href="#37、list与Set区别" class="headerlink" title="37、list与Set区别"></a>37、list与Set区别</h3><h4 id="（1）List简介"><a href="#（1）List简介" class="headerlink" title="（1）List简介"></a>（1）List简介</h4><p>实际上有两种List：一种是基本的ArrayList,其优点在于随机访问元素，另一种是LinkedList,它并不是为快速随机访问设计的，而是快速的插入或删除。<br>ArrayList：由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。<br>LinkedList ：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。<br>还具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。</p>
<h4 id="（2）Set简介"><a href="#（2）Set简介" class="headerlink" title="（2）Set简介"></a>（2）Set简介</h4><p>Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection,只是行为不同。这是继承与多态思想的典型应用：表现不同的行为。Set不保存重复的元素(至于如何判断元素相同则较为负责) </p>
<p>Set : 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br>HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。<br>TreeSet： 保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。 </p>
<h4 id="（3）list与Set区别"><a href="#（3）list与Set区别" class="headerlink" title="（3）list与Set区别"></a>（3）list与Set区别</h4><p>① List,Set都是继承自Collection接口</p>
<p>② List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） </p>
<p>③ Set和List对比： </p>
<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>
<h3 id="38、HashMap-和-Hashtable-有什么区别？"><a href="#38、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="38、HashMap 和 Hashtable 有什么区别？"></a>38、HashMap 和 Hashtable 有什么区别？</h3><p>HashMap是线程不安全的，HashTable是线程安全的；<br>HashMap中允许键和值为null，HashTable不允许；<br>HashMap的默认容器是16，为2倍扩容，HashTable默认是11，为2倍+1扩容；</p>
<h3 id="39、说一下-HashMap-的实现原理？"><a href="#39、说一下-HashMap-的实现原理？" class="headerlink" title="39、说一下 HashMap 的实现原理？"></a>39、说一下 HashMap 的实现原理？</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>HashMap基于map接口，元素以键值对方式存储，允许有null值，HashMap是线程不安全的。</p>
<h4 id="（2）基本属性"><a href="#（2）基本属性" class="headerlink" title="（2）基本属性"></a>（2）基本属性</h4><p>初始化大小，默认16，2倍扩容；<br>负载因子0.75；<br>初始化的默认数组；<br>size<br>threshold。判断是否需要调整hashmap容量</p>
<h4 id="（3）HashMap的存储结构"><a href="#（3）HashMap的存储结构" class="headerlink" title="（3）HashMap的存储结构"></a>（3）HashMap的存储结构</h4><p>JDK1.7中采用数组+链表的存储形式。</p>
<p>HashMap采取Entry数组来存储key-value，每一个键值对组成了一个Entry实体，Entry类时机上是一个单向的链表结构，它具有next指针，指向下一个Entry实体，以此来解决Hash冲突的问题。</p>
<p>HashMap实现一个内部类Entry，重要的属性有hash、key、value、next。<br><a href="https://imgtu.com/i/jkaUsK"><img src="https://s1.ax1x.com/2022/06/25/jkaUsK.jpg" alt="jkaUsK.jpg"></a></p>
<p>JDK1.8中采用数据+链表+红黑树的存储形式。当链表长度超过阈值（8）时，将链表转换为红黑树。在性能上进一步得到提升。<br><a href="https://imgtu.com/i/jkaNM6"><img src="https://s1.ax1x.com/2022/06/25/jkaNM6.jpg" alt="jkaNM6.jpg"></a></p>
<h3 id="40、set有哪些实现类？"><a href="#40、set有哪些实现类？" class="headerlink" title="40、set有哪些实现类？"></a>40、set有哪些实现类？</h3><h4 id="（1）HashSet"><a href="#（1）HashSet" class="headerlink" title="（1）HashSet"></a>（1）HashSet</h4><p>HashSet是set接口的实现类，set下面最主要的实现类就是HashSet（也就是用的最多的），此外还有LinkedHashSet和TreeSet。<br>HashSet是无序的、不可重复的。通过对象的hashCode和equals方法保证对象的唯一性。<br>HashSet内部的存储结构是哈希表，是线程不安全的。</p>
<h4 id="（2）TreeSet"><a href="#（2）TreeSet" class="headerlink" title="（2）TreeSet"></a>（2）TreeSet</h4><p>TreeSet对元素进行排序的方式：</p>
<p>元素自身具备比较功能，需要实现Comparable接口，并覆盖compareTo方法。<br>元素自身不具备比较功能，需要实现Comparator接口，并覆盖compare方法。</p>
<h4 id="（3）LinkedHashSet"><a href="#（3）LinkedHashSet" class="headerlink" title="（3）LinkedHashSet"></a>（3）LinkedHashSet</h4><p>LinkedHashSet是一种有序的Set集合，即其元素的存入和输出的顺序是相同的。</p>
<h3 id="41、说一下-HashSet-的实现原理？"><a href="#41、说一下-HashSet-的实现原理？" class="headerlink" title="41、说一下 HashSet 的实现原理？"></a>41、说一下 HashSet 的实现原理？</h3><p>HashSet实际上是一个HashMap实例，数据存储结构都是数组+链表。</p>
<p>HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value都是一个统一的对象PRESENT。</p>
<p>private static final Object PRESENT &#x3D; new Object();<br>HashSet中add方法调用的是底层HashMap中的put方法，put方法要判断插入值是否存在，而HashSet的add方法，首先判断元素是否存在，如果存在则插入，如果不存在则不插入，这样就保证了HashSet中不存在重复值。</p>
<p> 通过对象的hashCode和equals方法保证对象的唯一性。</p>
<h3 id="42、ArrayList-和-LinkedList-的区别是什么？"><a href="#42、ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="42、ArrayList 和 LinkedList 的区别是什么？"></a>42、ArrayList 和 LinkedList 的区别是什么？</h3><p>ArrayList是动态数组的数据结构实现，查找和遍历的效率较高；</p>
<p>LinkedList 是双向链表的数据结构，增加和删除的效率较高；</p>
<h3 id="43、如何实现数组和-List-之间的转换？"><a href="#43、如何实现数组和-List-之间的转换？" class="headerlink" title="43、如何实现数组和 List 之间的转换？"></a>43、如何实现数组和 List 之间的转换？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;zs&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ww&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">String[] arr1 = list1.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list1.size()]);</span><br><span class="line">System.out.println(arr1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    System.out.println(arr1[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44、在-Queue-中-poll-和-remove-有什么区别？"><a href="#44、在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="44、在 Queue 中 poll()和 remove()有什么区别？"></a>44、在 Queue 中 poll()和 remove()有什么区别？</h3><h4 id="（1）offer-和add-区别："><a href="#（1）offer-和add-区别：" class="headerlink" title="（1）offer()和add()区别："></a>（1）offer()和add()区别：</h4><p>增加新项时，如果队列满了，add会抛出异常，offer返回false。</p>
<h4 id="（2）poll-和remove-区别："><a href="#（2）poll-和remove-区别：" class="headerlink" title="（2）poll()和remove()区别："></a>（2）poll()和remove()区别：</h4><p>poll()和remove()都是从队列中删除第一个元素，remove抛出异常，poll返回null。</p>
<h4 id="（3）peek-和element（）区别："><a href="#（3）peek-和element（）区别：" class="headerlink" title="（3）peek()和element（）区别："></a>（3）peek()和element（）区别：</h4><p>peek()和element（）用于查询队列头部元素，为空时element抛出异常，peek返回null。</p>
<h3 id="45、哪些集合类是线程安全的"><a href="#45、哪些集合类是线程安全的" class="headerlink" title="45、哪些集合类是线程安全的"></a>45、哪些集合类是线程安全的</h3><p>Vector：就比Arraylist多了个同步化机制（线程安全）。</p>
<p>Stack：栈，也是线程安全的，继承于Vector。</p>
<p>Hashtable：就比Hashmap多了个线程安全。</p>
<p>ConcurrentHashMap:是一种高效但是线程安全的集合。</p>
<h3 id="46、迭代器-Iterator-是什么？"><a href="#46、迭代器-Iterator-是什么？" class="headerlink" title="46、迭代器 Iterator 是什么？"></a>46、迭代器 Iterator 是什么？</h3><p>为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator)。</p>
<h3 id="47、Iterator-怎么使用？有什么特点？"><a href="#47、Iterator-怎么使用？有什么特点？" class="headerlink" title="47、Iterator 怎么使用？有什么特点？"></a>47、Iterator 怎么使用？有什么特点？</h3><p>Iterator 接口源码中的方法：</p>
<ol>
<li><p>java.lang.Iterable 接口被 java.util.Collection 接口继承，java.util.Collection 接口的 iterator() 方法返回一个 Iterator 对象</p>
</li>
<li><p>next() 方法获得集合中的下一个元素</p>
</li>
<li><p>hasNext() 检查集合中是否还有元素</p>
</li>
<li><p>remove() 方法将迭代器新返回的元素删除</p>
</li>
</ol>
<h3 id="48、Iterator-和-ListIterator-有什么区别？"><a href="#48、Iterator-和-ListIterator-有什么区别？" class="headerlink" title="48、Iterator 和 ListIterator 有什么区别？"></a>48、Iterator 和 ListIterator 有什么区别？</h3><p>（1）ListIterator 继承 Iterator</p>
<p>（2）ListIterator 比 Iterator多方法</p>
<ol>
<li><p>add(E e)  将指定的元素插入列表，插入位置为迭代器当前位置之前</p>
</li>
<li><p>set(E e)  迭代器返回的最后一个元素替换参数e</p>
</li>
<li><p>hasPrevious()  迭代器当前位置，反向遍历集合是否含有元素</p>
</li>
<li><p>previous()  迭代器当前位置，反向遍历集合，下一个元素</p>
</li>
<li><p>previousIndex()  迭代器当前位置，反向遍历集合，返回下一个元素的下标</p>
</li>
<li><p>nextIndex()  迭代器当前位置，返回下一个元素的下标<br>（3）使用范围不同，Iterator可以迭代所有集合；ListIterator 只能用于List及其子类</p>
</li>
<li><p>ListIterator 有 add 方法，可以向 List 中添加对象；Iterator 不能</p>
</li>
<li><p>ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向遍历；Iterator不可以</p>
</li>
<li><p>ListIterator 有 nextIndex() 和previousIndex() 方法，可定位当前索引的位置；Iterator不可以</p>
</li>
<li><p>ListIterator 有 set()方法，可以实现对 List 的修改；Iterator 仅能遍历，不能修改。</p>
</li>
</ol>
<h3 id="49、怎么确保一个集合不能被修改？"><a href="#49、怎么确保一个集合不能被修改？" class="headerlink" title="49、怎么确保一个集合不能被修改？"></a>49、怎么确保一个集合不能被修改？</h3><p>我们很容易想到用final关键字进行修饰，我们都知道</p>
<p>final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。</p>
<p>那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。</p>
<p>我们可以做一个实验：</p>
<p>可以看到：我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。</p>
<p>那我们应该怎么做才能确保集合不被修改呢？<br>我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。</p>
<p>同理：Collections包也提供了对list和set集合的方法。</p>
<p>Collections.unmodifiableList(List)<br>Collections.unmodifiableSet(Set)<br><a href="https://imgtu.com/i/jkabQ0"><img src="https://s1.ax1x.com/2022/06/25/jkabQ0.md.jpg" alt="jkabQ0.md.jpg"></a></p>
<h3 id="50、队列和栈是什么？有什么区别？"><a href="#50、队列和栈是什么？有什么区别？" class="headerlink" title="50、队列和栈是什么？有什么区别？"></a>50、队列和栈是什么？有什么区别？</h3><p>（1）队列先进先出，栈先进后出。</p>
<p>（2）遍历数据速度不同。</p>
<p>栈只能从头部取数据 也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性；</p>
<p>队列则不同，他基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多。</p>
<h3 id="51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？"><a href="#51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？" class="headerlink" title="51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？"></a>51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？</h3><p>ConcurrentHashMap的原理是引用了内部的 Segment ( ReentrantLock )  分段锁，保证在操作不同段 map 的时候， 可以并发执行， 操作同段 map 的时候，进行锁的竞争和等待。从而达到线程安全， 且效率大于 synchronized。</p>
<p>但是在 Java 8 之后， JDK 却弃用了这个策略，重新使用了 synchronized+CAS。</p>
<p>弃用原因</p>
<p>通过  JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p>
<p>加入多个分段锁浪费内存空间。<br>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。<br>为了提高 GC 的效率<br>新的同步方案</p>
<p>既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？（源码保留了segment 代码， 但并没有使用）。</p>
<h3 id="52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"><a href="#52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？" class="headerlink" title="52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"></a>52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</h3><p>我想从下面几个角度讨论这个问题：</p>
<p>（1）锁的粒度</p>
<p>首先锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍。</p>
<p>（2）Hash冲突</p>
<p>JDK1.7中，ConcurrentHashMap从过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。<br>JDK1.8中，在ConcurrentHashmap进行扩容时，其他线程可以通过检测数组中的节点决定是否对这条链表（红黑树）进行扩容，减小了扩容的粒度，提高了扩容的效率。</p>
<p>下面是我对面试中的那个问题的一下看法。</p>
<p>为什么是synchronized，而不是ReentranLock</p>
<p>（1）减少内存开销</p>
<p>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p>
<p>（2）获得JVM的支持</p>
<p>可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</p>
<h3 id="53、concurrentHashMap和HashTable有什么区别"><a href="#53、concurrentHashMap和HashTable有什么区别" class="headerlink" title="53、concurrentHashMap和HashTable有什么区别"></a>53、concurrentHashMap和HashTable有什么区别</h3><p>concurrentHashMap融合了hashmap和hashtable的优势，hashmap是不同步的，但是单线程情况下效率高，hashtable是同步的同步情况下保证程序执行的正确性。</p>
<p>但hashtable每次同步执行的时候都要锁住整个结构，如下图：<br><a href="https://imgtu.com/i/jkdpWR"><img src="https://s1.ax1x.com/2022/06/25/jkdpWR.md.jpg" alt="jkdpWR.md.jpg"></a></p>
<p>concurrentHashMap锁的方式是细粒度的。concurrentHashMap将hash分为16个桶（默认值），诸如get、put、remove等常用操作只锁住当前需要用到的桶。</p>
<p>concurrentHashMap的读取并发，因为读取的大多数时候都没有锁定，所以读取操作几乎是完全的并发操作，只是在求size时才需要锁定整个hash。</p>
<p>而且在迭代时，concurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，弱一致迭代器。在这种方式中，当iterator被创建后集合再发生改变就不会抛出ConcurrentModificationException，取而代之的是在改变时new新的数据而不是影响原来的数据，iterator完成后再讲头指针替代为新的数据，这样iterator时使用的是原来的数据。</p>
<h3 id="54、HashMap和HashSet的区别"><a href="#54、HashMap和HashSet的区别" class="headerlink" title="54、HashMap和HashSet的区别"></a>54、HashMap和HashSet的区别</h3><p>（1）先了解一下HashCode</p>
<p>Java中的集合有两类，一类是List，一类是Set。</p>
<p>List：元素有序，可以重复；</p>
<p>Set：元素无序，不可重复；</p>
<p>要想保证元素的不重复，拿什么来判断呢？这就是Object.equals方法了。如果元素有很多，增加一个元素，就要判断n次吗？</p>
<p>显然不现实，于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一根地址上，初学者可以简单的理解为，HashCode方法返回的就是对象存储的物理位置（实际上并不是）。</p>
<p>这样一来，当集合添加新的元素时，先调用这个元素的hashcode()方法，就一下子能定位到他应该放置的物理位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上，不用再进行任何比较了。如果这个位置上有元素，就调用它的equals方法与新元素进行比较，想同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际上调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<p>简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率。</p>
<p>Java对象的equals方法和hashCode方法时这样规定的：</p>
<p>相等的对象就必须具有相等的hashcode。</p>
<p>如果两个对象的hashcode相同，他们并不一定相同。<br>如果两个对象的hashcode相同，他们并不一定相同。<br>如果两个Java对象A和B，A和B不相等，但是A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同，这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用规则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法避免哈希冲突。</p>
<p>equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p>
<p>（2）HashMap和HashSet的区别</p>
<p><a href="https://imgtu.com/i/jVQ1ER"><img src="https://s1.ax1x.com/2022/06/27/jVQ1ER.jpg" alt="jVQ1ER.jpg"></a></p>
<h3 id="55、请谈谈-ReadWriteLock-和-StampedLock"><a href="#55、请谈谈-ReadWriteLock-和-StampedLock" class="headerlink" title="55、请谈谈 ReadWriteLock 和 StampedLock"></a>55、请谈谈 ReadWriteLock 和 StampedLock</h3><h4 id="ReadWriteLock包括两种子锁"><a href="#ReadWriteLock包括两种子锁" class="headerlink" title="ReadWriteLock包括两种子锁"></a>ReadWriteLock包括两种子锁</h4><p>（1）ReadWriteLock</p>
<p>ReadWriteLock 可以实现多个读锁同时进行，但是读与写和写于写互斥，只能有一个写锁线程在进行。</p>
<p>（2）StampedLock</p>
<p>StampedLock是Jdk在1.8提供的一种读写锁，相比较ReentrantReadWriteLock性能更好，因为ReentrantReadWriteLock在读写之间是互斥的，使用的是一种悲观策略，在读线程特别多的情况下，会造成写线程处于饥饿状态，虽然可以在初始化的时候设置为true指定为公平，但是吞吐量又下去了，而StampedLock是提供了一种乐观策略，更好的实现读写分离，并且吞吐量不会下降。</p>
<h4 id="StampedLock包括三种锁："><a href="#StampedLock包括三种锁：" class="headerlink" title="StampedLock包括三种锁："></a>StampedLock包括三种锁：</h4><p>（1）写锁writeLock：</p>
<p>writeLock是一个独占锁写锁，当一个线程获得该锁后，其他请求读锁或者写锁的线程阻塞， 获取成功后，会返回一个stamp（凭据）变量来表示该锁的版本，在释放锁时调用unlockWrite方法传递stamp参数。提供了非阻塞式获取锁tryWriteLock。</p>
<p>（2）悲观读锁readLock：</p>
<p>readLock是一个共享读锁，在没有线程获取写锁情况下，多个线程可以获取该锁。如果有写锁获取，那么其他线程请求读锁会被阻塞。悲观读锁会认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据进行加锁，这是在读少写多的情况下考虑的。请求该锁成功后会返回一个stamp值，在释放锁时调用unlockRead方法传递stamp参数。提供了非阻塞式获取锁方法tryWriteLock。</p>
<p>（3）乐观读锁tryOptimisticRead：</p>
<p>tryOptimisticRead相对比悲观读锁，在操作数据前并没有通过CAS设置锁的状态，如果没有线程获取写锁，则返回一个非0的stamp变量，获取该stamp后在操作数据前还需要调用validate方法来判断期间是否有线程获取了写锁，如果是返回值为0则有线程获取写锁，如果不是0则可以使用stamp变量的锁来操作数据。由于tryOptimisticRead并没有修改锁状态，所以不需要释放锁。这是读多写少的情况下考虑的，不涉及CAS操作，所以效率较高，在保证数据一致性上需要复制一份要操作的变量到方法栈中，并且在操作数据时可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性得到了保证。</p>
<h3 id="56、线程的run-和start-有什么区别？"><a href="#56、线程的run-和start-有什么区别？" class="headerlink" title="56、线程的run()和start()有什么区别？"></a>56、线程的run()和start()有什么区别？</h3><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h3 id="57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h3 id="58、Synchronized-用过吗，其原理是什么？"><a href="#58、Synchronized-用过吗，其原理是什么？" class="headerlink" title="58、Synchronized 用过吗，其原理是什么？"></a>58、Synchronized 用过吗，其原理是什么？</h3><p>（1）可重入性</p>
<p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁；</p>
<p>可重入的好处：<br>可以避免死锁；<br>可以让我们更好的封装代码；<br>synchronized是可重入锁，每部锁对象会有一个计数器记录线程获取几次锁，在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p>
<p>（2）不可中断性</p>
<p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断；<br>synchronized 属于不可被中断；<br>Lock lock方法是不可中断的；<br>Lock tryLock方法是可中断的；</p>
<h3 id="59、JVM-对-Java-的原生锁做了哪些优化？"><a href="#59、JVM-对-Java-的原生锁做了哪些优化？" class="headerlink" title="59、JVM 对 Java 的原生锁做了哪些优化？"></a>59、JVM 对 Java 的原生锁做了哪些优化？</h3><p>（1）自旋锁</p>
<p>在线程进行阻塞的时候，先让线程自旋等待一段时间，可能这段时间其它线程已经解锁，这时就无需让线程再进行阻塞操作了。</p>
<p>自旋默认次数是10次。</p>
<p>（2）自适应自旋锁</p>
<p>自旋锁的升级，自旋的次数不再固定，由前一次自旋次数和锁的拥有者的状态决定。</p>
<p>（3）锁消除</p>
<p>在动态编译同步代码块的时候，JIT编译器借助逃逸分析技术来判断锁对象是否只被一个线程访问，而没有其他线程，这时就可以取消锁了。</p>
<p>4、锁粗化</p>
<p>当JIT编译器发现一系列的操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环中，此时会将加锁同步的范围粗化到整个操作系列的外部。</p>
<p>锁粒度：不要锁住一些无关的代码。</p>
<p>锁粗化：可以一次性执行完的不要多次加锁执行。</p>
<h3 id="60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h3><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p>
<p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p>
<p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p>
<p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p>
<h3 id="61、Java-如何实现多线程之间的通讯和协作？"><a href="#61、Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="61、Java 如何实现多线程之间的通讯和协作？"></a>61、Java 如何实现多线程之间的通讯和协作？</h3><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p>
<p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p>
<p>Java中线程通信协作的最常见的两种方式：</p>
<p>1、syncrhoized加锁的线程的Object类的wait()&#x2F;notify()&#x2F;notifyAll()</p>
<p>2、ReentrantLock类加锁的线程的Condition类的await()&#x2F;signal()&#x2F;signalAll()</p>
<p>线程间直接的数据交换：</p>
<p>通过管道进行线程间通信：1）字节流；2）字符流</p>
<h3 id="62、Thread-类中的-yield-方法有什么作用？"><a href="#62、Thread-类中的-yield-方法有什么作用？" class="headerlink" title="62、Thread 类中的 yield 方法有什么作用？"></a>62、Thread 类中的 yield 方法有什么作用？</h3><p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p>结论：yield()从未导致线程转到等待&#x2F;睡眠&#x2F;阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p>
<h3 id="63、为什么说-Synchronized-是非公平锁？"><a href="#63、为什么说-Synchronized-是非公平锁？" class="headerlink" title="63、为什么说 Synchronized 是非公平锁？"></a>63、为什么说 Synchronized 是非公平锁？</h3><p>当锁被释放后，任何一个线程都有机会竞争得到锁，这样做的目的是提高效率，但缺点是可能产生线程饥饿现象。</p>
<h3 id="64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？"><a href="#64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？" class="headerlink" title="64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？"></a>64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？</h3><p>volatile只能作用于变量，保证了操作可见性和有序性，不保证原子性。</p>
<p>在Java的内存模型中分为主内存和工作内存，Java内存模型规定所有的变量存储在主内存中，每条线程都有自己的工作内存。</p>
<p>主内存和工作内存之间的交互分为8个原子操作：</p>
<ol>
<li>lock</li>
<li>unlock</li>
<li>read</li>
<li>load</li>
<li>assign</li>
<li>use</li>
<li>store</li>
<li>write</li>
</ol>
<p>volatile修饰的变量，只有对volatile进行assign操作，才可以load，只有load才可以use，，这样就保证了在工作内存操作volatile变量，都会同步到主内存中。</p>
<h3 id="65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？"><a href="#65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？" class="headerlink" title="65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？"></a>65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</h3><p>Synchronized的并发策略是悲观的，不管是否产生竞争，任何数据的操作都必须加锁。</p>
<p>乐观锁的核心是CAS，CAS包括内存值、预期值、新值，只有当内存值等于预期值时，才会将内存值修改为新值。</p>
<h3 id="66、乐观锁一定就是好的吗？"><a href="#66、乐观锁一定就是好的吗？" class="headerlink" title="66、乐观锁一定就是好的吗？"></a>66、乐观锁一定就是好的吗？</h3><p>乐观锁认为对一个对象的操作不会引发冲突，所以每次操作都不进行加锁，只是在最后提交更改时验证是否发生冲突，如果冲突则再试一遍，直至成功为止，这个尝试的过程称为自旋。</p>
<p>乐观锁没有加锁，但乐观锁引入了ABA问题，此时一般采用版本号进行控制；<br>也可能产生自旋次数过多问题，此时并不能提高效率，反而不如直接加锁的效率高；<br>只能保证一个对象的原子性，可以封装成对象，再进行CAS操作；</p>
<h3 id="67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。"><a href="#67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。" class="headerlink" title="67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。"></a>67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</h3><h4 id="（1）相似点"><a href="#（1）相似点" class="headerlink" title="（1）相似点"></a>（1）相似点</h4><p>它们都是阻塞式的同步，也就是说一个线程获得了对象锁，进入代码块，其它访问该同步块的线程都必须阻塞在同步代码块外面等待，而进行线程阻塞和唤醒的代码是比较高的。</p>
<h4 id="（2）功能区别"><a href="#（2）功能区别" class="headerlink" title="（2）功能区别"></a>（2）功能区别</h4><p>Synchronized是java语言的关键字，是原生语法层面的互斥，需要JVM实现；ReentrantLock 是JDK1.5之后提供的API层面的互斥锁，需要lock和unlock()方法配合try&#x2F;finally代码块来完成。<br>Synchronized使用较ReentrantLock 便利一些；<br>锁的细粒度和灵活性：ReentrantLock强于Synchronized；</p>
<h4 id="（3）性能区别"><a href="#（3）性能区别" class="headerlink" title="（3）性能区别"></a>（3）性能区别</h4><p>Synchronized引入偏向锁，自旋锁之后，两者的性能差不多，在这种情况下，官方建议使用Synchronized。</p>
<h4 id="①-Synchronized"><a href="#①-Synchronized" class="headerlink" title="① Synchronized"></a>① Synchronized</h4><p>Synchronized会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。</p>
<p>在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计数器+1，相应的执行monitorexit时，计数器-1，当计数器为0时，锁就会被释放。如果获取锁失败，当前线程就要阻塞，知道对象锁被另一个线程释放为止。</p>
<h4 id="②-ReentrantLock"><a href="#②-ReentrantLock" class="headerlink" title="② ReentrantLock"></a>② ReentrantLock</h4><p>ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有如下三项：</p>
<p>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized避免出现死锁的情况。通过lock.lockInterruptibly()来实现这一机制；<br>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁是非公平锁；ReentrantLock默认也是非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好；<br>锁绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象。ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像Synchronized要么随机唤醒一个线程，要么唤醒全部线程。</p>
<h3 id="68、ReentrantLock-是如何实现可重入性的？"><a href="#68、ReentrantLock-是如何实现可重入性的？" class="headerlink" title="68、ReentrantLock 是如何实现可重入性的？"></a>68、ReentrantLock 是如何实现可重入性的？</h3><h4 id="（1）什么是可重入性"><a href="#（1）什么是可重入性" class="headerlink" title="（1）什么是可重入性"></a>（1）什么是可重入性</h4><p>一个线程持有锁时，当其他线程尝试获取该锁时，会被阻塞；而这个线程尝试获取自己持有锁时，如果成功说明该锁是可重入的，反之则不可重入。</p>
<h4 id="（2）synchronized是如何实现可重入性"><a href="#（2）synchronized是如何实现可重入性" class="headerlink" title="（2）synchronized是如何实现可重入性"></a>（2）synchronized是如何实现可重入性</h4><p>synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。每个锁对象内部维护一个计数器，该计数器初始值为0，表示任何线程都可以获取该锁并执行相应的方法。根据虚拟机规范要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了对象的锁，把锁的计数器+1，相应的在执行monitorexit指令后锁计数器-1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p>
<h4 id="（3）ReentrantLock如何实现可重入性"><a href="#（3）ReentrantLock如何实现可重入性" class="headerlink" title="（3）ReentrantLock如何实现可重入性"></a>（3）ReentrantLock如何实现可重入性</h4><p>ReentrantLock使用内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个private volatile int state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p>
<h4 id="（4）ReentrantLock代码实例"><a href="#（4）ReentrantLock代码实例" class="headerlink" title="（4）ReentrantLock代码实例"></a>（4）ReentrantLock代码实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync继承于AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock默认是非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 可以通过向构造方法中传true来实现公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前想要获取锁的线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当前锁的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<h4 id="（5）代码分析"><a href="#（5）代码分析" class="headerlink" title="（5）代码分析"></a>（5）代码分析</h4><p>当一个线程在获取锁过程中，先判断state的值是否为0，如果是表示没有线程持有锁，就可以尝试获取锁。<br>当state的值不为0时，表示锁已经被一个线程占用了，这时会做一个判断current&#x3D;&#x3D;getExclusiveOwnerThread()，这个方法返回的是当前持有锁的线程，这个判断是看当前持有锁的线程是不是自己，如果是自己，那么将state的值+1，表示重入返回即可。</p>
<h3 id="69、什么是锁消除和锁粗化？"><a href="#69、什么是锁消除和锁粗化？" class="headerlink" title="69、什么是锁消除和锁粗化？"></a>69、什么是锁消除和锁粗化？</h3><h4 id="（1）锁消除"><a href="#（1）锁消除" class="headerlink" title="（1）锁消除"></a>（1）锁消除</h4><p>所消除就是虚拟机根据一个对象是否真正存在同步情况，若不存在同步情况，则对该对象的访问无需经过加锁解锁的操作。</p>
<p>比如StringBuffer的append方法，因为append方法需要判断对象是否被占用，而如果代码不存在锁竞争，那么这部分的性能消耗是无意义的。于是虚拟机在即时编译的时候就会将上面的代码进行优化，也就是锁消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，append方法用了 synchronized关键字，它是线程安全的。但我们可能仅在线程内部把StringBuffer当做局部变量使用；StringBuffer仅在方法内作用域有效，不存在线程安全的问题，这时我们可以通过编译器将其优化，将锁消除，前提是Java必须运行在server模式，同时必须开启逃逸分析；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br><span class="line"></span><br><span class="line">其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sBuf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sBuf.append(str1);<span class="comment">// append方法是同步操作</span></span><br><span class="line">    sBuf.append(str2);</span><br><span class="line">    <span class="keyword">return</span> sBuf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。 </p>
<h4 id="（2）锁粗化"><a href="#（2）锁粗化" class="headerlink" title="（2）锁粗化"></a>（2）锁粗化</h4><p>锁的请求、同步、释放都会消耗一定的系统资源，如果高频的锁请求反而不利于系统性能的优化，锁粗化就是把多次的锁请求合并成一个请求，扩大锁的范围，降低锁请求、同步、释放带来的性能损耗。</p>
<h3 id="70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？"><a href="#70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？" class="headerlink" title="70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？"></a>70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？</h3><p>1、都是可重入锁；</p>
<p>2、ReentrantLock内部是实现了Sync，Sync继承于AQS抽象类。Sync有两个实现，一个是公平锁，一个是非公平锁，通过构造函数定义。AQS中维护了一个state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p>
<p>3、ReentrantLock只能定义代码块，而Synchronized可以定义方法和代码块；</p>
<p>4、Synchronized是JVM的一个内部关键字，ReentrantLock是JDK1.5之后引入的一个API层面的互斥锁；</p>
<p>5、Synchronized实现自动的加锁、释放锁，ReentrantLock需要手动加锁和释放锁，中间可以暂停；</p>
<p>6、Synchronized由于引进了偏向锁和自旋锁，所以性能上和ReentrantLock差不多，但操作上方便很多，所以优先使用Synchronized。</p>
<h3 id="71、那么请谈谈-AQS-框架是怎么回事儿？"><a href="#71、那么请谈谈-AQS-框架是怎么回事儿？" class="headerlink" title="71、那么请谈谈 AQS 框架是怎么回事儿？"></a>71、那么请谈谈 AQS 框架是怎么回事儿？</h3><p>（1）AQS是AbstractQueuedSynchronizer的缩写，它提供了一个FIFO队列，可以看成是一个实现同步锁的核心组件。</p>
<p>AQS是一个抽象类，主要通过继承的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了同步状态的获取和释放的方法来提供自定义的同步组件。</p>
<p>（2）AQS的两种功能：独占锁和共享锁</p>
<p>（3）AQS的内部实现</p>
<p>AQS的实现依赖内部的同步队列，也就是FIFO的双向队列，如果当前线程竞争失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点（线程）。</p>
<p><a href="https://imgtu.com/i/jV6pBd"><img src="https://s1.ax1x.com/2022/06/27/jV6pBd.jpg" alt="jV6pBd.jpg"></a></p>
<p>AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接前驱节点。所以双向链表可以从任意一个节点开始很方便的范文前驱和后继节点。每个Node其实是由线程封装，当线程争抢锁失败后会封装成Node加入到AQS队列中。</p>
<h3 id="72、AQS-对资源的共享方式？"><a href="#72、AQS-对资源的共享方式？" class="headerlink" title="72、AQS 对资源的共享方式？"></a>72、AQS 对资源的共享方式？</h3><p>AQS定义两种资源共享方式</p>
<p>（1）Exclusive（独占）</p>
<p>只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
<p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁<br>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的<br>（2）Share（共享）</p>
<p>多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>
<p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。</p>
<h3 id="73、如何让-Java-的线程彼此同步？"><a href="#73、如何让-Java-的线程彼此同步？" class="headerlink" title="73、如何让 Java 的线程彼此同步？"></a>73、如何让 Java 的线程彼此同步？</h3><p>synchronized<br>volatile<br>ReenreantLock<br>使用局部变量实现线程同步</p>
<h3 id="74、你了解过哪些同步器？请分别介绍下。"><a href="#74、你了解过哪些同步器？请分别介绍下。" class="headerlink" title="74、你了解过哪些同步器？请分别介绍下。"></a>74、你了解过哪些同步器？请分别介绍下。</h3><p>（1）Semaphore同步器</p>
<p>特征：</p>
<p>经典的信号量，通过计数器控制对共享资源的访问<br>Semaphore(int count):创建拥有count个许可证的信号量<br>acquire()&#x2F;acquire(int num) : 获取1&#x2F;num个许可证<br>release&#x2F;release(int num) : 释放1&#x2F;num个许可证</p>
<p>（2）CountDownLatch同步器</p>
<p>特征：</p>
<p>必须发生指定数量的事件后才可以继续运行(比如赛跑比赛，裁判喊出3,2,1之后大家才同时跑)<br>CountDownLatch(int count):必须发生count个数量才可以打开锁存器<br>await:等待锁存器<br>countDown:触发事件</p>
<p>（3）CyclicBarrier同步器</p>
<p>特征：</p>
<p>适用于只有多个线程都到达预定点时才可以继续执行(比如斗地主，需要等齐三个人才开始)<br>CyclicBarrier(int num) :等待线程的数量<br>CyclicBarrier(int num, Runnable action) :等待线程的数量以及所有线程到达后的操作<br>await() : 到达临界点后暂停线程</p>
<p>（4）交换器(Exchanger)同步器</p>
<p>（5）Phaser同步器</p>
<h3 id="75、Java-中的线程池是如何实现的"><a href="#75、Java-中的线程池是如何实现的" class="headerlink" title="75、Java 中的线程池是如何实现的"></a>75、Java 中的线程池是如何实现的</h3><p>创建一个阻塞队列来容纳任务，在第一次执行任务时创建足够多的线程，并处理任务，之后每个工作线程自动从任务队列中获取线程，直到任务队列中任务为0为止，此时线程处于等待状态，一旦有工作任务加入任务队列中，即刻唤醒工作线程进行处理，实现线程的可复用性。</p>
<p>线程池一般包括四个基本组成部分：</p>
<p>（1）线程池管理器</p>
<p>用于创建线程池，销毁线程池，添加新任务。</p>
<p>（2）工作线程</p>
<p>线程池中线程，可循环执行任务，在没有任务时处于等待状态。</p>
<p>（3）任务队列</p>
<p>用于存放没有处理的任务，一种缓存机制。</p>
<p>（4）任务接口</p>
<p>每个任务必须实现的接口，供工作线程调度任务的执行，主要规定了任务的开始和收尾工作，和任务的状态。</p>
<h3 id="76、创建线程池的几个核心构造参数"><a href="#76、创建线程池的几个核心构造参数" class="headerlink" title="76、创建线程池的几个核心构造参数"></a>76、创建线程池的几个核心构造参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java线程池的完整构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize, // 线程池长期维持的最小线程数，即使线程处于Idle状态，也不会回收。</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize, // 线程数的上限</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime, // 线程最大生命周期。</span></span><br><span class="line"><span class="params">  TimeUnit unit, //时间单位                                 </span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue, //任务队列。当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory, // 线程工厂。定义如何启动一个线程，可以设置线程名称，并且可以确认是否是后台线程等。</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler // 拒绝任务处理器。由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<h3 id="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"><a href="#77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？" class="headerlink" title="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"></a>77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？</h3><p>线程池中的线程是在第一次提交任务submit时创建的</p>
<p>创建线程的方式有继承Thread和实现Runnable，重写run方法，start开始执行，wait等待，sleep休眠，shutdown停止。</p>
<p>（1）newSingleThreadExecutor：单线程池。</p>
<p>顾名思义就是一个池中只有一个线程在运行，该线程永不超时，而且由于是一个线程，当有多个任务需要处理时，会将它们放置到一个无界阻塞队列中逐个处理，它的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的使用方法也很简单，下面是简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建单线程执行器</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">// 执行一个任务</span></span><br><span class="line">    Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 获得任务执行后的返回值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回值：&quot;</span> + future.get());</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>（2）newCachedThreadPool：缓冲功能的线程。</p>
<p>建立了一个线程池，而且线程数量是没有限制的(当然，不能超过Integer的最大值)，新增一个任务即有一个线程处理，或者复用之前空闲的线程，或者重亲启动一个线程，但是一旦一个线程在60秒内一直处于等待状态时（也就是一分钟无事可做），则会被终止，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里需要说明的是，任务队列使用了同步阻塞队列，这意味着向队列中加入一个元素，即可唤醒一个线程(新创建的线程或复用空闲线程来处理)，这种队列已经没有队列深度的概念了。</p>
<p>（3）newFixedThreadPool：固定线程数量的线程池。</p>
<p>在初始化时已经决定了线程的最大数量，若任务添加的能力超出了线程的处理能力，则建立阻塞队列容纳多余的任务，其源码如下：　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面返回的是一个ThreadPoolExecutor，它的corePoolSize和maximumPoolSize是相等的，也就是说，最大线程数量为nThreads。如果任务增长的速度非常快，超过了LinkedBlockingQuene的最大容量(Integer的最大值)，那此时会如何处理呢？会按照ThreadPoolExecutor默认的拒绝策略(默认是DiscardPolicy，直接丢弃)来处理。</p>
<p>以上三种线程池执行器都是ThreadPoolExecutor的简化版，目的是帮助开发人员屏蔽过得线程细节，简化多线程开发。当需要运行异步任务时，可以直接通过Executors获得一个线程池，然后运行任务，不需要关注ThreadPoolExecutor的一系列参数时什么含义。当然，有时候这三个线程不能满足要求，此时则可以直接操作ThreadPoolExecutor来实现复杂的多线程计算。</p>
<p>newSingleThreadExecutor、newCachedThreadPool、newFixedThreadPool是线程池的简化版，而ThreadPoolExecutor则是旗舰版___简化版容易操作，需要了解的知识相对少些，方便使用，而旗舰版功能齐全，适用面广，难以驾驭。</p>
<h3 id="78、volatile-关键字的作用"><a href="#78、volatile-关键字的作用" class="headerlink" title="78、volatile 关键字的作用"></a>78、volatile 关键字的作用</h3><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</p>
<p>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</p>
<h3 id="79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？"><a href="#79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？" class="headerlink" title="79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？"></a>79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？</h3><p>volatile修饰的变量在各个线程的工作内存中不存在一致性的问题（在各个线程工作的内存中，volatile修饰的变量也会存在不一致的情况，但是由于每次使用之前都会先刷新主存中的数据到工作内存，执行引擎看不到不一致的情况，因此可以认为不存在不一致的问题），但是java的运算并非原子性的操作，导致volatile在并发下并非是线程安全的。</p>
<h3 id="80、ThreadLocal-是什么？有哪些使用场景？"><a href="#80、ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="80、ThreadLocal 是什么？有哪些使用场景？"></a>80、ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p>
<p>原理：线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。</p>
<h3 id="81、请谈谈-ThreadLocal-是怎么解决并发安全的？"><a href="#81、请谈谈-ThreadLocal-是怎么解决并发安全的？" class="headerlink" title="81、请谈谈 ThreadLocal 是怎么解决并发安全的？"></a>81、请谈谈 ThreadLocal 是怎么解决并发安全的？</h3><p>在java程序中，常用的有两种机制来解决多线程并发问题，一种是sychronized方式，通过锁机制，一个线程执行时，让另一个线程等待，是以时间换空间的方式来让多线程串行执行。而另外一种方式就是ThreadLocal方式，通过创建线程局部变量，以空间换时间的方式来让多线程并行执行。两种方式各有优劣，适用于不同的场景，要根据不同的业务场景来进行选择。</p>
<p>在spring的源码中，就使用了ThreadLocal来管理连接，在很多开源项目中，都经常使用ThreadLocal来控制多线程并发问题，因为它足够的简单，我们不需要关心是否有线程安全问题，因为变量是每个线程所特有的。</p>
<h3 id="82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？"><a href="#82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？" class="headerlink" title="82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？"></a>82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？</h3><p>ThreadLocal 变量解决了多线程环境下单个线程中变量的共享问题，使用名为ThreadLocalMap的哈希表进行维护（key为ThreadLocal变量名，value为ThreadLocal变量的值）；</p>
<p>使用时需要注意以下几点：</p>
<ul>
<li>线程之间的threadLocal变量是互不影响的，</li>
<li>使用private final static进行修饰，防止多实例时内存的泄露问题</li>
<li>线程池环境下使用后将threadLocal变量remove掉或设置成一个初始值</li>
</ul>
<h3 id="83、为什么代码会重排序？"><a href="#83、为什么代码会重排序？" class="headerlink" title="83、为什么代码会重排序？"></a>83、为什么代码会重排序？</h3><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ul>
<li>在单线程环境下不能改变程序运行的结果；</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>
<h3 id="84、什么是自旋"><a href="#84、什么是自旋" class="headerlink" title="84、什么是自旋"></a>84、什么是自旋</h3><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<h3 id="85、多线程中-synchronized-锁升级的原理是什么？"><a href="#85、多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="85、多线程中 synchronized 锁升级的原理是什么？"></a>85、多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="86、synchronized-和-ReentrantLock-区别是什么？"><a href="#86、synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="86、synchronized 和 ReentrantLock 区别是什么？"></a>86、synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p>
<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>相同点：两者都是可重入锁</p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li>
<li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法</li>
<li>加锁，synchronized 操作的应该是对象头中 mark word</li>
</ul>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h3 id="87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？"></a>87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>（1）可以使锁更公平</p>
<p>（2）可以使线程在等待锁的时候响应中断</p>
<p>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>（4）可以在不同的范围，以不同的顺序获取和释放锁</p>
<p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p>
<h3 id="88、jsp-和-servlet-有什么区别？"><a href="#88、jsp-和-servlet-有什么区别？" class="headerlink" title="88、jsp 和 servlet 有什么区别？"></a>88、jsp 和 servlet 有什么区别？</h3><p>（1）servlet是服务器端的Java程序，它担当客户端和服务端的中间层。</p>
<p>（2）jsp全名为Java server pages，中文名叫Java服务器页面，其本质是一个简化的servlet设计。JSP是一种动态页面设计，它的主要目的是将表示逻辑从servlet中分离出来。</p>
<p>（3）JVM只能识别Java代码，不能识别JSP，JSP编译后变成了servlet，web容器将JSP的代码编译成JVM能够识别的Java类（servlet）。</p>
<p>（4）JSP有内置对象、servlet没有内置对象。</p>
<h3 id="89、jsp-有哪些内置对象？作用分别是什么？"><a href="#89、jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="89、jsp 有哪些内置对象？作用分别是什么？"></a>89、jsp 有哪些内置对象？作用分别是什么？</h3><p>JSP九大内置对象：</p>
<ol>
<li>pageContext，页面上下文对象，相当于页面中所有功能的集合，通过它可以获取JSP页面的out、request、response、session、application对象。</li>
<li>request</li>
<li>response</li>
<li>session</li>
<li>application，应用程序对象，application实现了用户间数据的共享，可存放全局变量，它开始于服务器启动，知道服务器关闭。</li>
<li>page，就是JSP本身。</li>
<li>exception</li>
<li>out，out用于在web浏览器内输出信息，并且管理应用服务器上的输出缓冲区，作用域page。</li>
<li>config，取得服务器的配置信息。</li>
</ol>
<h3 id="90、forward-和-redirect-的区别？"><a href="#90、forward-和-redirect-的区别？" class="headerlink" title="90、forward 和 redirect 的区别？"></a>90、forward 和 redirect 的区别？</h3><ol>
<li>forward是直接请求转发；redirect是间接请求转发，又叫重定向。</li>
<li>forward，客户端和浏览器执行一次请求；redirect，客户端和浏览器执行两次请求。</li>
<li>forward，经典的MVC模式就是forward；redirect，用于避免用户的非正常访问。（例如用户非正常访问，servlet就可以将HTTP请求重定向到登录页面）。</li>
<li>forward，地址不变；redirect，地址改变。</li>
<li>forward常用方法：RequestDispatcher类的forward()方法；redirect常用方法：HttpServletRequest类的sendRedirect()方法。</li>
</ol>
<h3 id="91、说一下-jsp-的-4-种作用域？"><a href="#91、说一下-jsp-的-4-种作用域？" class="headerlink" title="91、说一下 jsp 的 4 种作用域？"></a>91、说一下 jsp 的 4 种作用域？</h3><p>application、session、request、page</p>
<h3 id="92、session-和-cookie-有什么区别？"><a href="#92、session-和-cookie-有什么区别？" class="headerlink" title="92、session 和 cookie 有什么区别？"></a>92、session 和 cookie 有什么区别？</h3><p>（1）存储位置不同</p>
<ul>
<li>cookie在客户端浏览器；</li>
<li>session在服务器；</li>
</ul>
<p>（2）存储容量不同</p>
<ul>
<li>cookie&lt;&#x3D;4K，一个站点最多保留20个cookie；</li>
<li>session没有上线，出于对服务器的保护，session内不可存过多东西，并且要设置session删除机制；</li>
</ul>
<p>（3）存储方式不同</p>
<ul>
<li>cookie只能保存ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据；</li>
<li>session中能存储任何类型的数据，包括并不局限于String、integer、list、map等；</li>
</ul>
<p>（4）隐私策略不同</p>
<ul>
<li>cookie对客户端是可见的，不安全；</li>
<li>session存储在服务器上，安全；</li>
</ul>
<p>（5）有效期不同</p>
<ul>
<li>开发可以通过设置cookie的属性，达到使cookie长期有效的效果；</li>
<li>session依赖于名为JESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session达不到长期有效的效果；</li>
</ul>
<p>（6）跨域支持上不同</p>
<ul>
<li>cookie支持跨域；</li>
<li>session不支持跨域；</li>
</ul>
<h3 id="93、如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#93、如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="93、如果客户端禁止 cookie 能实现 session 还能用吗？"></a>93、如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>一般默认情况下，在会话中，服务器存储 session 的 sessionid 是通过 cookie 存到浏览器里。</p>
<p>如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，session失效。</p>
<p>但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用session：</p>
<ol>
<li>通过url重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionid 参数。</li>
<li>服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。</li>
<li>通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。</li>
</ol>
<h3 id="94、什么是上下文切换？"><a href="#94、什么是上下文切换？" class="headerlink" title="94、什么是上下文切换？"></a>94、什么是上下文切换？</h3><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h3 id="95、cookie、session、token"><a href="#95、cookie、session、token" class="headerlink" title="95、cookie、session、token"></a>95、cookie、session、token</h3><p>1、session机制</p>
<p><a href="https://imgtu.com/i/jVoY7T"><img src="https://s1.ax1x.com/2022/06/27/jVoY7T.jpg" alt="jVoY7T.jpg"></a></p>
<p>session是服务端存储的一个对象，主要用来存储所有访问过该服务端的客户端的用户信息（也可以存储其他信息），从而实现保持用户会话状态。但是服务器重启时，内存会被销毁，存储的用户信息也就消失了。</p>
<p>不同的用户访问服务端的时候会在session对象中存储键值对，“键”用来存储开启这个用户信息的“钥匙”，在登录成功后，“钥匙”通过cookie返回给客户端，客户端存储为sessionId记录在cookie中。当客户端再次访问时，会默认携带cookie中的sessionId来实现会话机制。</p>
<p>（1）session是基于cookie的。</p>
<ul>
<li>cookie的数据4k左右；</li>
<li>cookie存储数据的格式：字符串key&#x3D;value</li>
<li>cookie存储有效期：可以自行通过expires进行具体的日期设置，如果没设置，默认是关闭浏览器时失效。</li>
<li>cookie有效范围：当前域名下有效。所以session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上（前后端项目协议、域名、端口号都一致，即在一个项目下）</li>
</ul>
<p>（2）session持久化</p>
<p>用于解决重启服务器后session消失的问题。在数据库中存储session，而不是存储在内存中。通过包：express-mysql-session。</p>
<p>当客户端存储的cookie失效后，服务端的session不会立即销毁，会有一个延时，服务端会定期清理无效session，不会造成无效数据占用存储空间的问题。</p>
<p>2、token机制</p>
<p><a href="https://imgtu.com/i/jVITkF"><img src="https://s1.ax1x.com/2022/06/27/jVITkF.jpg" alt="jVITkF.jpg"></a></p>
<p>适用于前后端分离的项目（前后端代码运行在不同的服务器下）</p>
<p>请求登录时，token和sessionid原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，会在响应主体中将{token：“字符串”}返回给客户端。</p>
<p>客户端通过cookie都可以进行存储。再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器就可以通过token信息查找用户登录状态。</p>
<h3 id="96、说一下-session-的工作原理？"><a href="#96、说一下-session-的工作原理？" class="headerlink" title="96、说一下 session 的工作原理？"></a>96、说一下 session 的工作原理？</h3><p>当客户端登录完成后，会在服务端产生一个session，此时服务端会将sessionid返回给客户端浏览器。客户端将sessionid储存在浏览器的cookie中，当用户再次登录时，会获得对应的sessionid，然后将sessionid发送到服务端请求登录，服务端在内存中找到对应的sessionid，完成登录，如果找不到，返回登录页面。</p>
<h3 id="97、http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#97、http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="97、http 响应码 301 和 302 代表的是什么？有什么区别？"></a>97、http 响应码 301 和 302 代表的是什么？有什么区别？</h3><ol>
<li>301和302状态码都表示重定向，当浏览器拿到服务器返回的这个状态码后悔自动跳转到一个新的URL地址。</li>
<li>301代表永久性重定向，旧地址被永久移除，客户端向新地址发送请求。</li>
<li>302代表暂时性重定向，旧地址还在，客户端继续向旧地址发送请求。</li>
<li>303代表暂时性重定向，重定向到新地址时，必须使用GET方法请求新地址。</li>
<li>307代表暂时性重定向，与302的区别在于307不允许从POST改为GET。</li>
<li>307代表永久性重定向，与301的区别在于308不允许从POST改为GET。</li>
</ol>
<h3 id="98、简述-tcp-和-udp的区别？"><a href="#98、简述-tcp-和-udp的区别？" class="headerlink" title="98、简述 tcp 和 udp的区别？"></a>98、简述 tcp 和 udp的区别？</h3><ol>
<li>TCP是传输控制协议，UDP是用户数据表协议；</li>
<li>TCP长连接，UDP无连接；</li>
<li>UDP程序结构较简单，只需发送，无须接收；</li>
<li>TCP可靠，保证数据正确性、顺序性；UDP不可靠，可能丢数据；</li>
<li>TCP适用于少量数据，UDP适用于大量数据传输；</li>
<li>TCP速度慢，UDP速度快；</li>
</ol>
<h3 id="99、tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#99、tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="99、tcp 为什么要三次握手，两次不行吗？为什么？"></a>99、tcp 为什么要三次握手，两次不行吗？为什么？</h3><p>因为客户端和服务端都要确认连接，①客户端请求连接服务端；②针对客户端的请求确认应答，并请求建立连接；③针对服务端的请求确认应答，建立连接；</p>
<p>两次无法确保A能收到B的数据；</p>
<h3 id="100、OSI-的七层模型都有哪些？"><a href="#100、OSI-的七层模型都有哪些？" class="headerlink" title="100、OSI 的七层模型都有哪些？"></a>100、OSI 的七层模型都有哪些？</h3><p><a href="https://imgtu.com/i/jVo5jI"><img src="https://s1.ax1x.com/2022/06/27/jVo5jI.jpg" alt="jVo5jI.jpg"></a></p>
<h3 id="101、get-和-post-请求有哪些区别？"><a href="#101、get-和-post-请求有哪些区别？" class="headerlink" title="101、get 和 post 请求有哪些区别？"></a>101、get 和 post 请求有哪些区别？</h3><ol>
<li>get请求参数是连接在url后面的,而post请求参数是存放在requestbody内的；</li>
<li>get请求因为浏览器对url长度有限制，所以参数个数有限制，而post请求参数个数没有限制；</li>
<li>因为get请求参数暴露在url上,所以安全方面post比get更加安全；</li>
<li>get请求只能进行url编码,而post请求可以支持多种编码方式；</li>
<li>get请求参数会保存在浏览器历史记录内,post请求并不会；</li>
<li>get请求浏览器会主动cache,post并不会,除非主动设置；</li>
<li>get请求产生1个tcp数据包,post请求产生2个tcp数据包；</li>
<li>在浏览器进行回退操作时,get请求是无害的,而post请求则会重新请求一次；</li>
<li>浏览器在发送get请求时会将header和data一起发送给服务器,服务器返回200状态码,而在发送post请求时,会先将header发送给服务器,服务器返回100,之后再将data发送给服务器,服务器返回200 OK；</li>
</ol>
<h3 id="102、什么是-XSS-攻击，如何避免？"><a href="#102、什么是-XSS-攻击，如何避免？" class="headerlink" title="102、什么是 XSS 攻击，如何避免？"></a>102、什么是 XSS 攻击，如何避免？</h3><p>xss(Cross Site Scripting)，即跨站脚本攻击，是一种常见于web应用程序中的计算机安全漏洞。指的是在用户浏览器上，在渲染DOM树的时候，执行了不可预期的JS脚本，从而发生了安全问题。</p>
<p>XSS就是通过在用户端注入恶意的可运行脚本，若服务端对用户的输入不进行处理，直接将用户的输入输出到浏览器，然后浏览器将会执行用户注入的脚本。 所以XSS攻击的核心就是浏览器渲染DOM的时候将文本信息解析成JS脚本从而引发JS脚本注入，那么XSS攻击的防御手段就是基于浏览器渲染这一步去做防御。只要我们使用HTML编码将浏览器需要渲染的信息编码后，浏览器在渲染DOM元素的时候，会自动解码需要渲染的信息，将上述信息解析成字符串而不是JS脚本，这就是我们防御XSS攻击的核心想法。</p>
<p>预防：</p>
<p>1、获取用户的输入，不用innerHtml,用innerText.<br>2、对用户的输入进行过滤，如对&amp; &lt; &gt; “ ‘ &#x2F;等进行转义；</p>
<h3 id="103、什么是-CSRF-攻击，如何避免？"><a href="#103、什么是-CSRF-攻击，如何避免？" class="headerlink" title="103、什么是 CSRF 攻击，如何避免？"></a>103、什么是 CSRF 攻击，如何避免？</h3><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<p>1、攻击细节</p>
<p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<p>例子</p>
<p>假如一家银行用以运行转账操作的URL地址如下：<a href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a></p>
<p>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman"></p>
<p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p>
<p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成信息的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p>
<p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。</p>
<p>2、防御措施</p>
<p>检查Referer字段</p>
<p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于<a href="http://www.examplebank.com之下.而如果是csrf攻击传来的请求,referer字段会是包含恶意网址的地址,不会位于www.examplebank.com之下,这时候服务器就能识别出恶意的访问./">www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。</a></p>
<p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p>
<p>3、添加校验token</p>
<p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>
<h3 id="104、如何实现跨域？说一下-JSONP-实现原理？"><a href="#104、如何实现跨域？说一下-JSONP-实现原理？" class="headerlink" title="104、如何实现跨域？说一下 JSONP 实现原理？"></a>104、如何实现跨域？说一下 JSONP 实现原理？</h3><p>1、<a href="https://blog.csdn.net/guorui_java/article/details/107345499">jsonp原理详解——终于搞清楚jsonp是啥了</a></p>
<p>2、最流行的跨域方案cors</p>
<p>cors是目前主流的跨域解决方案，跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>
<p>3、最方便的跨域方案Nginx</p>
<p>nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p>
<p>现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p>
<p>反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略。</p>
<h3 id="105、websocket应用的是哪个协议"><a href="#105、websocket应用的是哪个协议" class="headerlink" title="105、websocket应用的是哪个协议"></a>105、websocket应用的是哪个协议</h3><p>WebSocket是一个允许Web应用程序(通常指浏览器)与服务器进行双向通信的协议。HTML5的WebSocket API主要是为浏览器端提供了一个基于TCP协议实现全双工通信的方法。</p>
<p>WebSocket优势： 浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息。同时，服务器与客户端之间交换的头信息很小。</p>
<h3 id="106、说一下-tcp-粘包是怎么产生的？"><a href="#106、说一下-tcp-粘包是怎么产生的？" class="headerlink" title="106、说一下 tcp 粘包是怎么产生的？"></a>106、说一下 tcp 粘包是怎么产生的？</h3><p>发送方需要等缓冲区满才能发送出去，造成粘包；<br>接收方不及时接收缓冲区的包，造成粘包；</p>
<h3 id="107、请列举出在-JDK-中几个常用的设计模式？"><a href="#107、请列举出在-JDK-中几个常用的设计模式？" class="headerlink" title="107、请列举出在 JDK 中几个常用的设计模式？"></a>107、请列举出在 JDK 中几个常用的设计模式？</h3><h4 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h4><p>作用：保证类只有一个实例。</p>
<p>JDK中体现：Runtime类。</p>
<h4 id="2、静态工厂模式"><a href="#2、静态工厂模式" class="headerlink" title="2、静态工厂模式"></a>2、静态工厂模式</h4><p>作用：代替构造函数创建对象，方法名比构造函数清晰。</p>
<p>JDK中体现：Integer.valueOf、Class.forName</p>
<h4 id="3、抽象工厂"><a href="#3、抽象工厂" class="headerlink" title="3、抽象工厂"></a>3、抽象工厂</h4><p>作用：创建某一种类的对象。</p>
<p>JDK中体现：Java.sql包。</p>
<h4 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h4><p>clone()；</p>
<p>原型模式的本质是拷贝原型来创建新的对象，拷贝是比new更快的创建对象的方法，当需要大批量创建新对象而且都是同一个类的对象的时候考虑使用原型模式。</p>
<p>一般的克隆只是浅拷贝（对象的hash值不一样，但是对象里面的成员变量的hash值是一样的）。</p>
<p>有些场景需要深拷贝，这时我们就要重写clone方法，以ArrayList为例：</p>
<h4 id="5、适配器模式"><a href="#5、适配器模式" class="headerlink" title="5、适配器模式"></a>5、适配器模式</h4><p>作用：使不兼容的接口相容。</p>
<p>JDK中体现：InputStream、OutputStream。</p>
<h4 id="6、装饰器模式"><a href="#6、装饰器模式" class="headerlink" title="6、装饰器模式"></a>6、装饰器模式</h4><p>作用：为类添加新的功能，防止类继承带来的类爆炸。</p>
<p>JDK中体现：io类、Collections、List。</p>
<h4 id="7、外观模式"><a href="#7、外观模式" class="headerlink" title="7、外观模式"></a>7、外观模式</h4><p>作用：封装一组交互类，一直对外提供接口。</p>
<p>JDK中体现：logging包。</p>
<h4 id="8、享元模式"><a href="#8、享元模式" class="headerlink" title="8、享元模式"></a>8、享元模式</h4><p>作用：共享对象、节省内存。</p>
<p>JDK中体现：Integer.valueOf、String常量池。</p>
<h4 id="9、代理模式"><a href="#9、代理模式" class="headerlink" title="9、代理模式"></a>9、代理模式</h4><p>作用：</p>
<p>（1）透明调用被代理对象，无须知道复杂实现细节；</p>
<p>（2）增加被代理类的功能；</p>
<p>JDK中体现：动态代理。</p>
<h4 id="10、迭代器模式"><a href="#10、迭代器模式" class="headerlink" title="10、迭代器模式"></a>10、迭代器模式</h4><p>作用：将集合的迭代和集合本身分离。</p>
<p>JDK中体现：Iterator</p>
<h4 id="11、命令模式"><a href="#11、命令模式" class="headerlink" title="11、命令模式"></a>11、命令模式</h4><p>作用：封装操作，使接口一致。</p>
<p>JDK中体现：Runable、Callable、ThreadPoolExecutor。</p>
<h3 id="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"><a href="#108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？" class="headerlink" title="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"></a>108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？</h3><h4 id="1、什么是设计模式？"><a href="#1、什么是设计模式？" class="headerlink" title="1、什么是设计模式？"></a>1、什么是设计模式？</h4><p>设计模式是解决软件开发某些特定问题而提出的一些解决方案，也可以理解为解决问题的一些固定思路。</p>
<p>通过设计模式可以帮助我们增强代码的可复用性、可扩展性、灵活性。</p>
<p>我们使用设计模式的最终目的是实现代码的高内聚、低耦合。</p>
<h4 id="2、设计模式的七大原则"><a href="#2、设计模式的七大原则" class="headerlink" title="2、设计模式的七大原则"></a>2、设计模式的七大原则</h4><p>单一职责原则<br>接口隔离原则<br>依赖倒转原则<br>里式替换原则<br>开闭原则<br>迪米特法则<br>合成复用原则</p>
<h4 id="3、你是否在你的代码里面使用过任何设计模式？"><a href="#3、你是否在你的代码里面使用过任何设计模式？" class="headerlink" title="3、你是否在你的代码里面使用过任何设计模式？"></a>3、你是否在你的代码里面使用过任何设计模式？</h4><p>（1）单例模式</p>
<p>JDK种的runtime，Spring种的singeton。</p>
<p>（2）简单工厂模式</p>
<p>Spring的BeanFactory，根据传入一个唯一标识来获得bean对象。</p>
<p>（3）原型模式</p>
<p>clone()</p>
<p>（4）代理模式</p>
<p>Spring的AOP中，Spring实现AOP功能的原理就是代理模式，①JDK动态代理。②CGLIB动态代理，使用Advice（通知）对类进行方法级别的切面增强。</p>
<p>（5）装饰器模式</p>
<p>为类添加新的功能，防止类爆炸；</p>
<p>IO流、数据源包装，Spring中用到的装饰器模式表现在Wrapper。</p>
<h3 id="109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式"><a href="#109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式" class="headerlink" title="109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式"></a>109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</h3><ol>
<li>保证程序只有一个对象的实例，叫做单例模式；</li>
<li>内部类的方式实现单例模式，是线程安全的；</li>
<li>双重验证方式实现单例模式也是线程安全的；</li>
</ol>
<h3 id="110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？"><a href="#110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？" class="headerlink" title="110、在 Java 中，什么叫观察者设计模式（observer design pattern）？"></a>110、在 Java 中，什么叫观察者设计模式（observer design pattern）？</h3><p>1、观察者模式是一种一对多的依赖关系，让多个观察者同时监听某一主题对象。当这个主题对象发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<p>2、JAVA提供的对观察者模式的支持</p>
<p>在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。</p>
<p>（1）Observer接口</p>
<p>这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>（2）Observable类</p>
<p>被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p>
<h3 id="111、使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#111、使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="111、使用工厂模式最主要的好处是什么？在哪里使用？"></a>111、使用工厂模式最主要的好处是什么？在哪里使用？</h3><p>1、工厂模式好处</p>
<ul>
<li>良好的封装性、代码结构清晰；</li>
<li>扩展性好，如果想增加一个产品，只需扩展一个工厂类即可；</li>
<li>典型的解耦框架；</li>
</ul>
<p>2、在哪里使用？</p>
<ul>
<li>需要生成对象的地方；</li>
<li>不同数据库的访问；</li>
</ul>
<h3 id="112、请解释自动装配模式的区别？"><a href="#112、请解释自动装配模式的区别？" class="headerlink" title="112、请解释自动装配模式的区别？"></a>112、请解释自动装配模式的区别？</h3><p>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p>
<p>1、no</p>
<p>默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。第 402 页 共 485 页</p>
<p>2、byName</p>
<p>通过参数名 自动装配，Spring 容器在配置文件中发现 bean</p>
<p>的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属</p>
<p>性具有相同名字的 bean。</p>
<p>3、byType:</p>
<p>通过参数类型自动装配，Spring 容器在配置文件中发现 bean</p>
<p>的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属</p>
<p>性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</p>
<p>4、constructor</p>
<p>这个方式类似于 byType， 但是要提供给构造器参数，如</p>
<p>果没有确定的带参数的构造器参数类型，将会抛出异常。</p>
<p>5、autodetect</p>
<p>首先尝试使用 constructor 来自动装配，如果无法工作，</p>
<p>则使用 byType 方式。</p>
<h3 id="113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h3><p>在Java IO中运用了装饰器模式，inputStream作为抽象类，其下有几个实现类，表示从不同的数据源输入：</p>
<ol>
<li>byteArrayInputStream</li>
<li>fileInputStream</li>
<li>StringBufferInputStream</li>
<li>PipedInputStream，从管道产生输入；</li>
<li>SequenceInputStream，可将其他流收集合并到一个流内；</li>
</ol>
<p>FilterInputStream作为装饰器在JDK中是一个普通类，其下面有多个具体装饰器比如BufferedInputStream、DataInputStream等。</p>
<p>FilterInputStream内部封装了基础构件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br></pre></td></tr></table></figure>


<p>而BufferedInputStream在调用其read()读取数据时会委托基础构件来进行更底层的操作，而它自己所起的装饰作用就是缓冲，在源码中可以很清楚的看到这一切。</p>
<h3 id="114、什么是-Spring-框架？Spring-框架有哪些主要模块？"><a href="#114、什么是-Spring-框架？Spring-框架有哪些主要模块？" class="headerlink" title="114、什么是 Spring 框架？Spring 框架有哪些主要模块？"></a>114、什么是 Spring 框架？Spring 框架有哪些主要模块？</h3><p>Spring是一个控制反转和面向切面的容器框架。</p>
<p>Spring有七大功能模块：</p>
<p>1、Core</p>
<p>Core模块是Spring的核心类库，Core实现了IOC功能。</p>
<p>2、AOP</p>
<p>Apring AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常见的拦截器，供用户自定义和配置。</p>
<p>3、orm</p>
<p>提供对常用ORM框架的管理和支持，hibernate、mybatis等。</p>
<p>4、Dao</p>
<p>Spring提供对JDBC的支持，对JDBC进行封装。</p>
<p>5、Web</p>
<p>对Struts2的支持。</p>
<p>6、Context</p>
<p>Context模块提供框架式的Bean的访问方式，其它程序可以通过Context访问Spring的Bean资源，相当于资源注入。</p>
<p>7、MVC</p>
<p>MVC模块为spring提供了一套轻量级的MVC实现，即Spring MVC。</p>
<h3 id="115、使用-Spring-框架能带来哪些好处？"><a href="#115、使用-Spring-框架能带来哪些好处？" class="headerlink" title="115、使用 Spring 框架能带来哪些好处？"></a>115、使用 Spring 框架能带来哪些好处？</h3><p>1、轻量级框架、容器</p>
<p>Spring是一个容器，管理对象的生命周期和配置。基于一个可配置原型prototype，你的bean可以使单利的，也可以每次需要时都生成一个新的实例。</p>
<p>2、控制反转IOC</p>
<p>Spring通过控制反转实现松耦合。</p>
<p>3、支持AOP</p>
<p>Spring提供对AOP的支持，它允许将一些通用任务，如安全、事务、日志等进行集中式处理，从而提高了程序的复用性。</p>
<p>4、轻量级框架</p>
<p>5、方便测试</p>
<p>Spring提供Junit4的支持，可以通过注解方便测试spring程序。</p>
<p>6、对Java中很多API进行了封装</p>
<p>7、方便集成各种优秀框架</p>
<p>如Struts、hibernate、mybstis。</p>
<p>8、支持声明式事务处理</p>
<p>只需通过配置就可以完成对事务的管理，而无须手动编程。</p>
<h3 id="116、Spring-IOC、AOP举例说明"><a href="#116、Spring-IOC、AOP举例说明" class="headerlink" title="116、Spring IOC、AOP举例说明"></a>116、Spring IOC、AOP举例说明</h3><h4 id="1、IOC理论的背景"><a href="#1、IOC理论的背景" class="headerlink" title="1、IOC理论的背景"></a>1、IOC理论的背景</h4><p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p>
<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。<br>齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。</p>
<h4 id="2、什么是控制反转"><a href="#2、什么是控制反转" class="headerlink" title="2、什么是控制反转"></a>2、什么是控制反转</h4><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。<br>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦，如下图：</p>
<p><a href="https://imgtu.com/i/jVTJxA"><img src="https://s1.ax1x.com/2022/06/27/jVTJxA.jpg" alt="jVTJxA.jpg"></a></p>
<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。<br>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统（拿掉IoC容器后的系统）：</p>
<p><a href="https://imgtu.com/i/jVTDPg"><img src="https://s1.ax1x.com/2022/06/27/jVTDPg.jpg" alt="jVTDPg.jpg"></a></p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！<br>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：<br>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。<br>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<h4 id="3、IOC的别名：依赖注入（DI）"><a href="#3、IOC的别名：依赖注入（DI）" class="headerlink" title="3、IOC的别名：依赖注入（DI）"></a>3、IOC的别名：依赖注入（DI）</h4><p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。<br>我们举一个生活中的例子，来帮助理解依赖注入的过程。大家对USB接口和USB设备应该都很熟悉吧，USB为我们使用电脑提供了很大的方便，现在有很多的外部设备都支持USB接口。</p>
<p><a href="https://imgtu.com/i/jVTrGQ"><img src="https://s1.ax1x.com/2022/06/27/jVTrGQ.jpg" alt="jVTrGQ.jpg"></a></p>
<p>现在，我们利用电脑主机和USB接口来实现一个任务：从外部USB设备读取一个文件。<br>电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，我就起到了IOC容器的作用。<br>通过这个例子,依赖注入的思路已经非常清楚：当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。<br>我们把依赖注入应用到软件系统中，再来描述一下这个过程：<br>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。<br>在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。</p>
<h4 id="4、IOC为我们带来了什么好处"><a href="#4、IOC为我们带来了什么好处" class="headerlink" title="4、IOC为我们带来了什么好处"></a>4、IOC为我们带来了什么好处</h4><p>我们还是从USB的例子说起，使用USB外部设备比使用内置硬盘，到底带来什么好处？<br>第一、USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。所以，无论两者中的任何一方出现什么的问题，都不会影响另一方的运行。这种特性体现在软件工程中，就是可维护性比较好，非常便于进行单元测试，便于调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即可，这就是组件之间低耦合或者无耦合带来的好处。<br>第二、USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。这种特性体现在软件开发过程中，好处可是太大了。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。所以，在一个大中型项目中，团队成员分工明确、责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将得到大幅度的提高。<br>第三、同一个USB外部设备可以插接到任何支持USB的设备，可以插接到电脑主机，也可以插接到DV机，USB外部设备可以被反复利用。在软件工程中，这种特性就是可复用性好，我们可以把具有普遍性的常用组件独立出来，反复利用到项目中的其它部分，或者是其它项目，当然这也是面向对象的基本特征。显然，IOC不仅更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现，都可以插接到支持此标准的模块中。<br>第四、同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。<br>以上几点好处，难道还不足以打动我们，让我们在项目开发过程中使用IOC框架吗？</p>
<h4 id="5、IOC容器的技术剖析"><a href="#5、IOC容器的技术剖析" class="headerlink" title="5、IOC容器的技术剖析"></a>5、IOC容器的技术剖析</h4><p>IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。<br>反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。<br>我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<h4 id="6、IOC容器的一些产品"><a href="#6、IOC容器的一些产品" class="headerlink" title="6、IOC容器的一些产品"></a>6、IOC容器的一些产品</h4><p>Sun ONE技术体系下的IOC容器有：轻量级的有Spring、Guice、Pico Container、Avalon、HiveMind；重量级的有EJB；不轻不重的有JBoss，Jdon等等。Spring框架作为Java开发中SSH(Struts、Spring、Hibernate)三剑客之一，大中小项目中都有使用，非常成熟，应用广泛，EJB在关键性的工业级项目中也被使用，比如某些电信业务。<br>.Net技术体系下的IOC容器有：Spring.Net、Castle等等。Spring.Net是从Java的Spring移植过来的IOC容器，Castle的IOC容器就是Windsor部分。它们均是轻量级的框架，比较成熟，其中Spring.Net已经被逐渐应用于各种项目中。</p>
<h4 id="7、使用IOC框架应该注意什么"><a href="#7、使用IOC框架应该注意什么" class="headerlink" title="7、使用IOC框架应该注意什么"></a>7、使用IOC框架应该注意什么</h4><p>使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p>
<p>（1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p>
<p>（2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p>
<p>（3）、具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p>
<p>（4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。<br>我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，象WEB2.0网站就是这种情况。</p>
<h3 id="117、什么是控制反转-IOC-？什么是依赖注入？"><a href="#117、什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="117、什么是控制反转(IOC)？什么是依赖注入？"></a>117、什么是控制反转(IOC)？什么是依赖注入？</h3><p>借助Spring实现具有依赖关系的对象之间的解耦。</p>
<p>对象A运行需要对象B，由主动创建变为IOC容器注入，这便是控制反转。</p>
<p>获得依赖对象的过程被反转了，获取依赖对象的过程由自身创建变为由IOC容器注入，这便是依赖注入。</p>
<h3 id="118、BeanFactory-和-ApplicationContext-有什么区别？"><a href="#118、BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="118、BeanFactory 和 ApplicationContext 有什么区别？"></a>118、BeanFactory 和 ApplicationContext 有什么区别？</h3><p>1、BeanFactory是Spring的最底层接口，包含bean的定义，管理bean的加载，实例化，控制bean的生命周期，特点是每次获取对象时才会创建对象。</p>
<p>ApplicationContext是BeanFactory的子接口，拥有BeanFactory的全部功能，并且扩展了很多高级特性，每次容器启动时就会创建所有的对象。</p>
<ol>
<li>ApplicationContext的额外功能：</li>
<li>继承MessageSource，支持国际化；</li>
<li>统一的资源文件访问方式；</li>
<li>提供在监听器中注册bean；</li>
<li>同时加载过个配置文件；</li>
<li>载入多个（有继承关系）上下文，使得每个上下文都专注于一个特定的层次，比如应用的web层；</li>
</ol>
<p>2、BeanFactory通常以编程的方式被创建，ApplicationContext可以以声明的方式创建，如使用ContextLoader。</p>
<p>3、BeanFactory 和 ApplicationContext都支持BeanPostProcessor，BeanFactoryPostProcessor，但BeanFactory需要手动注册，ApplicationContext则是自动注册。</p>
<h3 id="119、什么是-JavaConfig？"><a href="#119、什么是-JavaConfig？" class="headerlink" title="119、什么是 JavaConfig？"></a>119、什么是 JavaConfig？</h3><p>JavaConfig是Spring3.0新增的概念，就是以注解的形式取代Spring中繁琐的xml文件。</p>
<p>JavaConfig结合了xml的解耦和java编译时检查的优点。</p>
<ol>
<li>@Configuration，表示这个类是配置类；</li>
<li>@ComponentScan，相当于xml的&lt;context:componentScan basepackage&#x3D;&gt;；</li>
<li>@Bean，相当于xml的<bean id="student" class="com.guor.entity">；</li>
<li>@EnableWebMvc，相当于xml的<a href="mvc:annotation-driven">mvc:annotation-driven</a>；</li>
<li>@ImportResource，相当于xml的<import resource="application-context-cache.xml">；</li>
<li>@PropertySource，用于读取properties配置文件；</li>
<li>@Profile，一般用于多环境配置，激活时可用@ActiveProfile(“dev”)注解；</li>
</ol>
<h3 id="120、什么是-ORM-框架？"><a href="#120、什么是-ORM-框架？" class="headerlink" title="120、什么是 ORM 框架？"></a>120、什么是 ORM 框架？</h3><p>ORM（Object-relational mapping），对象关系映射。</p>
<p>是为了解决面向对象与关系型数据库存在的不匹配问题。</p>
<p>ORM框架的优点：</p>
<ol>
<li>开发效率更高</li>
<li>数据访问更抽象、轻便</li>
<li>支持面向对象封装</li>
</ol>
<h3 id="121、Spring-有几种配置方式？"><a href="#121、Spring-有几种配置方式？" class="headerlink" title="121、Spring 有几种配置方式？"></a>121、Spring 有几种配置方式？</h3><p>1、xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jackma&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tyq.dto.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jackma&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jm&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tyq.dto.Dog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jack&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;breed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;金毛&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、基于注解的方式</p>
<p>项目越来越大，基于xml配置太麻烦，Spring 2.x时代提供了声明bean的注解。</p>
<p>（1）Bean的定义</p>
<p>@Component、@Controller、@Service、@Repository。</p>
<p>（2）Bean的注入</p>
<p>@Autowire</p>
<p>3、基于Java的方式</p>
<p>Spring 3.x以后，可以通过Java代码装配Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">zs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//两个狗</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">haqi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;zs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get，set方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 原来就是配置类啊，通过@Bean、@Component、getBean方式进行Bean的注册和发现。</p>
<h3 id="122、请解释-Spring-Bean-的生命周期？"><a href="#122、请解释-Spring-Bean-的生命周期？" class="headerlink" title="122、请解释 Spring Bean 的生命周期？"></a>122、请解释 Spring Bean 的生命周期？</h3><ol>
<li>通过构造器或工厂方法创建bean实例；</li>
<li>为bean的属性赋值；</li>
<li>调用bean的初始化方法；</li>
<li>使用bean；</li>
<li>当容器关闭时，调用bean的销毁方法；</li>
</ol>
<h3 id="123、Spring-Bean-的作用域之间有什么区别？"><a href="#123、Spring-Bean-的作用域之间有什么区别？" class="headerlink" title="123、Spring Bean 的作用域之间有什么区别？"></a>123、Spring Bean 的作用域之间有什么区别？</h3><h4 id="Spring容器中的bean可以分为5个范围："><a href="#Spring容器中的bean可以分为5个范围：" class="headerlink" title="Spring容器中的bean可以分为5个范围："></a>Spring容器中的bean可以分为5个范围：</h4><ol>
<li>singleton：这种bean范围是默认的，这种范围确保不管接受多少请求，每个容器中只哟一个bean的实例，单例模式；</li>
<li>prototype：为每一个bean提供一个实例；</li>
<li>request：在请求bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完毕后，bean会失效并被垃圾回收器回收；</li>
<li>session：为每个session创建一个实例，session过期后，bean会随之消失；</li>
<li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet公用全局的存储变量的话，那么全局变量需要存储在global-session中。</li>
</ol>
<h3 id="124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="124、如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>124、如何在 Spring Boot 中禁用 Actuator 端点安全性？</h3><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有Actuator角色的用户才能访问它们。安全性是使用标准的HTTPServletRequest.isUserInRole方法实施的。我们可以使用management.security.enable &#x3D; false来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h3 id="125、什么是-Spring-inner-beans？"><a href="#125、什么是-Spring-inner-beans？" class="headerlink" title="125、什么是 Spring inner beans？"></a>125、什么是 Spring inner beans？</h3><p>在Spring框架中，无论何时bean被使用时，当仅被调用一个属性。可以将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们要做的是创建一个Person实例，然后再Customer内部使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;CustomerBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Customer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.person&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">1</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;素小暖&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">18</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="126、Spring-框架中的单例-Beans-是线程安全的么？"><a href="#126、Spring-框架中的单例-Beans-是线程安全的么？" class="headerlink" title="126、Spring 框架中的单例 Beans 是线程安全的么？"></a>126、Spring 框架中的单例 Beans 是线程安全的么？</h3><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态，所以在某种程度上说Spring的单例bean时线程安全的。如果你的bean有多种状态的话，比如view model，就需要自行保证线程安全啦。</p>
<p>最浅显的解决办法就是将多态bean的作用域由singleton变更为prototype。</p>
<h3 id="127、请解释-Spring-Bean-的自动装配？"><a href="#127、请解释-Spring-Bean-的自动装配？" class="headerlink" title="127、请解释 Spring Bean 的自动装配？"></a>127、请解释 Spring Bean 的自动装配？</h3><p>Spring支持IOC，自动装配不用类实例化，直接从bean容器中取。</p>
<p>1、配置在xml中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employeeDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.guor.EmployeeDAOImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、@Autowired自动装配</p>
<h3 id="128、如何开启基于注解的自动装配？"><a href="#128、如何开启基于注解的自动装配？" class="headerlink" title="128、如何开启基于注解的自动装配？"></a>128、如何开启基于注解的自动装配？</h3><p>要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：</p>
<p>引入配置文件中的<bean>下引入 <a href="context:annotation-config">context:annotation-config</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:annotation-config /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="129、什么是-Spring-Batch？"><a href="#129、什么是-Spring-Batch？" class="headerlink" title="129、什么是 Spring Batch？"></a>129、什么是 Spring Batch？</h3><p>1、什么是spring batch?</p>
<p>spring batch是一个轻量级的、完善的批处理框架，它主要的目的在于帮助企业建立健壮、高效的批处理应用。</p>
<p>spring batch是Spring的一个子项目，它使用java语言并基于spring框架作为基础开发，使得已经使用Spring框架的开发者或者是企业可以更加容易访问和利用企业服务。</p>
<p>spring batch提供了大量可重用的组件,包括了日志、追踪、事务、任务作业统计、任务重启、跳过、重复、资源管理。</p>
<p>对大数据量和高性能的批处理任务，spring batch同样提供了高级功能和特性来支持。</p>
<p>例如：分区功能、远程功能。</p>
<p>总的来说，spring batch可以支持简单的、复杂的和大数据量的批处理作业。</p>
<p>2、spring batch业务场景</p>
<p>周期性的提交批处理</p>
<p>把一个任务并行处理</p>
<p>消息驱动应用分级处理</p>
<p>大规模并行批处理</p>
<p>手工或调度使任务失败之后重新启动</p>
<p>有依赖步骤的顺序执行(使用工作流驱动扩展)</p>
<p>处理时跳过部分记录</p>
<p>成批事务：为小批量的或有的存储过程&#x2F;脚本的场景使用</p>
<h3 id="130、spring-mvc-和-struts-的区别是什么？"><a href="#130、spring-mvc-和-struts-的区别是什么？" class="headerlink" title="130、spring mvc 和 struts 的区别是什么？"></a>130、spring mvc 和 struts 的区别是什么？</h3><p>1、拦截机制的不同</p>
<p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p>
<p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p>
<p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>2、底层框架的不同</p>
<p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p>
<p>3、性能方面</p>
<p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p>
<p>4、配置方面</p>
<p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p>
<h3 id="131、请举例解释-Required-注解？"><a href="#131、请举例解释-Required-注解？" class="headerlink" title="131、请举例解释@Required 注解？"></a>131、请举例解释@Required 注解？</h3><p>@Required注解应用于bean属性的setter方法，它表明影响的bean属性在配置时必须放在XML配置文件中。</p>
<p>十九、请举例说明@Qualifier 注解？<br>如果在xml中定义了一种类型的多个bean，同时在java注解中又想把其中一个bean对象作为属性，那么此时可以使用@Qualifier加@Autowired来达到这一目的，若不加@Qualifier这个注解，在运行时会出现“ No qualifying bean of type [com.tutorialspoint.Student] is defined: expected single matching bean but found 2: student1,student2”这个异常。</p>
<h3 id="132、Spring常用注解"><a href="#132、Spring常用注解" class="headerlink" title="132、Spring常用注解"></a>132、Spring常用注解</h3><p><a href="https://blog.csdn.net/guorui_java/article/details/107347754">Spring常用注解（绝对经典）</a></p>
<h3 id="133、项目中是如何实现权限验证的，权限验证需要几张表"><a href="#133、项目中是如何实现权限验证的，权限验证需要几张表" class="headerlink" title="133、项目中是如何实现权限验证的，权限验证需要几张表"></a>133、项目中是如何实现权限验证的，权限验证需要几张表</h3><p>通过了解，现在最普遍的权限管理模型就是RBAC（Role-Based Access Control）。</p>
<p>1、权限控制分类</p>
<p>菜单功能<br>url控制（控制访问不同的控制器）<br>2、RBAC的优缺点</p>
<p>（1）优点</p>
<p>简化了用户和权限的关系<br>易扩展、易维护</p>
<p>（2）缺点</p>
<p>RBAC模型没有提供操作顺序的控制机制，这一缺陷使得RBAC模型很难适应哪些对操作次序有严格要求的系统。</p>
<p>3、RBAC支持的安全原则</p>
<p>（1）最小权限原则</p>
<p>RBAC可以将角色配置成其完成任务所需的最小权限集合。</p>
<p>（2）责任分离原则</p>
<p>可以通过调用相互独立互斥的角色来共同完成敏感的任务，例如要求一个记账员和财务管理员共同参与统一过账操作。</p>
<p>（3）数据抽象原则</p>
<p>可以通过权限的抽象来体现，例如财务操作用借款、存款等抽象权限，而不是使用典型的读写权限。</p>
<p>4、远古时代的权限控制</p>
<p>当时还没有RBAC，也没有这个概念，就是一堆程序员在那鼓捣，觉得登录这块该做点什么。</p>
<p><a href="https://imgtu.com/i/jV7rTK"><img src="https://s1.ax1x.com/2022/06/27/jV7rTK.jpg" alt="jV7rTK.jpg"></a></p>
<blockquote>
<p>1、新建一个用户，对这个用户进行赋予权限。</p>
<p>2、但是一旦用户多了，权限复杂了，这工作量也是蛮大的。</p>
</blockquote>
<p>5、RBAC</p>
<p>RBAC 1.0</p>
<p><a href="https://imgtu.com/i/jV76YD"><img src="https://s1.ax1x.com/2022/06/27/jV76YD.jpg" alt="jV76YD.jpg"></a></p>
<p><a href="https://imgtu.com/i/jV7cfe"><img src="https://s1.ax1x.com/2022/06/27/jV7cfe.jpg" alt="jV7cfe.jpg"></a></p>
<p>直接上图，一目了然，当程序不是很复杂的时候，RBAC就是这样设计的，我们公司的权限验证模块就是这样设计的。</p>
<p>简简单单，五张表，解</p>
<p>RBAC 2.0</p>
<p>基于RBAC 1.0模型的基础上，进行了角色的访问控制</p>
<p><a href="https://imgtu.com/i/jV7yFO"><img src="https://s1.ax1x.com/2022/06/27/jV7yFO.jpg" alt="jV7yFO.jpg"></a></p>
<p>RBAC2中的一个基本限制是互斥角色的限制，互斥角色是指各自权限可以互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。</p>
<p>该模型有以下几种约束</p>
<ul>
<li>互斥角色 ：同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自权限互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。常举的例子：在审计活动中，一个角色不能同时被指派给会计角色和审计员角色。</li>
<li>基数约束 ：一个角色被分配的用户数量受限；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配。</li>
<li>先决条件角色 ：可以分配角色给用户仅当该用户已经是另一角色的成员；对应的可以分配访问权限给角色，仅当该角色已经拥有另一种访问权限。指要想获得较高的权限，要首先拥有低一级的权限。</li>
<li>运行时互斥 ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。</li>
</ul>
<p>6、rbac的实现理论分析</p>
<p>进入登录页面；<br>拿到通过post传过来的用户名和密码；<br>使用orm进行过滤查找；<br>如果能找到值，则说明登录成功：登录成功后调用rbac初始化函数，初始化函数的主要功能是获取用户的权限和菜单保存到session中，并跳转客户列表页面；如果失败，页面进行友好提示；</p>
<p>7、url权限控制关键代码</p>
<p><a href="https://imgtu.com/i/jV7Dw6"><img src="https://s1.ax1x.com/2022/06/27/jV7Dw6.jpg" alt="jV7Dw6.jpg"></a></p>
<h3 id="134、谈谈controller，接口调用的路径问题"><a href="#134、谈谈controller，接口调用的路径问题" class="headerlink" title="134、谈谈controller，接口调用的路径问题"></a>134、谈谈controller，接口调用的路径问题</h3><p>1、Spring MVC如何匹配请求路径</p>
<p>@RequestMapping是用来映射请求的，比如get请求、post请求、或者REST风格与非REST风格的。该注解可以用在类上或方法上，如果用在类上，表示是该类中所有方法的父路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/springmvc&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCTest</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testRequestMapping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在类上还添加了一个@Controller注解，该注解在SpringMVC中负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个model，然后再把该model返回给对应的view进行展示。</p>
<p>我们可以通过“springmvc&#x2F;testRequestMapping”这个路径来定位到testRequestMapping这个方法，然后执行方法内的方法体。</p>
<p>RequestMapping可以实现模糊匹配路径，比如：</p>
<ol>
<li>？表示一个字符；</li>
<li>*表示任意字符；</li>
<li>** 匹配多层路径；</li>
</ol>
<p>&#x2F;springmvc&#x2F;**&#x2F;testRequestMapping 就可以匹配&#x2F;springmvc&#x2F;stu&#x2F;getStudentInfo&#x2F;testRequestMapping 这样的路径了。</p>
<p>2、SpringMVC如何获取请求的参数</p>
<p>（1）@PathVariable</p>
<p>该注解用来映射请求URL中绑定的占位符。通过@PathVariable可以将URL中占位符的参数绑定到controller处理方法的入参中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPathVariable</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testPathVariable:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在index.jsp中我们添加一条连接，用来触发一个请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/testPathVariable/1&quot;</span>&gt;</span>testPathVariable<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>（2） @RequestParam</p>
<p>该注解也是用来获取请求参数的，那么该注解和@PathVariable有什么不同呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRequestParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(value=&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(value=&quot;age&quot;, required=false, defaultValue=&quot;0&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testRequestParam&quot;</span> + <span class="string">&quot; username:&quot;</span> + username + <span class="string">&quot; age:&quot;</span> +age);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在index.jsp添加超链接标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/testRequestParam?username=jackie&amp;age=12&quot;</span>&gt;</span>testRequestParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>3、REST风格的请求</p>
<p>在SpringMVC中业务最多的应该是CRUD了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestPut</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test put:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestDelete</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test delete:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test post&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test get:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="135、如何防止表单重复提交"><a href="#135、如何防止表单重复提交" class="headerlink" title="135、如何防止表单重复提交"></a>135、如何防止表单重复提交</h3><p>1、通过JavaScript屏蔽提交按钮（不推荐）</p>
<p>2、给数据库增加唯一键约束（简单粗暴）</p>
<p>3、利用Session防止表单重复提交（推荐）</p>
<p>4、使用AOP自定义切入实现</p>
<h3 id="136、Spring中都应用了哪些设计模式"><a href="#136、Spring中都应用了哪些设计模式" class="headerlink" title="136、Spring中都应用了哪些设计模式"></a>136、Spring中都应用了哪些设计模式</h3><h4 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h4><p>简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。</p>
<p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。</p>
<h4 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h4><p>应用程序将对象的创建及初始化职责交给工厂对象，工厂Bean。</p>
<p>定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory-method指定静态方法名称。</p>
<h4 id="3、单例模式"><a href="#3、单例模式" class="headerlink" title="3、单例模式"></a>3、单例模式</h4><p>Spring用的是双重判断加锁的单例模式，通过getSingleton方法从singletonObjects中获取bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h4><p>Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（① JDK动态代理，② CGLIB字节码生成技术代理。）对类进行方法级别的切面增强。</p>
<h4 id="5、装饰器模式"><a href="#5、装饰器模式" class="headerlink" title="5、装饰器模式"></a>5、装饰器模式</h4><p>装饰器模式：动态的给一个对象添加一些额外的功能。</p>
<p>Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。</p>
<p>在Spring中有两种表现：</p>
<p>一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<h4 id="6、观察者模式"><a href="#6、观察者模式" class="headerlink" title="6、观察者模式"></a>6、观察者模式</h4><p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p>
<p>Spring中观察者模式一般用在listener的实现。</p>
<h4 id="7、策略模式"><a href="#7、策略模式" class="headerlink" title="7、策略模式"></a>7、策略模式</h4><p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p>
<p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p>
<h4 id="8、模板方法模式"><a href="#8、模板方法模式" class="headerlink" title="8、模板方法模式"></a>8、模板方法模式</h4><p>Spring JdbcTemplate的query方法总体结构是一个模板方法+回调函数，query方法中调用的execute()是一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。</p>
<h3 id="137、请举例说明如何在-Spring-中注入一个-Java-Collection？"><a href="#137、请举例说明如何在-Spring-中注入一个-Java-Collection？" class="headerlink" title="137、请举例说明如何在 Spring 中注入一个 Java Collection？"></a>137、请举例说明如何在 Spring 中注入一个 Java Collection？</h3><p>Spring注入有四种方式:</p>
<ol>
<li>set注入；</li>
<li>构造器注入；</li>
<li>基于注解的注入；</li>
<li>xml配置文件注入；</li>
</ol>
<p>想要注入java collection，就是注入集合类：</p>
<ol>
<li>list</li>
<li>set</li>
<li>map</li>
<li>props：该标签支持注入键和值都是字符串类型的键值对。</li>
</ol>
<p>list和set都使用value标签；map使用entry标签；props使用prop标签；</p>
<h3 id="138、mybatis-中-和-的区别是什么？"><a href="#138、mybatis-中-和-的区别是什么？" class="headerlink" title="138、mybatis 中 #{}和 ${}的区别是什么？"></a>138、mybatis 中 #{}和 ${}的区别是什么？</h3><ol>
<li>#{}带引号，${}不带引号；</li>
<li>#{}可以防止SQL注入；</li>
<li>${}常用于数据库表名、order by子句；</li>
<li>一般能用#{}就不要使用${}；</li>
</ol>
<h3 id="139、mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#139、mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="139、mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>139、mybatis 是否支持延迟加载？延迟加载的原理是什么？</h3><h4 id="1、mybatis-是否支持延迟加载？"><a href="#1、mybatis-是否支持延迟加载？" class="headerlink" title="1、mybatis 是否支持延迟加载？"></a>1、mybatis 是否支持延迟加载？</h4><p>延迟加载其实就是讲数据加载时机推迟，比如推迟嵌套查询的时机。</p>
<p>延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。</p>
<p>mybatis仅支持关联对象association和关联集合对象collection的延迟加载，association是一对一，collection是一对多查询，在mybatis配置文件中可以配置lazyloadingEnable&#x3D;true&#x2F;false。</p>
<h4 id="2、延迟加载的原理是什么？"><a href="#2、延迟加载的原理是什么？" class="headerlink" title="2、延迟加载的原理是什么？"></a>2、延迟加载的原理是什么？</h4><p>使用CGLIB为目标对象建立代理对象，当调用目标对象的方法时进入拦截器方法。</p>
<p>比如调用a.getB().getName()，拦截器方法invoke()发现a.getB()为null，会单独发送事先准备好的查询关联B对象的sql语句，把B查询出来然后调用a.setB(b)，也是a的对象的属性b就有值了，然后调用getName()，这就是延迟加载的原理。</p>
<h3 id="140、说一下-mybatis-的一级缓存和二级缓存？"><a href="#140、说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="140、说一下 mybatis 的一级缓存和二级缓存？"></a>140、说一下 mybatis 的一级缓存和二级缓存？</h3><p>一级缓存是session级别的缓存，默认开启，当查询一次数据库时，对查询结果进行缓存，如果之后的查询在一级缓存中存在，则无需再访问数据库；</p>
<p>二级缓存是sessionFactory级别的缓存，需要配置才会开启。当进行sql语句查询时，先查看二级缓存，如果不存在，访问一级缓存，降低数据库访问压力。</p>
<h3 id="141、mybatis-有哪些执行器（Executor）？"><a href="#141、mybatis-有哪些执行器（Executor）？" class="headerlink" title="141、mybatis 有哪些执行器（Executor）？"></a>141、mybatis 有哪些执行器（Executor）？</h3><p>1、mybatis有三种基本的Executor执行器：</p>
<p>（1）、SimpleExecutor</p>
<p>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p>（2）、PauseExecutor</p>
<p>执行update或select，以sql做为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而且放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p>（3）、BatchExecutor</p>
<p>执行update，将所有sql通过addBatch()都添加到批处理中，等待统一执行executeBatch()，它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>2、作用范围：</p>
<p>Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<p>3、Mybatis中如何指定使用哪一种Executor执行器？</p>
<p>在mybatis的配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<h3 id="142、mybatis-和-hibernate-的区别有哪些？"><a href="#142、mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="142、mybatis 和 hibernate 的区别有哪些？"></a>142、mybatis 和 hibernate 的区别有哪些？</h3><p>1、两者最大的区别</p>
<p>针对简单逻辑，都有对应的代码生成工具，可以生成简单基本的dao层方法；</p>
<p>针对高级查询，mybatis要手动编写sql语句和resultMap，而hibernate有良好的映射机制；</p>
<p>2、开发难度对比</p>
<p>hibernate &gt; mybatis </p>
<p>3、日志统计</p>
<p>hibernate有自己的日志统计功能，而mybatis需要借助log4j来记录日志。</p>
<p>4、数据库扩展比较</p>
<p>hibernate &gt; mybatis </p>
<p>5、缓存机制比较</p>
<p>因为hibernate对查询对象有良好的管理机制，用户无需关心sql，所以使用二级缓存如果出现脏数据，系统会报错。</p>
<p>而mybatis，如果不能获取最新数据，应该避免缓存的使用，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>6、如何选择</p>
<p>mybatis需要编写sql和映射规则，工作量大于hibernate；<br>mybatis支持的工具也有限，不能像hibernate那样有许多插件可以帮助生成映射代码和关联关系；<br>对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐hibernate；<br>对于性能要求高、响应快、灵活的系统，比如电商系统，推荐使用mybatis；</p>
<h3 id="143、myBatis查询多个id、myBatis常用属性"><a href="#143、myBatis查询多个id、myBatis常用属性" class="headerlink" title="143、myBatis查询多个id、myBatis常用属性"></a>143、myBatis查询多个id、myBatis常用属性</h3><p>myBatis查询多个id（我居然回答用对象来传递…）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Page&lt;UserPoJo&gt;  <span class="title function_">getUserListByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--根据id列表批量查询user--&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;getUserListByIds&quot;</span> resultType=<span class="string">&quot;com.guor.UserPoJo&quot;</span>&gt;</span><br><span class="line">    select * from student</span><br><span class="line">    where id in</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;ids&quot;</span> item=<span class="string">&quot;userid&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">        #&#123;userid&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>



<h3 id="144、mybatis一级缓存、二级缓存"><a href="#144、mybatis一级缓存、二级缓存" class="headerlink" title="144、mybatis一级缓存、二级缓存"></a>144、mybatis一级缓存、二级缓存</h3><p>1、一级缓存：指的是mybatis中sqlSession对象的缓存，当我们执行查询以后，查询的结果会同时存入sqlSession中，再次查询的时候，先去sqlSession中查询，有的话直接拿出，当sqlSession消失时，mybatis的一级缓存也就消失了，当调用sqlSession的修改、添加、删除、commit()、close()等方法时，会清空一级缓存。</p>
<p>2、二级缓存：指的是mybatis中的sqlSessionFactory对象的缓存，由同一个sqlSessionFactory对象创建的sqlSession共享其缓存，但是其中缓存的是数据而不是对象。当命中二级缓存时，通过存储的数据构造成对象返回。查询数据的时候，查询的流程是二级缓存 &gt; 一级缓存 &gt; 数据库。</p>
<p>3、如果开启了二级缓存，sqlSession进行close()后，才会把sqlSession一级缓存中的数据添加到二级缓存中，为了将缓存数据取出执行反序列化，还需要将要缓存的pojo实现Serializable接口，因为二级缓存数据存储介质多种多样，不一定只存在内存中，也可能存在硬盘中。</p>
<p>4、mybatis框架主要是围绕sqlSessionFactory进行的，具体的步骤：</p>
<ol>
<li>定义一个configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings。</li>
<li>通过配置对象，则可以创建一个sqlSessionFactoryBuilder对象。</li>
<li>通过sqlSessionFactoryBuilder获得sqlSessionFactory实例。</li>
<li>通过sqlSessionFactory实例创建qlSession实例，通过sqlSession对数据库进行操作。</li>
</ol>
<p>5、代码实例</p>
<p>mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!-- 加载类路径下的属性文件 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置类型别名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atapathy.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置一个默认的连接环境信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_developer&quot;</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">        <span class="comment">&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_developer&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;jdbc&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.driver&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">        <span class="comment">&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;oracle_developer&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;jdbc&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.driver&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.url&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.username&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.password&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!-- 加载映射文件--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;cn/itcast/javaee/mybatis/app14/StudentMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取mybatis-config.xml文件</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//初始化mybatis,创建SqlSessionFactory类的实例</span></span><br><span class="line">            <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">            <span class="comment">//创建session实例</span></span><br><span class="line">            <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 接下来在这里做很多事情,到目前为止,目的已经达到得到了SqlSession对象.通过调用SqlSession里面的方法,</span></span><br><span class="line"><span class="comment">             * 可以测试MyBatis和Dao层接口方法之间的正确性,当然也可以做别的很多事情,在这里就不列举了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//插入数据</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setC_password(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            user.setC_username(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            user.setC_salt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            <span class="comment">//第一个参数为方法的完全限定名:位置信息+映射文件当中的id</span></span><br><span class="line">            session.insert(<span class="string">&quot;com.cn.dao.UserMapping.insertUserInformation&quot;</span>, user);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            session.commit();</span><br><span class="line">            <span class="comment">//关闭session</span></span><br><span class="line">            session.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="145、mybatis如何防止sql注入"><a href="#145、mybatis如何防止sql注入" class="headerlink" title="145、mybatis如何防止sql注入"></a>145、mybatis如何防止sql注入</h3><p>注意：但凡是sql注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成sql语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的【外部数据不可信任】的原则，纵观web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到，就是变量的检测、过滤、验证下手，确保变量是开发者所预想的。</p>
<p>1、检查变量数据类型和格式</p>
<p>数据类型检查，sql执行前，要进行数据类型检查，如果是邮箱，参数就必须是邮箱的格式，如果是日期，就必须是日期格式；</p>
<p>只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。</p>
<p>如果上述例子中id是int型的，效果会怎样呢？无法注入，因为输入注入参数会失败。比如上述中的name字段，我们应该在用户注册的时候，就确定一个用户名规则，比如5-20个字符，只能由大小写字母、数字以及汉字组成，不包含特殊字符。此时我们应该有一个函数来完成统一的用户名检查。不过，仍然有很多场景并不能用到这个方法，比如写博客，评论系统，弹幕系统，必须允许用户可以提交任意形式的字符才行，否则用户体验感太差了。</p>
<p>2、过滤特殊符号</p>
<p>3、绑定变量，使用预编译语句</p>
<h3 id="146、为什么要使用-hibernate？"><a href="#146、为什么要使用-hibernate？" class="headerlink" title="146、为什么要使用 hibernate？"></a>146、为什么要使用 hibernate？</h3><ol>
<li>hibernate对jdbc进行了封装，简化了JDBC的重复性代码；</li>
<li>hibernate对dao有一个封装类hibernateTemplate，可以继承它，实现简单的CRUD接口。</li>
<li>hibernate使用注解和配置文件，可以对实体类和映射文件进行映射；</li>
<li>hibernate有事务管理机制，保证了数据的安全性；</li>
<li>hibernate有一级缓存和二级缓存；</li>
</ol>
<h4 id="146-1、hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#146-1、hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="146.1、hibernate 中如何在控制台查看打印的 sql 语句？"></a>146.1、hibernate 中如何在控制台查看打印的 sql 语句？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.show_sql=<span class="literal">true</span></span><br><span class="line">spring.jpa.properties.hibernate.format_sql=<span class="literal">true</span></span><br><span class="line">spring.jpa.properties.hibernate.use_sql_comments=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="147、hibernate-有几种查询方式？"><a href="#147、hibernate-有几种查询方式？" class="headerlink" title="147、hibernate 有几种查询方式？"></a>147、hibernate 有几种查询方式？</h3><p>1、导航对象图查询：根据已加载的对象，导航到其他对象。</p>
<p>例如，对于已经加载的Customer对象，调用它的getOrders().iterator()方法就可以导航到所有关联的Order对象，假如在关联级别使用了延迟加载检索策略，那么首次执行此方法时，hibernate会从数据库中加载关联的Order对象，否则就从缓存中获得Order对象。</p>
<p>2、OID方式：按照对象的OID来检索对象</p>
<p>Session的get()和load()方法提供了这种功能，如果在应用程序中先知道了OID，就可以使用这种方式检索对象。</p>
<p>get()和load()的用法完全一样，都需要两个参数，一个是持久化对象类名class，一个是行号OID，返回固定的某一行的数据，但是需要注意的是，当输入的OID不存在时，get()会返回一个空对象，load()则直接报错。</p>
<p>3、HQL检索方式：（hibernate query language）</p>
<p>使用面向对象的HQL查询语言，session的find()方法用于执行HQL查询语句。此外，hibernate还提供了query接口，它是hibernate提供的专门的HQL查询接口，能够执行各种复杂的HQL查询语句。</p>
<p>它具备以下功能：</p>
<ol>
<li>在查询语句中设定各种查询条件；</li>
<li>支持投影查询，即仅检索出对象的部分属性；</li>
<li>支持分页查询；</li>
<li>支持连接查询；</li>
<li>支持分组查询；</li>
<li>提供内置函数；</li>
<li>能够调用用户自定义的SQL函数；</li>
<li>支持子查询；</li>
<li>支持动态绑定参数；</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(“from UserPo”）；</span><br></pre></td></tr></table></figure>


<p>获得一个query对象，注意参数字符串中不是一个SQL语句，from后面的是持久化对象名称；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br></pre></td></tr></table></figure>


<p>就可以获取数据库中对应表的数据集合。</p>
<p>4、QBC检索方式：Query By Criteria的API来检索对象</p>
<p>这种API封装了基于字符串形式的查询语句，提供了更加面向对象的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例：<span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> session.createCriteria(UserPo.class);</span><br></pre></td></tr></table></figure>


<p>创建一个Criteria对象，参数是所关联的持久化对象，criteria.add(Restrictions.ge(“id”,2));将查询条件加入对象中，后面的操作就和Query对象一样了。</p>
<p>5、本地SQL</p>
<p>使用本地数据库的SQL查询语句，hibernate会负责把检索到的JDBC ResultSet结果映射为持久化对象图。</p>
<h3 id="148、hibernate-实体类可以被定义为-final-吗？"><a href="#148、hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="148、hibernate 实体类可以被定义为 final 吗？"></a>148、hibernate 实体类可以被定义为 final 吗？</h3><p>可以将hibernate的实体类定义为final，但这种做法不好。</p>
<p>因为hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为Java不允许对final类进行扩展，所以hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。</p>
<p>不过，如果你的持久化类实现了一个接口，而且在该接口中声明了所有定义于实体类中的所有public的方法的话，就能避免出现前面所说的不利后果。</p>
<h3 id="149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h3><p>hibernate是面向对象的ORM，所以一般定义成封装类型，要看数据库中的定义，如果数据库中有对应字段存在null值，就要定义Integer。也可以定义基本类型，在配置文件中写清楚即可。</p>
<h3 id="150、什么是-Spring-Boot？Spring-Boot-有哪些优点？"><a href="#150、什么是-Spring-Boot？Spring-Boot-有哪些优点？" class="headerlink" title="150、什么是 Spring Boot？Spring Boot 有哪些优点？"></a>150、什么是 Spring Boot？Spring Boot 有哪些优点？</h3><h4 id="1、Spring-Boot简介"><a href="#1、Spring-Boot简介" class="headerlink" title="1、Spring Boot简介"></a>1、Spring Boot简介</h4><p>基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突、引用的不稳定性得到了解决。</p>
<h4 id="2、Spring-Boot-有哪些优点？"><a href="#2、Spring-Boot-有哪些优点？" class="headerlink" title="2、Spring Boot 有哪些优点？"></a>2、Spring Boot 有哪些优点？</h4><ol>
<li>快速构建项目，可以选一些必要的组件；</li>
<li>对主流框架的无配置集成；</li>
<li>内嵌Tomcat容器，项目可独立运行；</li>
<li>删除了繁琐的xml配置文件；</li>
<li>极大地提高了开发和部署效率；</li>
<li>提供starter，简化maven配置；</li>
</ol>
<h4 id="3、SpringBoot有哪些缺点？"><a href="#3、SpringBoot有哪些缺点？" class="headerlink" title="3、SpringBoot有哪些缺点？"></a>3、SpringBoot有哪些缺点？</h4><ol>
<li>版本迭代速度快，一些模块改动很大；</li>
<li>由于无须配置，报错时很难定位；</li>
</ol>
<h3 id="151、Spring-Boot-中的监视器是什么？"><a href="#151、Spring-Boot-中的监视器是什么？" class="headerlink" title="151、Spring Boot 中的监视器是什么？"></a>151、Spring Boot 中的监视器是什么？</h3><p>监听器也叫listener，是servlet的监听器，可以用于监听web应用程序中某些对象的创建、销毁、增加、修改、删除等动作的发生，然后做出相应的响应处理。当范围对象的状态发生变化时，服务器自动调用监听器对象中的方法，常用于系统加载时进行信息初始化，统计在线人数和在线用户，统计网站的访问量。</p>
<p>配置监听器的方法：</p>
<p>通过@Component把监听器加入Spring容器中管理；<br>在application.properties中添加context.listener.classes配置；<br>在方法上加@EventListener注解；</p>
<h3 id="152、什么是-YAML？"><a href="#152、什么是-YAML？" class="headerlink" title="152、什么是 YAML？"></a>152、什么是 YAML？</h3><p>YAML是JSON的一个超集，可以非常方便地将外部配置以层次结构形式存储起来。YAML可以作为properties配置文件的替代。</p>
<p>YAML使用的注意事项：</p>
<ol>
<li>在properties文件中是以”.”进行分割的，在yml中是用”.”进行分割的；</li>
<li>yml的数据格式和json的格式很像，都是K-V格式，并且通过”:”进行赋值；</li>
<li>每个冒号后面一定要加一个空格；</li>
</ol>
<h3 id="153、如何使用-Spring-Boot-实现分页和排序？"><a href="#153、如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="153、如何使用 Spring Boot 实现分页和排序？"></a>153、如何使用 Spring Boot 实现分页和排序？</h3><p>使用Spring Data Jpa可以实现将可分页的传递给存储库方法。</p>
<h3 id="154、如何使用-Spring-Boot-实现异常处理？"><a href="#154、如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="154、如何使用 Spring Boot 实现异常处理？"></a>154、如何使用 Spring Boot 实现异常处理？</h3><p>1、使用 @ExceptionHandler 注解处理局部异常(只能处理当前controller中的ArithmeticException和NullPointerException异常，缺点就是只能处理单个controller的异常)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerController</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/excep&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exceptionMethod</span><span class="params">(Model model)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	String a=<span class="literal">null</span>;</span><br><span class="line">	System.out.println(a.charAt(<span class="number">1</span>));</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;没有抛出异常&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ExceptionHandler(value = &#123;ArithmeticException.class,NullPointerException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">arithmeticExceptionHandle</span><span class="params">(Model model, Exception e)</span> &#123;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;@ExceptionHandler&quot;</span> + e.getMessage());</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>2、使用 @ControllerAdvice + @ExceptionHandler 注解处理全局异常(value后面可以填写数组)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerAdviceException</span> &#123;<span class="meta">@ExceptionHandler(value = &#123;NullPointerException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">NullPointerExceptionHandler</span><span class="params">(Model model, Exception e)</span> &#123;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;@ControllerAdvice + @ExceptionHandler :&quot;</span> + e.getMessage());</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>3、配置 SimpleMappingExceptionResolver 类处理异常（配置类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMappingException</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">getSimpleMappingExceptionResolver</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">SimpleMappingExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	<span class="comment">//第一个参数为异常全限定名，第二个为跳转视图名称</span></span><br><span class="line">	mappings.put(<span class="string">&quot;java.lang.NullPointerException&quot;</span>, <span class="string">&quot;index&quot;</span>);</span><br><span class="line">	mappings.put(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="string">&quot;index&quot;</span>);</span><br><span class="line">	<span class="comment">//设置异常与视图映射信息的</span></span><br><span class="line">	resolver.setExceptionMappings(mappings);</span><br><span class="line">	<span class="keyword">return</span> resolver;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、实现 HandlerExceptionResolver 接口处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerException</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">	<span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">	modelAndView.addObject(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;实现HandlerExceptionResolver接口&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//判断不同异常类型，做不同视图跳转</span></span><br><span class="line">	<span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NullPointerException)&#123;</span><br><span class="line">		modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ArithmeticException)&#123;</span><br><span class="line">		modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="155、单点登录"><a href="#155、单点登录" class="headerlink" title="155、单点登录"></a>155、单点登录</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>单点登录SSO，说的是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。</p>
<h4 id="2、单点登录的要点"><a href="#2、单点登录的要点" class="headerlink" title="2、单点登录的要点"></a>2、单点登录的要点</h4><p>存储信任；<br>验证信任；</p>
<h4 id="3、实现单点登录的三种方式"><a href="#3、实现单点登录的三种方式" class="headerlink" title="3、实现单点登录的三种方式"></a>3、实现单点登录的三种方式</h4><p>（1）以cookie作为凭证</p>
<p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。</p>
<p>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie进行校验，校验通过则登录当前用户。</p>
<p>缺点：</p>
<p>cookie不安全</p>
<p>通过加密可以保证安全性，但如果对方掌握了解密算法就完蛋了。</p>
<p>不能跨域实现免登</p>
<p>（2）通过JSONP实现</p>
<p>对于跨域问题，可以使用JSONP实现。用户在父应用中登录后，跟session匹配的cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>
<p>缺点：</p>
<p>这种方法虽然能解决跨域问题，但是治标不治本，没有解决cookie安全性的问题。</p>
<p>（3）通过页面重定向的方式</p>
<p>最后一种介绍的方式，是通过父应用和子应用来回重定向进行通信，实现信息的安全传递。</p>
<p>父应用提供一个GET方式的登录接口A（此时的父应用接口固定，攻击者无法去伪造），用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个登录页面，用户输入账号密码进行登录，如果用户已经登录了，则生成加密的token，并且重定向到子应用提供的验证token的接口B（此时的子应用接口固定，攻击者无法去伪造），通过解密和校验之后，子应用登录当前用户。</p>
<p>缺点：</p>
<p>这种方式较前面的两种方式，是解决了安全性和跨域的问题，但是并没有前面两种方式简单，安全与方便，本来就是矛盾的。</p>
<h4 id="4、使用独立登录系统"><a href="#4、使用独立登录系统" class="headerlink" title="4、使用独立登录系统"></a>4、使用独立登录系统</h4><p>一般来说，大型应用会把授权的逻辑和用户信息的相关逻辑独立成一个应用，称为用户中心。用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕后返回凭证，第三方应用验证凭证，通过后就登录用户。</p>
<h4 id="5、sso（单点登录）与OAuth2-0（授权）的区别？"><a href="#5、sso（单点登录）与OAuth2-0（授权）的区别？" class="headerlink" title="5、sso（单点登录）与OAuth2.0（授权）的区别？"></a>5、sso（单点登录）与OAuth2.0（授权）的区别？</h4><p>（1）sso（单点登录）</p>
<p>通常处理的是一个公司的不同应用间的访问登录问题，如企业应用有很多子系统，只需登录一个系统，就可以实现不同子系统间的跳转，而避免了登录操作；<br>通过cookie、jsonp、重定向来实现；</p>
<p>（2）OAuth2.0（授权）</p>
<p>解决的是服务提供方（如微信）给第三方应用授权的问题，简称微信登录；<br>是一种具体的协议，只是为用户资源的授权提供了一个安全的、开放的而又简易的标准，OAuth2.0（授权）为客户开发者开发web应用，桌面应用程序，移动应用及客厅设备提供特定的授权流程。</p>
<h3 id="156、Spring-Boot比Spring多哪些注解"><a href="#156、Spring-Boot比Spring多哪些注解" class="headerlink" title="156、Spring Boot比Spring多哪些注解"></a>156、Spring Boot比Spring多哪些注解</h3><p><a href="https://blog.csdn.net/guorui_java/article/details/107379648">Spring Boot常用注解（绝对经典）</a></p>
<h3 id="157、打包和部署"><a href="#157、打包和部署" class="headerlink" title="157、打包和部署"></a>157、打包和部署</h3><p>Spring和Spring Boot都支持maven和Gradle通用打包管理技术。</p>
<p>Spring Boot相对Spring的一些优点：</p>
<p>提供嵌入式容器支持；<br>使用命令java -jar独立运行jar；<br>部署时可以灵活指定配置文件；<br>最近项目是分布式的项目，都是通过分项目打包部署，然后部署在docker中运行。</p>
<h3 id="158、Spring-Boot如何访问不同的数据库"><a href="#158、Spring-Boot如何访问不同的数据库" class="headerlink" title="158、Spring Boot如何访问不同的数据库"></a>158、Spring Boot如何访问不同的数据库</h3><p>可以使用druidDataSource创建DataSource，然后通过jdbcTemplate执行sql。</p>
<h3 id="159、查询网站在线人数"><a href="#159、查询网站在线人数" class="headerlink" title="159、查询网站在线人数"></a>159、查询网站在线人数</h3><p>通过监听session对象的方式来实现在线人数的统计和在线人信息展示，并且让超时的自动销毁。</p>
<blockquote>
<p>对session对象实现监听，首先必须继承HttpSessionListener类，该程序的基本原理就是当浏览器访问页面的时候必定会产生一个session对象，当关闭该页面的时候必然会删除session对象。所以每当产生一个新的session对象就让在线人数+1，当删除一个session对象就让在线人数-1。</p>
<p>还要继承一个HttpSessionAttributeListener，来实现对其属性的监听。分别实现attributeAdded方法，attributeReplace方法以及attributeRemove方法。</p>
<p>sessionCreated&#x2F;&#x2F;新建一个会话的时候触发，也可以说是客户端第一次喝服务器交互时触发。</p>
<p>sessionDestroyed&#x2F;&#x2F;销毁会话的时候，一般来说只有某个按钮触发进行销毁，或者配置定时销毁。</p>
<p>HttpSessionAttributeListener有三个方法需要实现</p>
<p>attributeAdded&#x2F;&#x2F;在session中添加对象时触发此操作 笼统的说就是调用setAttribute这个方法时候会触发的<br>attributeRemoved&#x2F;&#x2F;修改、删除session中添加对象时触发此操作  笼统的说就是调用 removeAttribute这个方法时候会触发的<br>attributeReplaced&#x2F;&#x2F;在Session属性被重新设置时。</p>
</blockquote>
<h3 id="160、easyExcel如何实现"><a href="#160、easyExcel如何实现" class="headerlink" title="160、easyExcel如何实现"></a>160、easyExcel如何实现</h3><p>异步读取<br>新建一个  ExcelModelListener 监听类出来，并且 继承 AnalysisEventListener 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zh.oukele.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.zh.oukele.model.ExcelMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelModelListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;ExcelMode&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      List&lt;ExcelMode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ExcelMode&gt;();</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(ExcelMode data, AnalysisContext context)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;解析到一条数据:&#123; &quot;</span>+ data.toString() +<span class="string">&quot; &#125;&quot;</span>);</span><br><span class="line">      list.add(data);</span><br><span class="line">      count ++;</span><br><span class="line">      <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">          saveData( count );</span><br><span class="line">          list.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">       saveData( count );</span><br><span class="line">       System.out.println(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot; count ：&quot;</span> + count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 加上存储数据库</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;&#123; &quot;</span>+ count +<span class="string">&quot; &#125;条数据，开始存储数据库！&quot;</span> + list.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="161、什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#161、什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="161、什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>161、什么是 Swagger？你用 Spring Boot 实现了它吗？</h3><p>Swagger是用于生成RestFul Web服务的可视化表示工具，它使文档和服务器可视化更新；</p>
<p>当定义好Swagger后，可以调用服务端接口，来查看接口的返回值，验证返回数据的正确性；</p>
<h3 id="162、数据库的三范式是什么？"><a href="#162、数据库的三范式是什么？" class="headerlink" title="162、数据库的三范式是什么？"></a>162、数据库的三范式是什么？</h3><p>1、列不可再分；</p>
<p>2、每一行数据只做一件事，只与一列相关，主键；</p>
<p>3、每个属性都与主键有直接关系，而不是间接关系；</p>
<p>三大范式只是设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情结，当然要特殊对待，数据库设计最重要的是看需求和性能，需求&gt;性能&gt;表结构。</p>
<p>所以不能一味的追求三范式建立数据库。</p>
<h3 id="163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？"><a href="#163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？"></a>163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</h3><p>一般情况下，我们创建的表类型是InnoDB。</p>
<p>不重启MySQL，如果新增一条记录，id是8；<br>重启，ID是6；因为InnoDB表只把自增主键的最大ID记录在内存中，如果重启，已删除的最大ID会丢失。<br>如果表类型是MyISAM，重启之后，最大ID也不会丢失，ID是8；</p>
<p>InnoDB必须有主键（建议使用自增主键，不用UUID，自增主键索引查询效率高）、支持外键、支持事务、支持行级锁。</p>
<p>系统崩溃后，MyISAM很难恢复；</p>
<p>综合考虑，优先选择InnoDB，MySQL默认也是InnoDB。</p>
<h3 id="164、如何获取当前数据库版本？"><a href="#164、如何获取当前数据库版本？" class="headerlink" title="164、如何获取当前数据库版本？"></a>164、如何获取当前数据库版本？</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>MySQL,,mysql <span class="operator">-</span>v</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Oracle </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$version;</span><br></pre></td></tr></table></figure>

<h3 id="165、说一下-ACID-是什么？"><a href="#165、说一下-ACID-是什么？" class="headerlink" title="165、说一下 ACID 是什么？"></a>165、说一下 ACID 是什么？</h3><p>ACID是数据库事务执行的四大基本要素，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<p>1、原子性</p>
<p>整个事务中的所有操作，要么全部完成，要不全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被roolback回滚到事务开始前的状态，就像这个事务从未执行过一样。</p>
<p>2、一致性</p>
<p>事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</p>
<p>3、隔离性</p>
<p>隔离状态执行事务，使他们好像是系统在给定时间内执行的唯一操作。</p>
<p>如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性确保每一个事务在系统中认为只有自己在使用系统。这种属性称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p>
<p>4、持久性</p>
<p>一个成功的事务将永久的改变系统的状态。</p>
<h3 id="166、char-和-varchar-的区别是什么？"><a href="#166、char-和-varchar-的区别是什么？" class="headerlink" title="166、char 和 varchar 的区别是什么？"></a>166、char 和 varchar 的区别是什么？</h3><ol>
<li>char的长度是固定的，varchar的长度的可变的；</li>
<li>char的效率比varchar的效率高；</li>
<li>char占用空间比varchar大，char在查询时需要使用trim；</li>
</ol>
<h3 id="167、float-和-double-的区别是什么？"><a href="#167、float-和-double-的区别是什么？" class="headerlink" title="167、float 和 double 的区别是什么？"></a>167、float 和 double 的区别是什么？</h3><p>1、float 和 double 的区别是什么？</p>
<p>（1）内存中占有的字节数不同</p>
<p>单精度浮点数在内存中占有4个字节；</p>
<p>双精度浮点数在内存中占有8个字节；</p>
<p>（2）有效数字位数不同</p>
<p>单精度浮点数有效数字8位；</p>
<p>双精度浮点数有效数字16位；</p>
<p>（3）数值取值范围不同</p>
<p>单精度浮点数的表示范围：-3.40E+38~3.40E+38</p>
<p>双精度浮点数的表示范围：-1.79E+308~-1.79E+308</p>
<p>（4）在程序中处理速度不同</p>
<p>一般来说，CPU处理单精度浮点数的速度比双精度浮点数的速度快</p>
<p>如果不声明，默认小数是double类型，如果想用float，要进行强转；</p>
<p>2、例如</p>
<p>float f &#x3D; 1.3；会编译报错，正确的写法是float f &#x3D; (float)1.3;或者float a &#x3D; 1.3f;（f或F都可以不区分大小写）</p>
<p>3、注意</p>
<p>float是八位有效数字，第七位会四舍五入；</p>
<p>4、面试题</p>
<p>（1）java中3*0.1&#x3D;&#x3D;0.3将会返回什么？true还是false？</p>
<p>答：返回false，因为浮点数不能完全精确的表示出来，一般会损失精度；</p>
<p>（2）java中float f &#x3D; 3.4;是否正确？</p>
<p>答：不正确。因为3.4是双精度浮点数，将双精度赋给单精度属于向下转型，会造成精度损失，因此需要强制类型转换float&#x3D;（float）3.4;或者写成float f &#x3D; 3.4f;</p>
<h3 id="168、Oracle分页sql"><a href="#168、Oracle分页sql" class="headerlink" title="168、Oracle分页sql"></a>168、Oracle分页sql</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#不带排序的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> ROWNUM <span class="keyword">AS</span> rowno, t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">where</span> ROWNUM <span class="operator">&lt;=</span><span class="number">20</span>) table_alias </span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno <span class="operator">&gt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#带排序的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> tt.<span class="operator">*</span>, ROWNUM <span class="keyword">AS</span> rowno <span class="keyword">FROM</span> (  </span><br><span class="line"><span class="keyword">SELECT</span> t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">ORDER</span> <span class="keyword">BY</span> wkid <span class="keyword">aSC</span>) tt <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">20</span>) table_alias </span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="169、数据库如何保证主键唯一性"><a href="#169、数据库如何保证主键唯一性" class="headerlink" title="169、数据库如何保证主键唯一性"></a>169、数据库如何保证主键唯一性</h3><p>1、主键约束</p>
<p>主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）；</p>
<p>2、唯一性约束</p>
<p>保证一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一性约束允许为null，但是只能有一行；</p>
<p>3、唯一性索引</p>
<p>不允许具有索引值相同的行，从而禁止重复的索引和键值；</p>
<p>4、三者的区别</p>
<p>约束是用来检查数据的正确性；<br>索引是用来优化查询的；<br>创建唯一性约束会创建一个约束和一个唯一性索引；<br>创建唯一性索引只会创建一个唯一性索引；<br>主键约束和唯一性约束都会创建一个唯一性索引。</p>
<h3 id="170、如何设计数据库"><a href="#170、如何设计数据库" class="headerlink" title="170、如何设计数据库"></a>170、如何设计数据库</h3><p>1、数据库设计最起码要占用这个项目开发的40%以上的时间</p>
<p>2、数据库设计不仅仅停留在页面demo的表面</p>
<p>页面内容所需字段，在数据库设计中只是一部分，还有系统运转、模块交互、中转数据、表之间的联系等等所需要的字段，因此数据库设计绝对不是简单的基本数据存储，还有逻辑数据存储。</p>
<p>3、数据库设计完成后，项目80%的设计开发都要存在你的脑海中</p>
<p>每个字段的设计都要有他存在的意义，要清楚的知道程序中如何去运用这些字段，多张表的联系在程序中是如何体现的。</p>
<p>4、数据库设计时就要考虑效率和优化问题</p>
<p>数据量大的表示粗粒度的，会冗余一些必要字段，达到用最少的表，最弱的表关系去存储海量的数据。大数据的表要建立索引，方便查询。对于含有计算、数据交互、统计这类需求时，还有考虑是否有必要采用存储过程。</p>
<p>5、添加必要的冗余字段</p>
<p>像创建时间、修改时间、操作用户IP、备注这些字段，在每张表中最好都有，一些冗余的字段便于日后维护、分析、拓展而添加。</p>
<p>6、设计合理的表关联 </p>
<p>若两张表之间的关系复杂，建议采用第三张映射表来关联维护两张表之间的关系，以降低表之间的直接耦合度。</p>
<p>7、设计表时不加主外键等约束关联，系统编码阶段完成后再添加约束性关联</p>
<p>8、选择合适的主键生成策略</p>
<p>数据库的设计难度其实比单纯的技术实现难很多，他充分体现了一个人的全局设计能力和掌控能力，最后说一句，数据库设计，很重要，很复杂。</p>
<h3 id="171、性别是否适合做索引"><a href="#171、性别是否适合做索引" class="headerlink" title="171、性别是否适合做索引"></a>171、性别是否适合做索引</h3><p>区分度不高的字段不适合做索引，因为索引页是需要有开销的，需要存储的，不过这类字段可以做联合索引的一部分。</p>
<h3 id="172、如何查询重复的数据"><a href="#172、如何查询重复的数据" class="headerlink" title="172、如何查询重复的数据"></a>172、如何查询重复的数据</h3><p>1、查询重复的单个字段（group by）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>2、查询重复的多个字段（group by）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, 重复字段B, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A, 重复字段B <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="173、数据库一般会采取什么样的优化方法？"><a href="#173、数据库一般会采取什么样的优化方法？" class="headerlink" title="173、数据库一般会采取什么样的优化方法？"></a>173、数据库一般会采取什么样的优化方法？</h3><p>1、选取适合的字段属性</p>
<ul>
<li>为了获取更好的性能，可以将表中的字段宽度设得尽可能小。</li>
<li>尽量把字段设置成not null</li>
<li>执行查询的时候，数据库不用去比较null值。</li>
<li>对某些省份或者性别字段，将他们定义为enum类型，enum类型被当做数值型数据来处理，而数值型数据被处理起来的速度要比文本类型块很多。</li>
</ul>
<p>2、使用join连接代替子查询</p>
<p>3、使用联合union来代替手动创建的临时表</p>
<p>注意：union用法中，两个select语句的字段类型要匹配，而且字段个数要相同。</p>
<p>4、事务</p>
<p>要么都成功，要么都失败。</p>
<p>可以保证数据库中数据的一致性和完整性。事务以begin开始，commit关键字结束。</p>
<p>如果出错，rollback命令可以将数据库恢复到begin开始之前的状态。</p>
<p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方式为用户提供一种安全的访问方式，这样就可以保证用户的操作不被其他的用户干扰。</p>
<p>5、锁定表</p>
<p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在大应用中。</p>
<p>由于在事务执行的过程中，数据库会被锁定，因此其它用户只能暂时等待直到事务结束。</p>
<p>有的时候可以用锁定表的方法来获得更好的性能，</p>
<p>共享锁：其它用户只能看，不能修改</p>
<p>lock table person in share mode；</p>
<p>对于通过lock table 命令主动添加的锁来说，如果要释放它们，只需发出rollback命令即可。</p>
<p>6、使用外键</p>
<p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性，这个时候可以使用外键。</p>
<p>7、使用索引</p>
<p>索引是提高数据库查询速度的常用方法，尤其是查询语句中包含max()、min()、order by这些命令的时候，性能提高更为显著。</p>
<p>一般来说索引应该建在常用于join、where、order by的字段上。尽量不要对数据库中含有大量重复的值得字段建立索引。</p>
<p>8、优化的查询语句</p>
<p>在索引的字段上尽量不要使用函数进行操作。</p>
<p>尽量不要使用like关键字和通配符，这样做法很简单，但却是以牺牲性能为代价的。</p>
<p>避免在查询中进行自动类型转换，因为类型转换也会使索引失效。</p>
<h3 id="174、索引怎么定义，分哪几种"><a href="#174、索引怎么定义，分哪几种" class="headerlink" title="174、索引怎么定义，分哪几种"></a>174、索引怎么定义，分哪几种</h3><ol>
<li>b-tree索引，如果不建立索引的情况下，oracle就自动给每一列都加一个B 树索引;</li>
<li>normal：普通索引</li>
<li>unique：唯一索引</li>
<li>bitmap：位图索引，位图索引特定于只有几个枚举值的情况，比如性别字段；</li>
<li>基于函数的索引</li>
</ol>
<h3 id="175、mysql-的内连接、左连接、右连接有什么区别？"><a href="#175、mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="175、mysql 的内连接、左连接、右连接有什么区别？"></a>175、mysql 的内连接、左连接、右连接有什么区别？</h3><ol>
<li>内连接,显示两个表中有联系的所有数据;</li>
<li>左链接,以左表为参照,显示所有数据,右表中没有则以null显示</li>
<li>右链接,以右表为参照显示数据，,左表中没有则以null显示</li>
</ol>
<h3 id="176、RabbitMQ的使用场景有哪些？"><a href="#176、RabbitMQ的使用场景有哪些？" class="headerlink" title="176、RabbitMQ的使用场景有哪些？"></a>176、RabbitMQ的使用场景有哪些？</h3><p>1、解决异步问题</p>
<p>例如用户注册，发送邮件和短信反馈注册成功，可以使用RabbitMQ消息队列，用户无需等待反馈。</p>
<p>2、服务间解耦</p>
<p>订单系统和库存系统，中间加入RabbitMQ消息队列，当库存系统出现问题时，订单系统依旧能正常使用，降低服务间耦合度。</p>
<p>3、秒杀系统</p>
<p>利用RabbitMQ的最大值，实现秒杀系统。</p>
<h3 id="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"><a href="#177、RabbitMQ有哪些重要的角色？有哪些重要的组件？" class="headerlink" title="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"></a>177、RabbitMQ有哪些重要的角色？有哪些重要的组件？</h3><p>1、RabbitMQ有哪些重要的角色？</p>
<p>客户端、RabbitMQ、服务端。</p>
<p>2、有哪些重要的组件？</p>
<p>（1）connectionFactory（连接管理器）</p>
<p>应用程序与RabbitMQ之间建立连接的管理器。</p>
<p>（2）Channel（信道）</p>
<p>消息推送使用的信道。</p>
<p>（3）RoutingKey（路由键）</p>
<p>用于把生产者的数据分配到交换机上。</p>
<p>（4）Exchange（交换机）</p>
<p>用于接受和分配消息。</p>
<p>（5）BindKey（绑定键）</p>
<p>用于把交换机的消息绑定到队列上</p>
<p>（6）Queue（队列）</p>
<p>用于存储生产者消息。</p>
<h3 id="178、RabbitMQ中-vhost-的作用是什么？"><a href="#178、RabbitMQ中-vhost-的作用是什么？" class="headerlink" title="178、RabbitMQ中 vhost 的作用是什么？"></a>178、RabbitMQ中 vhost 的作用是什么？</h3><p>vhost可以理解为mini版的RabbitMQ，其内部均含有独立的交换机、绑定、队列，最重要的是拥有独立的权限系统，可以做到vhost范围内的用户控制。从RabbitMQ全局考虑，不同的应用可以跑在不同的vhost上，作为不同权限隔离的手段。</p>
<h3 id="179、说一下-jvm-的主要组成部分？及其作用？"><a href="#179、说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="179、说一下 jvm 的主要组成部分？及其作用？"></a>179、说一下 jvm 的主要组成部分？及其作用？</h3><p>JVM包括类加载子系统、堆、方法区、栈、本地方法栈、程序计数器、直接内存、垃圾回收器、执行引擎。</p>
<p>1、类加载子系统</p>
<p>类加载子系统负责加载class信息，加载的类信息存放于方法区中。</p>
<p>2、直接内存</p>
<p>直接内存是在Java堆外的、直接向系统申请的内存空间。访问直接内存的速度会由于Java堆。出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。</p>
<p>3、垃圾回收器</p>
<p>垃圾回收器可以对堆、方法区、直接内存进行回收。</p>
<p>4、执行引擎</p>
<p>执行引擎负责执行虚拟机的字节码，虚拟机会使用即时编译技术将方法编译成机器码后再执行。</p>
<h3 id="180、说一下-jvm-运行时数据区？"><a href="#180、说一下-jvm-运行时数据区？" class="headerlink" title="180、说一下 jvm 运行时数据区？"></a>180、说一下 jvm 运行时数据区？</h3><p>运行时数据区包括堆、方法区、栈、本地方法栈、程序计数器。</p>
<p>1、堆</p>
<p>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</p>
<p>2、方法区</p>
<p>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</p>
<p>3、栈</p>
<p>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>（1）栈帧</p>
<p>每个方法从调用到执行的过程就是一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>（2）局部变量表</p>
<p>用于保存函数的参数和局部变量。</p>
<p>（3）操作数栈</p>
<p>操作数栈又称操作栈，大多数指令都是从这里弹出数据，执行运算，然后把结果压回操作数栈。</p>
<p>4、本地方法栈</p>
<p>与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</p>
<p>5、程序计数器（PC寄存器）</p>
<p>程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p>
<h3 id="181、什么是类加载器，类加载器有哪些？"><a href="#181、什么是类加载器，类加载器有哪些？" class="headerlink" title="181、什么是类加载器，类加载器有哪些？"></a>181、什么是类加载器，类加载器有哪些？</h3><p><a href="https://imgtu.com/i/jVqiLR"><img src="https://s1.ax1x.com/2022/06/27/jVqiLR.jpg" alt="jVqiLR.jpg"></a></p>
<p>1、什么是类加载器？</p>
<p>类加载器负责加载所有的类，其为所有被载入内存的类生成一个java.lang.Class实例对象。</p>
<p>2、类加载器有哪些？</p>
<p>JVM有三种类加载器：</p>
<p>（1）启动类加载器</p>
<p>该类没有父加载器，用来加载Java的核心类，启动类加载器的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并不继承自java.lang.classLoader。</p>
<p>（2）扩展类加载器</p>
<p>它的父类为启动类加载器，扩展类加载器是纯java类，是ClassLoader类的子类，负责加载JRE的扩展目录。</p>
<p>（3）应用程序类加载器</p>
<p>它的父类为扩展类加载器，它从环境变量classpath或者系统属性java.lang.path所指定的目录中加载类，它是自定义的类加载器的父加载器。</p>
<h3 id="182、说一下类加载的执行过程？"><a href="#182、说一下类加载的执行过程？" class="headerlink" title="182、说一下类加载的执行过程？"></a>182、说一下类加载的执行过程？</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，JVM会通过加载、连接、初始化3个步骤对该类进行类加载。</p>
<p>1、加载</p>
<p>加载指的是将类的class文件读入到内存中，并为之创建一个java.lang.Class对象。</p>
<p>类的加载由类加载器完成，类加载器由JVM提供，开发者也可以通过继承ClassLoader基类来创建自己的类加载器。</p>
<p>通过使用不同的类加载器可以从不同来源加载类的二进制数据，通常有如下几种来源：</p>
<ol>
<li>从本地文件系统加载</li>
<li>从jar包加载</li>
<li>通过网络加载</li>
<li>把一个Java源文件动态编译，并执行加载</li>
</ol>
<p>2、连接</p>
<p>当类被加载之后，系统为之生成一个对应的Class对象，接着进入连接阶段，连接阶段负责将类的二进制数据合并到JRE中。</p>
<p>类连接又可分为三个阶段：</p>
<p>（1）验证</p>
<p>文件格式验证<br>元数据验证<br>字节码验证<br>符号引用验证</p>
<p>（2）准备</p>
<p>为类的静态变量分配内存，并设置默认初始值。</p>
<p>（3）解析</p>
<p>将类的二进制数据中的符号引用替换成直接引用。</p>
<p>3、初始化</p>
<p>为类的静态变量赋予初始值。</p>
<h3 id="183、JVM的类加载机制是什么？"><a href="#183、JVM的类加载机制是什么？" class="headerlink" title="183、JVM的类加载机制是什么？"></a>183、JVM的类加载机制是什么？</h3><p>JVM类加载机制主要有三种：</p>
<p>1、全盘负责</p>
<p>类加载器加载某个class时，该class所依赖的和引用其它的class也由该类加载器载入。</p>
<p>2、双亲委派</p>
<p>先让父加载器加载该class，父加载器无法加载时才考虑自己加载。</p>
<p>3、缓存机制</p>
<p>缓存机制保证所有加载过的class都会被缓存，当程序中需要某个class时，先从缓存区中搜索，如果不存在，才会读取该类对应的二进制数据，并将其转换成class对象，存入缓存区中。</p>
<p>这就是为什么修改了class后，必须重启JVM，程序所做的修改才会生效的原因。</p>
<h3 id="184、什么是双亲委派模型？"><a href="#184、什么是双亲委派模型？" class="headerlink" title="184、什么是双亲委派模型？"></a>184、什么是双亲委派模型？</h3><p>如果一个类收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器执行，如果父加载器还存在其父加载器，则进一步向上委托，依次递归，请求将最终到达顶层的启动类加载器，如果父类加载器可以完成父加载任务，就成功返回，如果父加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模型。</p>
<p>双亲委派模式的优势：</p>
<ol>
<li>避免重复加载；</li>
<li>考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委派模式传递到启动加载器，而启动加载器在核心Java API中发现同名的类，发现该类已经被加载，就不会重新加载网络传递的Integer类，而直接返回已加载过的Integer.class，这样可以防止核心API库被随意篡改。</li>
</ol>
<h3 id="185、怎么判断对象是否可以被回收？"><a href="#185、怎么判断对象是否可以被回收？" class="headerlink" title="185、怎么判断对象是否可以被回收？"></a>185、怎么判断对象是否可以被回收？</h3><p>1、引用计数算法</p>
<p>（1）判断对象的引用数量</p>
<p>通过判断对象的引用数量来决定对象是否可以被回收；<br>每个对象实例都有一个引用计数器，被引用+1，完成引用-1；<br>任何引用计数为0的对象实例可以被当做垃圾回收；</p>
<p>（2）优缺点</p>
<p>优点：执行效率高，程序受影响较小；<br>缺点：无法检测出循环引用的情况，导致内存泄漏；</p>
<p>2、可达性分析算法</p>
<p>通过判断对象的引用链是否可达来决定对象是否可以被回收。</p>
<p>如果程序无法再引用该对象，那么这个对象肯定可以被回收，这个状态称为不可达。</p>
<p>那么不可达状态如何判断呢？</p>
<p>答案是GC roots，也就是根对象，如果一个对象无法到达根对象的路径，或者说从根对象无法引用到该对象，该对象就是不可达的。</p>
<p>以下三种对象在JVM中被称为GC roots，来判断一个对象是否可以被回收。</p>
<p>（1）虚拟机栈的栈帧</p>
<p>每个方法在执行的时候，JVM都会创建一个相应的栈帧（操作数栈、局部变量表、运行时常量池的引用），当方法执行完，该栈帧就从栈中弹出，这样一来，方法中临时创建的独享就不存在了，或者说没有任何GC roots指向这些临时对象，这些对象在下一次GC的时候便会被回收。</p>
<p>（2）方法区中的静态属性</p>
<p>静态属性数据类属性，不属于任何实例，因此该属性自然会作为GC roots。这要这个class在，该引用指向的对象就一直存在，class也由被回收的时候。</p>
<p>class何时会被回收？</p>
<p>堆中不存在该类的任何实例<br>加载该类的classLoader已经被回收<br>该类的java.lang.class对象没有在任何地方被引用，也就是说无法通过反射访问该类的信息<br>（3）本地方法栈引用的对象</p>
<h3 id="186、说一下-jvm-有哪些垃圾回收算法？"><a href="#186、说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="186、说一下 jvm 有哪些垃圾回收算法？"></a>186、说一下 jvm 有哪些垃圾回收算法？</h3><p>1、对象是否已死算法</p>
<ul>
<li>引用计数器算法</li>
<li>可达性分析算法</li>
</ul>
<p>2、GC算法</p>
<p>（1）标记清除算法</p>
<p>如果对象被标记后进行清除，会带来一个新的问题–内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p>
<p>（2）复制算法（Java堆中新生代的垃圾回收算法）</p>
<ol>
<li>先标记待回收内存和不用回收内存；</li>
<li>将不用回收的内存复制到新的内存区域；</li>
<li>就的内存区域就可以被全部回收了，而新的内存区域也是连续的；</li>
</ol>
<p>缺点是损失部分系统内存，因为腾出部分内存进行复制。</p>
<p>（3）标记压缩算法（Java堆中老年代的垃圾回收算法）</p>
<p>对于新生代，大部分对象都不会存活，所以复制算法较高效，但对于老年代，大部分对象可能要继续存活，如果此时使用复制算法，效率会降低。</p>
<p>标记压缩算法首先还是标记，将不用回收的内存对象压缩到内存一端，此时即可清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。</p>
<p>老年代的垃圾回收算法称为“Major GC”。</p>
<h3 id="187、说一下-jvm-有哪些垃圾回收器？"><a href="#187、说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="187、说一下 jvm 有哪些垃圾回收器？"></a>187、说一下 jvm 有哪些垃圾回收器？</h3><p><a href="https://blog.csdn.net/guorui_java/article/details/108405844">说一下 jvm 有哪些垃圾回收器？</a></p>
<h3 id="188、JVM栈堆概念，何时销毁对象"><a href="#188、JVM栈堆概念，何时销毁对象" class="headerlink" title="188、JVM栈堆概念，何时销毁对象"></a>188、JVM栈堆概念，何时销毁对象</h3><ol>
<li>类在程序运行的时候就会被加载，方法是在执行的时候才会被加载，如果没有任何引用了，Java自动垃圾回收，也可以用System.gc()开启回收器，但是回收器不一定会马上回收。</li>
<li>静态变量在类装载的时候进行创建，在整个程序结束时按序销毁；</li>
<li>实例变量在类实例化对象时创建，在对象销毁的时候销毁；</li>
<li>局部变量在局部范围内使用时创建，跳出局部范围时销毁；</li>
</ol>
<h3 id="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>新生代回收器一般采用的是复制算法，复制算法效率较高，但是浪费内存；</p>
<p>老生代回收器一般采用标记清楚算法，比如最常用的CMS；</p>
<h3 id="190、详细介绍一下-CMS-垃圾回收器？"><a href="#190、详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="190、详细介绍一下 CMS 垃圾回收器？"></a>190、详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 垃圾回收器是Concurrent Mark Sweep，是一种同步的标记-清除，CMS分为四个阶段：</p>
<p>初始标记，标记一下GC Root能直接关联到的对象，会触发“Stop The World”；<br>并发标记，通过GC Roots Tracing判断对象是否在使用中；<br>重新标记，标记期间产生对象的再次判断，执行时间较短，会触发“Stop The World”；<br>并发清除，清除对象，可以和用户线程并发进行；</p>
<h3 id="191、简述分代垃圾回收器是怎么工作的？"><a href="#191、简述分代垃圾回收器是怎么工作的？" class="headerlink" title="191、简述分代垃圾回收器是怎么工作的？"></a>191、简述分代垃圾回收器是怎么工作的？</h3><p>分代回收器分为新生代和老年代，新生代大概占1&#x2F;3，老年代大概占2&#x2F;3；</p>
<p>新生代包括Eden、From Survivor、To Survivor；</p>
<p>Eden区和两个survivor区的 的空间比例 为8：1：1 ；</p>
<p>垃圾回收器的执行流程：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden + From Survivor 分区，From Survivor 和 To Survivor 分区交换；<br>每次交换后存活的对象年龄+1，到达15，升级为老年代，大对象会直接进入老年代；<br>老年代中当空间到达一定占比，会触发全局回收，老年代一般采取标记-清除算法；</p>
<h3 id="192、Redis是什么？"><a href="#192、Redis是什么？" class="headerlink" title="192、Redis是什么？"></a>192、Redis是什么？</h3><p>Redis是一个key-value存储系统，它支持存储的value类型相对更多，包括string、list、set、zset（sorted set –有序集合）和hash。这些数据结构都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中，Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
<h3 id="193、Redis都有哪些使用场景？"><a href="#193、Redis都有哪些使用场景？" class="headerlink" title="193、Redis都有哪些使用场景？"></a>193、Redis都有哪些使用场景？</h3><ol>
<li>Redis是基于内存的nosql数据库，可以通过新建线程的形式进行持久化，不影响Redis单线程的读写操作</li>
<li>通过list取最新的N条数据</li>
<li>模拟类似于token这种需要设置过期时间的场景</li>
<li>发布订阅消息系统</li>
<li>定时器、计数器</li>
</ol>
<h3 id="194、Redis有哪些功能？"><a href="#194、Redis有哪些功能？" class="headerlink" title="194、Redis有哪些功能？"></a>194、Redis有哪些功能？</h3><p>1、基于本机内存的缓存</p>
<p>当调用api访问数据库时，假如此过程需要2秒，如果每次请求都要访问数据库，那将对服务器造成巨大的压力，如果将此sql的查询结果存到Redis中，再次请求时，直接从Redis中取得，而不是访问数据库，效率将得到巨大的提升，Redis可以定时去更新数据（比如1分钟）。</p>
<p>2、如果电脑重启，写入内存的数据是不是就失效了呢，这时Redis还提供了持久化的功能。</p>
<p>3、哨兵（Sentinel）和复制</p>
<p>Sentinel可以管理多个Redis服务器，它提供了监控、提醒以及自动的故障转移功能；</p>
<p>复制则是让Redis服务器可以配备备份的服务器；</p>
<p>Redis也是通过这两个功能保证Redis的高可用；</p>
<p>4、集群（Cluster）</p>
<p>单台服务器资源总是有上限的，CPU和IO资源可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，但是内存资源怎么办，主从模式只是数据的备份，并不能扩充内存；</p>
<p>现在我们可以横向扩展，让每台服务器只负责一部分任务，然后将这些服务器构成一个整体，对外界来说，这一组服务器就像是集群一样。</p>
<h3 id="195、Redis支持的数据类型有哪些？"><a href="#195、Redis支持的数据类型有哪些？" class="headerlink" title="195、Redis支持的数据类型有哪些？"></a>195、Redis支持的数据类型有哪些？</h3><ol>
<li>字符串</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset</li>
</ol>
<h3 id="196、Redis取值存值问题"><a href="#196、Redis取值存值问题" class="headerlink" title="196、Redis取值存值问题"></a>196、Redis取值存值问题</h3><p>1、先把Redis的连接池拿出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>(),<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br></pre></td></tr></table></figure>

<p>2、存取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">jedis.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">jedis.del(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">//给一个key叠加value</span></span><br><span class="line">jedis.append(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value2&quot;</span>);<span class="comment">//此时key的值就是value + value2;</span></span><br><span class="line"><span class="comment">//同时给多个key进行赋值：</span></span><br><span class="line">jedis.mset(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>3、对map进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">user.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line"><span class="comment">//存入</span></span><br><span class="line">jedis.hmset(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"><span class="comment">//取出user中key1 </span></span><br><span class="line">List&lt;String&gt; nameMap = jedis.hmget(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="comment">//删除其中一个键值</span></span><br><span class="line">jedis.hdel(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;key2&quot;</span>);</span><br><span class="line"><span class="comment">//是否存在一个键</span></span><br><span class="line">jedis.exists(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="comment">//取出所有的Map中的值：</span></span><br><span class="line">Iterator&lt;String&gt; iter = jedis.hkeys(<span class="string">&quot;user&quot;</span>).iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.next())&#123;</span><br><span class="line">    jedis.hmget(<span class="string">&quot;user&quot;</span>,iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="197、Redis为什么是单线程的？"><a href="#197、Redis为什么是单线程的？" class="headerlink" title="197、Redis为什么是单线程的？"></a>197、Redis为什么是单线程的？</h3><ol>
<li>代码更清晰，处理逻辑更简单；</li>
<li>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能问题；</li>
<li>不存在多线程切换而消耗CPU；</li>
<li>无法发挥多核CPU的优势，但可以采用多开几个Redis实例来完善；</li>
</ol>
<h3 id="198、Redis真的是单线程的吗？"><a href="#198、Redis真的是单线程的吗？" class="headerlink" title="198、Redis真的是单线程的吗？"></a>198、Redis真的是单线程的吗？</h3><p>Redis6.0之前是单线程的，Redis6.0之后开始支持多线程；<br>redis内部使用了基于<a href="https://baike.baidu.com/item/epoll/10738144?fr=aladdin">epoll</a>的多路服用，也可以多部署几个redis服务器解决单线程的问题；<br>redis主要的性能瓶颈是内存和网络；<br>内存好说，加内存条就行了，而网络才是大麻烦，所以redis6内存好说，加内存条就行了；<br>而网络才是大麻烦，所以redis6.0引入了多线程的概念，<br>redis6.0在网络IO处理方面引入了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。</p>
<h3 id="199、Redis持久化有几种方式？"><a href="#199、Redis持久化有几种方式？" class="headerlink" title="199、Redis持久化有几种方式？"></a>199、Redis持久化有几种方式？</h3><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p>
<p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p>
<p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p>
<p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p>
<h3 id="200、Redis和-memecache-有什么区别？"><a href="#200、Redis和-memecache-有什么区别？" class="headerlink" title="200、Redis和 memecache 有什么区别？"></a>200、Redis和 memecache 有什么区别？</h3><p>1、Redis相比memecache，拥有更多的数据结构和支持更丰富的数据操作。</p>
<p>（1）Redis支持key-value，常用的数据类型主要有String、Hash、List、Set、Sorted Set。</p>
<p>（2）memecache只支持key-value。</p>
<p>2、内存使用率对比，Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memecache。</p>
<p>3、性能对比：Redis只使用单核，memecache使用多核。</p>
<p>4、Redis支持磁盘持久化，memecache不支持。</p>
<p>Redis可以将一些很久没用到的value通过swap方法交换到磁盘。</p>
<p>5、Redis支持分布式集群，memecache不支持。</p>
<h3 id="201、Redis支持的-java-客户端都有哪些？"><a href="#201、Redis支持的-java-客户端都有哪些？" class="headerlink" title="201、Redis支持的 java 客户端都有哪些？"></a>201、Redis支持的 java 客户端都有哪些？</h3><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p>
<h3 id="202、jedis-和-redisson-有哪些区别？"><a href="#202、jedis-和-redisson-有哪些区别？" class="headerlink" title="202、jedis 和 redisson 有哪些区别？"></a>202、jedis 和 redisson 有哪些区别？</h3><p>Jedis 和 Redisson 都是Java中对Redis操作的封装。Jedis 只是简单的封装了 Redis 的API库，可以看作是Redis客户端，它的方法和Redis 的命令很类似。Redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于Jedis 更加大。但Jedis相比于Redisson 更原生一些，更灵活。</p>
<h3 id="203、Redis中什么是缓存穿透？怎么解决？"><a href="#203、Redis中什么是缓存穿透？怎么解决？" class="headerlink" title="203、Redis中什么是缓存穿透？怎么解决？"></a>203、Redis中什么是缓存穿透？怎么解决？</h3><p>1、缓存穿透</p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对用的value，就应该去后端系统查找（比如DB数据库）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>2、怎么解决？</p>
<p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。</p>
<p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</p>
<h3 id="204、怎么保证缓存和数据库数据的一致性？"><a href="#204、怎么保证缓存和数据库数据的一致性？" class="headerlink" title="204、怎么保证缓存和数据库数据的一致性？"></a>204、怎么保证缓存和数据库数据的一致性？</h3><p>1、淘汰缓存</p>
<p>数据如果为较为复杂的数据时，进行缓存的更新操作就会变得异常复杂，因此一般推荐选择淘汰缓存，而不是更新缓存。</p>
<p>2、选择先淘汰缓存，再更新数据库</p>
<p>假如先更新数据库，再淘汰缓存，如果淘汰缓存失败，那么后面的请求都会得到脏数据，直至缓存过期。</p>
<p>假如先淘汰缓存再更新数据库，如果更新数据库失败，只会产生一次缓存穿透，相比较而言，后者对业务则没有本质上的影响。</p>
<p>3、延时双删策略</p>
<p>如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>次数便出现了数据不一致问题。采用延时双删策略得以解决:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>&#123;</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">    db.update(data);</span><br><span class="line">    Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可根据俄业务场景进行一个调节。</p>
<p>4、数据库读写分离的场景</p>
<p>两个请求，一个请求A进行更新操作，另一个请求B进行查询操作：</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求A将数据写入数据库了</li>
<li>请求B查询缓存发现，缓存没有值</li>
<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>
<li>请求B将旧值写入缓存</li>
<li>数据库完成主从同步，从库变为新值</li>
</ol>
<p>依旧采用延时双删策略解决此问题。</p>
<h3 id="205、Redis中什么是缓存雪崩？怎么解决？"><a href="#205、Redis中什么是缓存雪崩？怎么解决？" class="headerlink" title="205、Redis中什么是缓存雪崩？怎么解决？"></a>205、Redis中什么是缓存雪崩？怎么解决？</h3><p>1、缓存雪崩</p>
<p>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来很大的压力，导致系统崩溃。</p>
<p>2、如何解决？</p>
<ol>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其它线程等待；</li>
<li>做二级缓存；</li>
<li>不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀；</li>
</ol>
<h3 id="206、Redis怎么实现分布式锁？"><a href="#206、Redis怎么实现分布式锁？" class="headerlink" title="206、Redis怎么实现分布式锁？"></a>206、Redis怎么实现分布式锁？</h3><p>使用Redis实现分布式锁</p>
<p>redis命令：set users 10 nx ex 12   原子性命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用uuid，解决锁释放的问题</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b_lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(b_lock)&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lockUUID</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(uuid.equals(lockUUID.toString()))&#123;</span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        testLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>备注：可以通过lua脚本，保证分布式锁的原子性。</p>
<h3 id="207、Redis分布式锁有什么缺陷？"><a href="#207、Redis分布式锁有什么缺陷？" class="headerlink" title="207、Redis分布式锁有什么缺陷？"></a>207、Redis分布式锁有什么缺陷？</h3><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<p>Redis容易产生的几个问题：</p>
<ol>
<li>锁未被释放</li>
<li>B锁被A锁释放了</li>
<li>数据库事务超时</li>
<li>锁过期了，业务还没执行完</li>
<li>Redis主从复制的问题</li>
</ol>
<h3 id="208、Redis如何做内存优化？"><a href="#208、Redis如何做内存优化？" class="headerlink" title="208、Redis如何做内存优化？"></a>208、Redis如何做内存优化？</h3><p>1、缩短键值的长度</p>
<ol>
<li>缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；</li>
<li>首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；</li>
<li>其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；</li>
<li>以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等</li>
</ol>
<p>2、共享对象池</p>
<p>对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。</p>
<p>3、字符串优化</p>
<p>4、编码优化</p>
<p>5、控制key的数量</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
